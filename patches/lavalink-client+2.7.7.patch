diff --git a/node_modules/lavalink-client/dist/index.d.mts b/node_modules/lavalink-client/dist/index.d.mts
index 7e40972..8d31168 100644
--- a/node_modules/lavalink-client/dist/index.d.mts
+++ b/node_modules/lavalink-client/dist/index.d.mts
@@ -1,5 +1,297 @@
 import { EventEmitter } from 'events';
 
+/** The Audio Outputs type */
+type AudioOutputs = "mono" | "stereo" | "left" | "right";
+/** The "active" / "disabled" Player Filters */
+interface PlayerFilters {
+    /** Sets nightcore to false, and vaporwave to false */
+    custom: boolean;
+    /** Sets custom to false, and vaporwave to false */
+    nightcore: boolean;
+    /** Sets custom to false, and nightcore to false */
+    vaporwave: boolean;
+    /** If rotation filter is enabled / not */
+    rotation: boolean;
+    /** if karaoke filter is enabled / not */
+    karaoke: boolean;
+    /** if tremolo filter is enabled / not */
+    tremolo: boolean;
+    /** if vibrato filter is enabled / not */
+    vibrato: boolean;
+    lowPass: boolean;
+    /** audio Output (default stereo, mono sounds the fullest and best for not-stereo tracks) */
+    audioOutput: AudioOutputs;
+    /** Lavalink Volume FILTER (not player Volume, think of it as a gain booster) */
+    volume: boolean;
+    /** Filters for the Lavalink Filter Plugin */
+    lavalinkFilterPlugin: {
+        /** if echo filter is enabled / not */
+        echo: boolean;
+        /** if reverb filter is enabled / not */
+        reverb: boolean;
+    };
+    lavalinkLavaDspxPlugin: {
+        /** if lowPass filter is enabled / not */
+        lowPass: boolean;
+        /** if highPass filter is enabled / not */
+        highPass: boolean;
+        /** if normalization filter is enabled / not */
+        normalization: boolean;
+        /** if echo filter is enabled / not */
+        echo: boolean;
+    };
+}
+/**
+ * There are 15 bands (0-14) that can be changed.
+ * "gain" is the multiplier for the given band.
+ * The default value is 0.
+ *  Valid values range from -0.25 to 1.0, where -0.25 means the given band is completely muted, and 0.25 means it is doubled.
+ * Modifying the gain could also change the volume of the output.
+ */
+interface EQBand {
+    /** On what band position (0-14) it should work */
+    band: IntegerNumber | number;
+    /** The gain (-0.25 to 1.0) */
+    gain: FloatNumber | number;
+}
+/**
+ * Uses equalization to eliminate part of a band, usually targeting vocals.
+ */
+interface KaraokeFilter {
+    /** The level (0 to 1.0 where 0.0 is no effect and 1.0 is full effect) */
+    level?: number;
+    /** The mono level (0 to 1.0 where 0.0 is no effect and 1.0 is full effect) */
+    monoLevel?: number;
+    /** The filter band (in Hz) */
+    filterBand?: number;
+    /**	The filter width */
+    filterWidth?: number;
+}
+/**
+ * Changes the speed, pitch, and rate
+ */
+interface TimescaleFilter {
+    /** The playback speed 0.0 ≤ x */
+    speed?: number;
+    /** The pitch 0.0 ≤ x */
+    pitch?: number;
+    /** The rate 0.0 ≤ x */
+    rate?: number;
+}
+/**
+ * Uses amplification to create a shuddering effect, where the volume quickly oscillates.
+ * Demo: https://en.wikipedia.org/wiki/File:Fuse_Electronics_Tremolo_MK-III_Quick_Demo.ogv
+ */
+interface TremoloFilter {
+    /** The frequency 0.0 < x */
+    frequency?: number;
+    /** The tremolo depth 0.0 < x ≤ 1.0 */
+    depth?: number;
+}
+/**
+ * Similar to tremolo. While tremolo oscillates the volume, vibrato oscillates the pitch.
+ */
+interface VibratoFilter {
+    /** The frequency 0.0 < x ≤ 14.0 */
+    frequency?: number;
+    /** The vibrato depth 0.0 < x ≤ 1.0 */
+    depth?: number;
+}
+/**
+ * Rotates the sound around the stereo channels/user headphones (aka Audio Panning).
+ * It can produce an effect similar to https://youtu.be/QB9EB8mTKcc (without the reverb).
+ */
+interface RotationFilter {
+    /** The frequency of the audio rotating around the listener in Hz. 0.2 is similar to the example video above */
+    rotationHz?: number;
+}
+/**
+ * Distortion effect. It can generate some pretty unique audio effects.
+ */
+interface DistortionFilter {
+    sinOffset?: number;
+    sinScale?: number;
+    cosOffset?: number;
+    cosScale?: number;
+    tanOffset?: number;
+    tanScale?: number;
+    offset?: number;
+    scale?: number;
+}
+/**
+ * Mixes both channels (left and right), with a configurable factor on how much each channel affects the other.
+ * With the defaults, both channels are kept independent of each other.
+ * Setting all factors to 0.5 means both channels get the same audio.
+ */
+interface ChannelMixFilter {
+    /** The left to left channel mix factor (0.0 ≤ x ≤ 1.0) */
+    leftToLeft?: number;
+    /** The left to right channel mix factor (0.0 ≤ x ≤ 1.0) */
+    leftToRight?: number;
+    /** The right to left channel mix factor (0.0 ≤ x ≤ 1.0) */
+    rightToLeft?: number;
+    /** The right to right channel mix factor (0.0 ≤ x ≤ 1.0) */
+    rightToRight?: number;
+}
+/**
+ * Higher frequencies get suppressed, while lower frequencies pass through this filter, thus the name low pass.
+ * Any smoothing values equal to or less than 1.0 will disable the filter.
+ */
+interface LowPassFilter {
+    /** The smoothing factor (1.0 < x) */
+    smoothing?: number;
+}
+/**
+ * Filter Data stored in the Client and partially sent to Lavalink
+ */
+interface FilterData {
+    volume?: number;
+    karaoke?: KaraokeFilter;
+    timescale?: TimescaleFilter;
+    tremolo?: TremoloFilter;
+    vibrato?: VibratoFilter;
+    rotation?: RotationFilter;
+    distortion?: DistortionFilter;
+    channelMix?: ChannelMixFilter;
+    lowPass?: LowPassFilter;
+    pluginFilters?: {
+        "lavalink-filter-plugin"?: {
+            "echo"?: {
+                delay?: number;
+                decay?: number;
+            };
+            "reverb"?: {
+                delays?: number[];
+                gains?: number[];
+            };
+        };
+        "high-pass"?: {
+            cutoffFrequency?: number;
+            boostFactor?: number;
+        };
+        "low-pass"?: {
+            cutoffFrequency?: number;
+            boostFactor?: number;
+        };
+        normalization?: {
+            maxAmplitude?: number;
+            adaptive?: boolean;
+        };
+        echo?: {
+            echoLength?: number;
+            decay?: number;
+        };
+    };
+}
+/**
+ * Actual Filter Data sent to Lavalink
+ */
+interface LavalinkFilterData extends FilterData {
+    equalizer?: EQBand[];
+}
+
+/**
+ * Debug events for more detailed logging
+ */
+declare enum DebugEvents {
+    SetSponsorBlock = "SetSponsorBlock",
+    DeleteSponsorBlock = "DeleteSponsorBlock",
+    TrackEndReplaced = "TrackEndReplaced",
+    AutoplayExecution = "AutoplayExecution",
+    AutoplayNoSongsAdded = "AutoplayNoSongsAdded",
+    AutoplayThresholdSpamLimiter = "AutoplayThresholdSpamLimiter",
+    TriggerQueueEmptyInterval = "TriggerQueueEmptyInterval",
+    QueueEnded = "QueueEnded",
+    TrackStartNewSongsOnly = "TrackStartNewSongsOnly",
+    TrackStartNoTrack = "TrackStartNoTrack",
+    ResumingFetchingError = "ResumingFetchingError",
+    PlayerUpdateNoPlayer = "PlayerUpdateNoPlayer",
+    PlayerUpdateFilterFixApply = "PlayerUpdateFilterFixApply",
+    PlayerUpdateSuccess = "PlayerUpdateSuccess",
+    HeartBeatTriggered = "HeartBeatTriggered",
+    NoSocketOnDestroy = "NoSocketOnDestroy",
+    SocketCleanupError = "SocketCleanupError",
+    SocketTerminateHeartBeatTimeout = "SocketTerminateHeartBeatTimeout",
+    TryingConnectWhileConnected = "TryingConnectWhileConnected",
+    LavaSearchNothingFound = "LavaSearchNothingFound",
+    SearchNothingFound = "SearchNothingFound",
+    ValidatingBlacklistLinks = "ValidatingBlacklistLinks",
+    ValidatingWhitelistLinks = "ValidatingWhitelistLinks",
+    TrackErrorMaxTracksErroredPerTime = "TrackErrorMaxTracksErroredPerTime",
+    TrackStuckMaxTracksErroredPerTime = "TrackStuckMaxTracksErroredPerTime",
+    PlayerDestroyingSomewhereElse = "PlayerDestroyingSomewhereElse",
+    PlayerCreateNodeNotFound = "PlayerCreateNodeNotFound",
+    PlayerPlayQueueEmptyTimeoutClear = "PlayerPlayQueueEmptyTimeoutClear",
+    PlayerPlayWithTrackReplace = "PlayerPlayWithTrackReplace",
+    PlayerPlayUnresolvedTrack = "PlayerPlayUnresolvedTrack",
+    PlayerPlayUnresolvedTrackFailed = "PlayerPlayUnresolvedTrackFailed",
+    PlayerVolumeAsFilter = "PlayerVolumeAsFilter",
+    BandcampSearchLokalEngine = "BandcampSearchLokalEngine",
+    PlayerChangeNode = "PlayerChangeNode",
+    BuildTrackError = "BuildTrackError",
+    TransformRequesterFunctionFailed = "TransformRequesterFunctionFailed",
+    GetClosestTrackFailed = "GetClosestTrackFailed",
+    PlayerDeleteInsteadOfDestroy = "PlayerDeleteInsteadOfDestroy",
+    FailedToConnectToNodes = "FailedToConnectToNodes",
+    NoAudioDebug = "NoAudioDebug",
+    PlayerAutoReconnect = "PlayerAutoReconnect"
+}
+/**
+ * Reasons why a player got destroyed
+ */
+declare enum DestroyReasons {
+    QueueEmpty = "QueueEmpty",
+    NodeDestroy = "NodeDestroy",
+    NodeDeleted = "NodeDeleted",
+    LavalinkNoVoice = "LavalinkNoVoice",
+    NodeReconnectFail = "NodeReconnectFail",
+    Disconnected = "Disconnected",
+    PlayerReconnectFail = "PlayerReconnectFail",
+    PlayerChangeNodeFail = "PlayerChangeNodeFail",
+    PlayerChangeNodeFailNoEligibleNode = "PlayerChangeNodeFailNoEligibleNode",
+    ChannelDeleted = "ChannelDeleted",
+    DisconnectAllNodes = "DisconnectAllNodes",
+    ReconnectAllNodes = "ReconnectAllNodes",
+    TrackErrorMaxTracksErroredPerTime = "TrackErrorMaxTracksErroredPerTime",
+    TrackStuckMaxTracksErroredPerTime = "TrackStuckMaxTracksErroredPerTime"
+}
+/**
+ *  Reasons why a player got disconnected
+ */
+declare enum DisconnectReasons {
+    Disconnected = "Disconnected",
+    DisconnectAllNodes = "DisconnectAllNodes"
+}
+/** The valid SponsorBlock categories */
+declare const validSponsorBlocks: string[];
+/**  The audio Outputs Data map declaration */
+declare const audioOutputsData: Record<AudioOutputs, ChannelMixFilter>;
+/**  Equalizer Presets */
+declare const EQList: {
+    /** A Bassboost Equalizer, so high it distorts the audio */
+    BassboostEarrape: EQBand[];
+    /** A High and decent Bassboost Equalizer */
+    BassboostHigh: EQBand[];
+    /** A decent Bassboost Equalizer */
+    BassboostMedium: EQBand[];
+    /** A slight Bassboost Equalizer */
+    BassboostLow: EQBand[];
+    /** Makes the Music slightly "better" */
+    BetterMusic: EQBand[];
+    /** Makes the Music sound like rock music / sound rock music better */
+    Rock: EQBand[];
+    /** Makes the Music sound like Classic music / sound Classic music better */
+    Classic: EQBand[];
+    /** Makes the Music sound like Pop music / sound Pop music better */
+    Pop: EQBand[];
+    /** Makes the Music sound like Electronic music / sound Electronic music better */
+    Electronic: EQBand[];
+    /** Boosts all Bands slightly for louder and fuller sound */
+    FullSound: EQBand[];
+    /** Boosts basses + lower highs for a pro gaming sound */
+    Gaming: EQBand[];
+};
+
 declare class FilterManager {
     static EQList: {
         BassboostEarrape: EQBand[];
@@ -24,15 +316,6 @@ declare class FilterManager {
     data: FilterData;
     /** The Player assigned to this Filter Manager */
     player: Player;
-    private get _LManager();
-    /**
-     * Returns wether the plugin validations are enabled or not
-     */
-    private get _checkForPlugins();
-    /**
-     * Returns wether the source validations are enabled or not
-     */
-    private get _checkForSources();
     /** The Constructor for the FilterManager */
     constructor(player: Player);
     /**
@@ -50,8 +333,7 @@ declare class FilterManager {
      * ```
      */
     applyPlayerFilters(): Promise<void>;
-    private privateNot0;
-    private getLavalinkFilterData;
+    privateNot0(value: number | undefined): boolean;
     /**
      * Checks if the filters are correctly stated (active / not-active) - mostly used internally.
      * @param oldFilterTimescale
@@ -208,385 +490,219 @@ declare class FilterManager {
      * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
      * ```
      */
-    toggleLowPass(smoothing?: number): Promise<FilterManager>;
-    /**
-     * Lavalink LavaDspx Plugin Filters
-     */
-    lavalinkLavaDspxPlugin: {
-        /**
-         * Enables / Disables the LowPass effect, (Optional: provide your Own Data)
-         * @param {number} boostFactor set the boost factor of the filter
-         * @param {number} cutoffFrequency set the cutoff frequency of the filter
-         * @returns  {Promise<boolean>} the state of the filter after execution.
-         *
-         * @example
-         * ```ts
-         * // Toggle LowPass filter with custom settings
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleLowPass(1.2, 300);
-         * // or use the defaults
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleLowPass();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleLowPass: (boostFactor?: number, cutoffFrequency?: number) => Promise<FilterManager>;
-        /**
-         * Enables / Disables the HighPass effect, (Optional: provide your Own Data)
-         * @param {number} boostFactor [] set the boost factor of the filter
-         * @param {number} cutoffFrequency set the cutoff frequency of the filter
-         * @returns  {Promise<boolean>} the state of the filter after execution.
-         *
-         * @example
-         * ```ts
-         * // Toggle HighPass filter with custom settings
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleHighPass(1.2, 150); // custom values
-         * // or use the defaults
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleHighPass();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleHighPass: (boostFactor?: number, cutoffFrequency?: number) => Promise<FilterManager>;
-        /**
-         * Enables / Disables the Normalization effect.
-         * @param {number} [maxAmplitude=0.75] - The maximum amplitude of the audio.
-         * @param {boolean} [adaptive=true] Whether to use adaptive normalization or not.
-         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-         *
-         * @example
-         * ```ts
-         * // Toggle Normalization filter with custom settings
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleNormalization(0.9, false); // custom values
-         * // or use the defaults
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleNormalization();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleNormalization: (maxAmplitude?: number, adaptive?: boolean) => Promise<FilterManager>;
-        /**
-         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
-         * @param {number} [decay=0.5] The decay of the echo effect.
-         * @param {number} [echoLength=0.5] The length of the echo effect.
-         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-         *
-         * @example
-         * ```ts
-         * // Toggle Echo filter with custom settings
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleEcho(0.7, 0.6); // custom values
-         * // or use the defaults
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleEcho();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleEcho: (decay?: number, echoLength?: number) => Promise<FilterManager>;
-    };
-    /**
-     * LavalinkFilter Plugin specific Filters
-     */
-    lavalinkFilterPlugin: {
-        /**
-         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
-         * @param {number} delay set the delay of the echo
-         * @param {number} decay set the decay of the echo
-         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-         *
-         * @example
-         * ```ts
-         * // Toggle Echo filter with custom settings
-         * await player.filterManager.lavalinkFilterPlugin.toggleEcho(3, 0.7); // custom values
-         * // or use the defaults
-         * await player.filterManager.lavalinkFilterPlugin.toggleEcho();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleEcho: (delay?: number, decay?: number) => Promise<FilterManager>;
-        /**
-         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
-         * @param {number} delays set the delays of the reverb
-         * @param {number} gains set the gains of the reverb
-         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-         *
-         * @example
-         * ```ts
-         * // Toggle Reverb filter with custom settings
-         * await player.filterManager.lavalinkFilterPlugin.toggleReverb([0.04, 0.045, 0.05, 0.055], [0.85, 0.84, 0.83, 0.82]);
-         * // or use the defaults
-         * await player.filterManager.lavalinkFilterPlugin.toggleReverb();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleReverb: (delays?: number[], gains?: number[]) => Promise<FilterManager>;
-    };
-    /**
-     * Enables / Disables a Nightcore-like filter Effect. Disables/Overrides both: custom and Vaporwave Filter
-     * @param {number} speed set the speed of the filter
-     * @param {number} pitch set the pitch of the filter
-     * @param {number} rate set the rate of the filter
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Toggle Nightcore filter with custom settings
-     * await player.filterManager.toggleNightcore(1.3, 1.3, 0.9);
-     * // or use the defaults
-     * await player.filterManager.toggleNightcore();
-     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-     * ```
-     */
-    toggleNightcore(speed?: number, pitch?: number, rate?: number): Promise<FilterManager>;
-    /**
-     * Enables / Disables a Vaporwave-like filter Effect. Disables/Overrides both: custom and nightcore Filter
-     * @param {number} speed set the speed of the filterq
-     * @param {number} pitch set the pitch of the filter
-     * @param {number} rate set the rate of the filter
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Toggle Vaporwave filter with custom settings
-     * await player.filterManager.toggleVaporwave(0.9, 0.7, 1);
-     * // or use the defaults
-     * await player.filterManager.toggleVaporwave();
-     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-     * ```
-     */
-    toggleVaporwave(speed?: number, pitch?: number, rate?: number): Promise<FilterManager>;
-    /**
-     * Enable / Disables a Karaoke like Filter Effect
-     * @param {number} level set the level of the filter
-     * @param {number} monoLevel set the mono level of the filter
-     * @param {number} filterBand set the filter band of the filter
-     * @param {number} filterWidth set the filter width of the filter
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Toggle Karaoke filter with custom settings
-     * await player.filterManager.toggleKaraoke(1.5, 1.0, 220, 100);
-     * // or use the defaults
-     * await player.filterManager.toggleKaraoke();
-     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-     * ```
-     */
-    toggleKaraoke(level?: number, monoLevel?: number, filterBand?: number, filterWidth?: number): Promise<FilterManager>;
-    /**
-     * Function to find out if currently there is a custom timescamle etc. filter applied
-     * @returns {boolean} whether a custom filter is active
-     *
-     * @example
-     * ```ts
-     * // Check if a custom filter is active
-     * const isCustom = player.filterManager.isCustomFilterActive();
-     * console.log(`Is custom filter active? ${isCustom}`);
-     * ```
-     */
-    isCustomFilterActive(): boolean;
-    /**
-     * Sets the players equalizer bands using one of the predefined presets.
-     * @param {keyof typeof EQList} preset The preset to use.
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Set EQ preset
-     * await player.filterManager.setEQPreset('BassboostMedium');
-     * ```
-     */
-    setEQPreset(preset: keyof typeof EQList): Promise<this>;
-    /**
-     * Sets the players equalizer band on-top of the existing ones.
-     * @param {number} bands
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Set EQ bands
-     * await player.filterManager.setEQ([
-     *   { band: 0, gain: 0.3 },
-     *   { band: 1, gain: -0.2 },
-     *   { band: 2, gain: 0.1 }
-     * ]);
-     *
-     * // or use one of the templates:
-     * await player.filterManager.setEQ(player.filterManager.EQList.BassboostMedium); // you can also import EQList from somewhere package if wanted.
-     * ```
-     */
-    setEQ(bands: EQBand | EQBand[]): Promise<this>;
-    /**
-     * Clears the equalizer bands.
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Clear all EQ bands
-     * await player.filterManager.clearEQ();
-     * ```
+    toggleLowPass(smoothing?: number): Promise<FilterManager>;
+    /**
+     * Lavalink LavaDspx Plugin Filters
      */
-    clearEQ(): Promise<this>;
-}
-
-/** Sourcenames provided by lavalink server */
-type LavalinkSourceNames = "youtube" | "youtubemusic" | "soundcloud" | "bandcamp" | "twitch";
-/** Source Names provided by lava src plugin */
-type LavalinkPlugin_LavaSrc_SourceNames = "deezer" | "spotify" | "applemusic" | "yandexmusic" | "flowery-tts" | "vkmusic" | "tidal" | "qobuz" | "pandora";
-/** Source Names provided by jiosaavan plugin */
-type LavalinkPlugin_JioSaavn_SourceNames = "jiosaavn";
-/** The SourceNames provided by lavalink */
-type SourceNames = LavalinkSourceNames | LavalinkPlugin_LavaSrc_SourceNames | LavalinkPlugin_JioSaavn_SourceNames;
-interface LavalinkTrackInfo {
-    /** The Identifier of the Track */
-    identifier: string;
-    /** The Track Title / Name */
-    title: string;
-    /** The Name of the Author */
-    author: string;
-    /** The duration of the Track */
-    length: number;
-    /** The URL of the artwork if available */
-    artworkUrl: string | null;
-    /** The URL (aka Link) of the Track called URI */
-    uri: string;
-    /** The Source name of the Track, e.g. soundcloud, youtube, spotify */
-    sourceName: SourceNames;
-    /** Wether the audio is seekable */
-    isSeekable: boolean;
-    /** Wether the audio is of a live stream */
-    isStream: boolean;
-    /** If isrc code is available, it's provided */
-    isrc: string | null;
-}
-interface TrackInfo {
-    /** The Identifier of the Track */
-    identifier: string;
-    /** The Track Title / Name */
-    title: string;
-    /** The Name of the Author */
-    author: string;
-    /** The duration of the Track */
-    duration: number;
-    /** The URL of the artwork if available */
-    artworkUrl: string | null;
-    /** The URL (aka Link) of the Track called URI */
-    uri: string;
-    /** The Source name of the Track, e.g. soundcloud, youtube, spotify */
-    sourceName: SourceNames;
-    /** Wether the audio is seekable */
-    isSeekable: boolean;
-    /** Wether the audio is of a live stream */
-    isStream: boolean;
-    /** If isrc code is available, it's provided */
-    isrc: string | null;
-}
-interface PluginInfo {
-    /** The Type provided by a plugin */
-    type?: "album" | "playlist" | "artist" | "recommendations" | string;
-    /** The Identifier provided by a plugin */
-    albumName?: string;
-    /** The url of the album */
-    albumUrl?: string;
-    /** The url of the album art */
-    albumArtUrl?: string;
-    /** The url of the artist */
-    artistUrl?: string;
-    /** The url of the artist artwork */
-    artistArtworkUrl?: string;
-    /** The url of the preview */
-    previewUrl?: string;
-    /** Whether the track is a preview */
-    isPreview?: boolean;
-    /** The total number of tracks in the playlist */
-    totalTracks?: number;
-    /** The Identifier provided by a plugin */
-    identifier?: string;
-    /** The ArtworkUrl provided by a plugin */
-    artworkUrl?: string;
-    /** The Author Information provided by a plugin */
-    author?: string;
-    /** The Url provided by a Plugin */
-    url?: string;
-    /** The Url provided by a Plugin */
-    uri?: string;
-    /** You can put specific track information here, to transform the tracks... */
-    clientData?: {
-        previousTrack?: boolean;
-        [key: string]: any;
+    lavalinkLavaDspxPlugin: {
+        /**
+         * Enables / Disables the LowPass effect, (Optional: provide your Own Data)
+         * @param {number} boostFactor set the boost factor of the filter
+         * @param {number} cutoffFrequency set the cutoff frequency of the filter
+         * @returns  {Promise<boolean>} the state of the filter after execution.
+         *
+         * @example
+         * ```ts
+         * // Toggle LowPass filter with custom settings
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleLowPass(1.2, 300);
+         * // or use the defaults
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleLowPass();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleLowPass: (boostFactor?: number, cutoffFrequency?: number) => Promise<FilterManager>;
+        /**
+         * Enables / Disables the HighPass effect, (Optional: provide your Own Data)
+         * @param {number} boostFactor [] set the boost factor of the filter
+         * @param {number} cutoffFrequency set the cutoff frequency of the filter
+         * @returns  {Promise<boolean>} the state of the filter after execution.
+         *
+         * @example
+         * ```ts
+         * // Toggle HighPass filter with custom settings
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleHighPass(1.2, 150); // custom values
+         * // or use the defaults
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleHighPass();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleHighPass: (boostFactor?: number, cutoffFrequency?: number) => Promise<FilterManager>;
+        /**
+         * Enables / Disables the Normalization effect.
+         * @param {number} [maxAmplitude=0.75] - The maximum amplitude of the audio.
+         * @param {boolean} [adaptive=true] Whether to use adaptive normalization or not.
+         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+         *
+         * @example
+         * ```ts
+         * // Toggle Normalization filter with custom settings
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleNormalization(0.9, false); // custom values
+         * // or use the defaults
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleNormalization();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleNormalization: (maxAmplitude?: number, adaptive?: boolean) => Promise<FilterManager>;
+        /**
+         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
+         * @param {number} [decay=0.5] The decay of the echo effect.
+         * @param {number} [echoLength=0.5] The length of the echo effect.
+         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+         *
+         * @example
+         * ```ts
+         * // Toggle Echo filter with custom settings
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleEcho(0.7, 0.6); // custom values
+         * // or use the defaults
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleEcho();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleEcho: (decay?: number, echoLength?: number) => Promise<FilterManager>;
     };
-}
-interface LavalinkTrack {
-    /** The Base 64 encoded String */
-    encoded?: Base64;
-    /** Track Information */
-    info: LavalinkTrackInfo;
-    /** Plugin Information from Lavalink */
-    pluginInfo: Partial<PluginInfo>;
-    /** The userData Object from when you provide to the lavalink request */
-    userData?: anyObject;
-}
-interface Track {
-    /** The Base 64 encoded String */
-    encoded?: Base64;
-    /** Track Information */
-    info: TrackInfo;
-    /** Plugin Information from Lavalink */
-    pluginInfo: Partial<PluginInfo>;
-    /** The Track's Requester */
-    requester?: unknown;
-    /** The userData Object from when you provide to the lavalink request */
-    userData?: anyObject;
-}
-interface UnresolvedTrackInfo extends Partial<TrackInfo> {
-    /** Required */
-    title: string;
-}
-interface UnresolvedQuery extends UnresolvedTrackInfo {
-    /** The base64 of the unresolved track to "encode" */
-    encoded?: Base64;
-}
-interface UnresolvedTrack {
-    /** Required */
-    resolve: (player: Player) => Promise<void>;
-    /** The Base 64 encoded String */
-    encoded?: Base64;
-    /** Track Information */
-    info: UnresolvedTrackInfo;
-    /** Plugin Information from Lavalink */
-    pluginInfo: Partial<PluginInfo>;
-    /** The userData Object from when you provide to the lavalink request */
-    userData?: anyObject;
-    /** The Track's Requester */
-    requester?: unknown;
-}
-
-interface StoredQueue {
-    current: Track | null;
-    previous: Track[];
-    tracks: (Track | UnresolvedTrack)[];
-}
-interface QueueStoreManager {
-    /** @async get a Value (MUST RETURN UNPARSED!) */
-    get: (guildId: string) => Awaitable<StoredQueue | string | undefined>;
-    /** @async Set a value inside a guildId (MUST BE UNPARSED) */
-    set: (guildId: string, value: StoredQueue | string) => Awaitable<void | boolean>;
-    /** @async Delete a Database Value based of it's guildId */
-    delete: (guildId: string) => Awaitable<void | boolean>;
-    /** @async Transform the value(s) inside of the QueueStoreManager (IF YOU DON'T NEED PARSING/STRINGIFY, then just return the value) */
-    stringify: (value: StoredQueue | string) => Awaitable<StoredQueue | string>;
-    /** @async Parse the saved value back to the Queue (IF YOU DON'T NEED PARSING/STRINGIFY, then just return the value) */
-    parse: (value: StoredQueue | string) => Awaitable<Partial<StoredQueue>>;
-}
-interface ManagerQueueOptions {
-    /** Maximum Amount of tracks for the queue.previous array. Set to 0 to not save previous songs. Defaults to 25 Tracks */
-    maxPreviousTracks?: number;
-    /** Custom Queue Store option */
-    queueStore?: QueueStoreManager;
-    /** Custom Queue Watcher class */
-    queueChangesWatcher?: QueueChangesWatcher;
-}
-interface QueueChangesWatcher {
-    /** get a Value (MUST RETURN UNPARSED!) */
-    tracksAdd: (guildId: string, tracks: (Track | UnresolvedTrack)[], position: number, oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
-    /** Set a value inside a guildId (MUST BE UNPARSED) */
-    tracksRemoved: (guildId: string, tracks: (Track | UnresolvedTrack)[], position: number | number[], oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
-    /** Set a value inside a guildId (MUST BE UNPARSED) */
-    shuffled: (guildId: string, oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
+    /**
+     * LavalinkFilter Plugin specific Filters
+     */
+    lavalinkFilterPlugin: {
+        /**
+         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
+         * @param {number} delay set the delay of the echo
+         * @param {number} decay set the decay of the echo
+         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+         *
+         * @example
+         * ```ts
+         * // Toggle Echo filter with custom settings
+         * await player.filterManager.lavalinkFilterPlugin.toggleEcho(3, 0.7); // custom values
+         * // or use the defaults
+         * await player.filterManager.lavalinkFilterPlugin.toggleEcho();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleEcho: (delay?: number, decay?: number) => Promise<FilterManager>;
+        /**
+         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
+         * @param {number} delays set the delays of the reverb
+         * @param {number} gains set the gains of the reverb
+         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+         *
+         * @example
+         * ```ts
+         * // Toggle Reverb filter with custom settings
+         * await player.filterManager.lavalinkFilterPlugin.toggleReverb([0.04, 0.045, 0.05, 0.055], [0.85, 0.84, 0.83, 0.82]);
+         * // or use the defaults
+         * await player.filterManager.lavalinkFilterPlugin.toggleReverb();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleReverb: (delays?: number[], gains?: number[]) => Promise<FilterManager>;
+    };
+    /**
+     * Enables / Disables a Nightcore-like filter Effect. Disables/Overrides both: custom and Vaporwave Filter
+     * @param {number} speed set the speed of the filter
+     * @param {number} pitch set the pitch of the filter
+     * @param {number} rate set the rate of the filter
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Toggle Nightcore filter with custom settings
+     * await player.filterManager.toggleNightcore(1.3, 1.3, 0.9);
+     * // or use the defaults
+     * await player.filterManager.toggleNightcore();
+     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+     * ```
+     */
+    toggleNightcore(speed?: number, pitch?: number, rate?: number): Promise<FilterManager>;
+    /**
+     * Enables / Disables a Vaporwave-like filter Effect. Disables/Overrides both: custom and nightcore Filter
+     * @param {number} speed set the speed of the filterq
+     * @param {number} pitch set the pitch of the filter
+     * @param {number} rate set the rate of the filter
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Toggle Vaporwave filter with custom settings
+     * await player.filterManager.toggleVaporwave(0.9, 0.7, 1);
+     * // or use the defaults
+     * await player.filterManager.toggleVaporwave();
+     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+     * ```
+     */
+    toggleVaporwave(speed?: number, pitch?: number, rate?: number): Promise<FilterManager>;
+    /**
+     * Enable / Disables a Karaoke like Filter Effect
+     * @param {number} level set the level of the filter
+     * @param {number} monoLevel set the mono level of the filter
+     * @param {number} filterBand set the filter band of the filter
+     * @param {number} filterWidth set the filter width of the filter
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Toggle Karaoke filter with custom settings
+     * await player.filterManager.toggleKaraoke(1.5, 1.0, 220, 100);
+     * // or use the defaults
+     * await player.filterManager.toggleKaraoke();
+     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+     * ```
+     */
+    toggleKaraoke(level?: number, monoLevel?: number, filterBand?: number, filterWidth?: number): Promise<FilterManager>;
+    /**
+     * Function to find out if currently there is a custom timescamle etc. filter applied
+     * @returns {boolean} whether a custom filter is active
+     *
+     * @example
+     * ```ts
+     * // Check if a custom filter is active
+     * const isCustom = player.filterManager.isCustomFilterActive();
+     * console.log(`Is custom filter active? ${isCustom}`);
+     * ```
+     */
+    isCustomFilterActive(): boolean;
+    /**
+     * Sets the players equalizer bands using one of the predefined presets.
+     * @param {keyof typeof EQList} preset The preset to use.
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Set EQ preset
+     * await player.filterManager.setEQPreset('BassboostMedium');
+     * ```
+     */
+    setEQPreset(preset: keyof typeof EQList): Promise<this>;
+    /**
+     * Sets the players equalizer band on-top of the existing ones.
+     * @param {number} bands
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Set EQ bands
+     * await player.filterManager.setEQ([
+     *   { band: 0, gain: 0.3 },
+     *   { band: 1, gain: -0.2 },
+     *   { band: 2, gain: 0.1 }
+     * ]);
+     *
+     * // or use one of the templates:
+     * await player.filterManager.setEQ(player.filterManager.EQList.BassboostMedium); // you can also import EQList from somewhere package if wanted.
+     * ```
+     */
+    setEQ(bands: EQBand | EQBand[]): Promise<this>;
+    /**
+     * Clears the equalizer bands.
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Clear all EQ bands
+     * await player.filterManager.clearEQ();
+     * ```
+     */
+    clearEQ(): Promise<this>;
 }
 
 declare class QueueSaver {
@@ -829,12 +945,6 @@ declare class Player {
     };
     /** Custom data for the player */
     private readonly data;
-    /**
-     * Emits a debug event to the LavalinkManager
-     * @param name name of the event
-     * @param eventData event data
-     */
-    private _emitDebugEvent;
     /**
      * Create a new Player
      * @param options
@@ -998,1318 +1108,1082 @@ declare class Player {
      */
     changeNode(newNode: LavalinkNode | string, checkSources?: boolean): Promise<string>;
     /**
-     * (Wrapper-FN for changeNode) Move the player to a different node. If no node is provided, it will find the least used node that is not the same as the current node.
+     * Move the player to a different node. If no node is provided, it will find the least used node that is not the same as the current node.
      * @param node the id of the node to move to
      * @returns the player
-     * @throws RangeError if there is no available nodes.
-     * @throws Error if the node to move to is the same as the current node.
-     * @example
-     * ```ts
-     * const newNodeMovedTo = await player.moveNode(); // no need to specify the new node, it will find a least used node automatically, but you can ofc. use a custom node id.
-     * ```
-     */
-    moveNode(node?: string): Promise<string | this>;
-    /** Converts the Player including Queue to a Json state */
-    toJSON(): PlayerJson;
-}
-
-declare const TrackSymbol: unique symbol;
-declare const UnresolvedTrackSymbol: unique symbol;
-declare const QueueSymbol: unique symbol;
-declare const NodeSymbol: unique symbol;
-/**
- * Parses Node Connection Url: "lavalink://<nodeId>:<nodeAuthorization(Password)>@<NodeHost>:<NodePort>"
- * @param connectionUrl
- * @returns
- */
-declare function parseLavalinkConnUrl(connectionUrl: string): {
-    authorization: string;
-    id: string;
-    host: string;
-    port: number;
-};
-declare class ManagerUtils {
-    LavalinkManager: LavalinkManager | undefined;
-    constructor(LavalinkManager?: LavalinkManager);
-    buildPluginInfo(data: any, clientData?: any): any;
-    buildTrack(data: LavalinkTrack | Track, requester: unknown): Track;
-    /**
-     * Builds a UnresolvedTrack to be resolved before being played  .
-     * @param query
-     * @param requester
-     */
-    buildUnresolvedTrack(query: UnresolvedQuery | UnresolvedTrack, requester: unknown): UnresolvedTrack;
-    /**
-     * Validate if a data is equal to a node
-     * @param data
-     */
-    isNode(data: LavalinkNode): boolean;
-    getTransformedRequester(requester: unknown): unknown;
-    /**
-     * Validate if a data is equal to node options
-     * @param data
-     */
-    isNodeOptions(data: LavalinkNodeOptions): boolean;
-    /**
-     * Validate tracks based on duration wether they are playble or broken tracks.
-     * most tracks should be longer than 30s, so you can put a minDuration of 29e3 (cause preview tracks are exactly 30s) or put 0.
-     * This check is not done automatically, you need to check it yourself by doing:
-     * @example
-     * ```ts
-     * const res = await player.search("Adele");
-     *
-     * // short hand:
-     * const validTracks = res.tracks.filter(client.lavalink.utils.isNotBrokenTrack)
-     * // or with options:
-     * const validTracks = res.tracks.filter(t => client.lavalink.utils.isNotBrokenTrack(t, 29e3));
-     *
-     * // then you can add it to the queue.
-     * await player.queue.add(validTracks);
-     * ```
-     */
-    isNotBrokenTrack(data: Track | UnresolvedTrack, minDuration?: number): data is Track;
-    /**
-     * Validate if a data is equal to a track
-     * @param data the Track to validate
-     * @returns
-     */
-    isTrack(data: Track | UnresolvedTrack): data is Track;
-    /**
-     * Checks if the provided argument is a valid UnresolvedTrack.
-     * @param track
-     */
-    isUnresolvedTrack(data: UnresolvedTrack | Track): data is UnresolvedTrack;
-    /**
-     * Checks if the provided argument is a valid UnresolvedTrack.
-     * @param track
-     */
-    isUnresolvedTrackQuery(data: UnresolvedQuery): boolean;
-    getClosestTrack(data: UnresolvedTrack, player: Player): Promise<Track | undefined>;
-    validateQueryString(node: LavalinkNode, queryString: string, sourceString?: LavalinkSearchPlatform): void;
-    transformQuery(query: SearchQuery): {
-        query: string;
-        extraQueryUrlParams: URLSearchParams;
-        source: any;
-    };
-    transformLavaSearchQuery(query: LavaSearchQuery): {
-        query: string;
-        types: string[];
-        source: any;
-    };
-    validateSourceString(node: LavalinkNode, sourceString: SearchPlatform): void;
-}
-/**
- * Separate interface for the constructor so that emitted js does not have a constructor that overwrites itself
- *
- * @internal
- */
-interface MiniMap<K, V> extends Map<K, V> {
-    constructor: MiniMapConstructor;
-}
-declare class MiniMap<K, V> extends Map<K, V> {
-    constructor(data?: [K, V][]);
-    /**
-     * Identical to
-     * [Array.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
-     * but returns a MiniMap instead of an Array.
-     *
-     * @param fn The function to test with (should return boolean)
-     * @param thisArg Value to use as `this` when executing function
-     *
-     * @example
-     * miniMap.filter(user => user.username === 'Bob');
-     */
-    filter<K2 extends K>(fn: (value: V, key: K, miniMap: this) => key is K2): MiniMap<K2, V>;
-    filter<V2 extends V>(fn: (value: V, key: K, miniMap: this) => value is V2): MiniMap<K, V2>;
-    filter(fn: (value: V, key: K, miniMap: this) => boolean): MiniMap<K, V>;
-    filter<This, K2 extends K>(fn: (this: This, value: V, key: K, miniMap: this) => key is K2, thisArg: This): MiniMap<K2, V>;
-    filter<This, V2 extends V>(fn: (this: This, value: V, key: K, miniMap: this) => value is V2, thisArg: This): MiniMap<K, V2>;
-    filter<This>(fn: (this: This, value: V, key: K, miniMap: this) => boolean, thisArg: This): MiniMap<K, V>;
-    toJSON(): [K, V][];
-    /**
-     * Maps each item to another value into an array. Identical in behavior to
-     * [Array.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).
-     *
-     * @param fn Function that produces an element of the new array, taking three arguments
-     * @param thisArg Value to use as `this` when executing function
-     *
-     * @example
-     * miniMap.map(user => user.tag);
+     * @throws RangeError if there is no available nodes.
+     * @throws Error if the node to move to is the same as the current node.
      */
-    map<T>(fn: (value: V, key: K, miniMap: this) => T): T[];
-    map<This, T>(fn: (this: This, value: V, key: K, miniMap: this) => T, thisArg: This): T[];
+    moveNode(node?: string): Promise<string | this>;
+    /** Converts the Player including Queue to a Json state */
+    toJSON(): PlayerJson;
 }
-declare function queueTrackEnd(player: Player, dontShiftQueue?: boolean): Promise<Track>;
-declare function safeStringify(obj: any, padding?: number): string;
 
-/** Helper for generating Opaque types. */
-type Opaque<T, K> = T & {
-    __opaque__: K;
-};
-/** Opqaue tyep for integernumber */
-type IntegerNumber = Opaque<number, 'Int'>;
-/** Opqaue tyep for floatnumber */
-type FloatNumber = Opaque<number, 'Float'>;
-type LavaSrcSearchPlatformBase = "spsearch" | "sprec" | "amsearch" | "dzsearch" | "dzisrc" | "dzrec" | "ymsearch" | "ymrec" | "vksearch" | "vkrec" | "tdsearch" | "tdrec" | "qbsearch" | "qbisrc" | "qbrec" | "pdsearch" | "pdisrc" | "pdrec";
-type LavaSrcSearchPlatform = LavaSrcSearchPlatformBase | "ftts";
-type JioSaavnSearchPlatform = "jssearch" | "jsrec";
-type DuncteSearchPlatform = "speak" | "phsearch" | "pornhub" | "porn" | "tts";
-type LavalinkClientSearchPlatform = "bcsearch";
-type LavalinkClientSearchPlatformResolve = "bandcamp" | "bc";
-type LavalinkSearchPlatform = "ytsearch" | "ytmsearch" | "scsearch" | "bcsearch" | LavaSrcSearchPlatform | DuncteSearchPlatform | JioSaavnSearchPlatform | LavalinkClientSearchPlatform;
-type ClientCustomSearchPlatformUtils = "local" | "http" | "https" | "link" | "uri";
-type ClientSearchPlatform = ClientCustomSearchPlatformUtils | // for file/link requests
-"youtube" | "yt" | "youtube music" | "youtubemusic" | "ytm" | "musicyoutube" | "music youtube" | "soundcloud" | "sc" | "am" | "apple music" | "applemusic" | "apple" | "musicapple" | "music apple" | "sp" | "spsuggestion" | "spotify" | "spotify.com" | "spotifycom" | "dz" | "deezer" | "yandex" | "yandex music" | "yandexmusic" | "vk" | "vk music" | "vkmusic" | "tidal" | "tidal music" | "qobuz" | "pandora" | "pd" | "pandora music" | "pandoramusic" | "flowerytts" | "flowery" | "flowery.tts" | LavalinkClientSearchPlatformResolve | LavalinkClientSearchPlatform | "js" | "jiosaavn" | "td" | "tidal" | "tdrec";
-type SearchPlatform = LavalinkSearchPlatform | ClientSearchPlatform;
-type SourcesRegex = "YoutubeRegex" | "YoutubeMusicRegex" | "SoundCloudRegex" | "SoundCloudMobileRegex" | "DeezerTrackRegex" | "DeezerArtistRegex" | "DeezerEpisodeRegex" | "DeezerMixesRegex" | "DeezerPageLinkRegex" | "DeezerPlaylistRegex" | "DeezerAlbumRegex" | "AllDeezerRegex" | "AllDeezerRegexWithoutPageLink" | "SpotifySongRegex" | "SpotifyPlaylistRegex" | "SpotifyArtistRegex" | "SpotifyEpisodeRegex" | "SpotifyShowRegex" | "SpotifyAlbumRegex" | "AllSpotifyRegex" | "mp3Url" | "m3uUrl" | "m3u8Url" | "mp4Url" | "m4aUrl" | "wavUrl" | "aacpUrl" | "tiktok" | "mixcloud" | "musicYandex" | "radiohost" | "bandcamp" | "jiosaavn" | "appleMusic" | "tidal" | "PandoraTrackRegex" | "PandoraAlbumRegex" | "PandoraArtistRegex" | "PandoraPlaylistRegex" | "AllPandoraRegex" | "TwitchTv" | "vimeo";
-interface PlaylistInfo {
-    /** The playlist name */
-    name: string;
-    /** The playlist title (same as name) */
-    title: string;
-    /** The playlist Author */
-    author?: string;
-    /** The playlist Thumbnail */
-    thumbnail?: string;
-    /** A Uri to the playlist */
-    uri?: string;
-    /** The playlist selected track. */
-    selectedTrack: Track | null;
-    /** The duration of the entire playlist. (calcualted) */
-    duration: number;
-}
-interface SearchResult {
-    loadType: LoadTypes;
-    exception: Exception | null;
-    pluginInfo: PluginInfo;
-    playlist: PlaylistInfo | null;
-    tracks: Track[];
-}
-interface UnresolvedSearchResult {
-    loadType: LoadTypes;
-    exception: Exception | null;
-    pluginInfo: PluginInfo;
-    playlist: PlaylistInfo | null;
-    tracks: UnresolvedTrack[];
-}
-/**
- * @internal
- */
-interface MiniMapConstructor {
-    new (): MiniMap<unknown, unknown>;
-    new <K, V>(entries?: ReadonlyArray<readonly [K, V]> | null): MiniMap<K, V>;
-    new <K, V>(iterable: Iterable<readonly [K, V]>): MiniMap<K, V>;
-    readonly prototype: MiniMap<unknown, unknown>;
-    readonly [Symbol.species]: MiniMapConstructor;
-}
-type PlayerEvents = TrackStartEvent | TrackEndEvent | TrackStuckEvent | TrackExceptionEvent | WebSocketClosedEvent | SponsorBlockSegmentEvents | LyricsEvent;
-type Severity = "COMMON" | "SUSPICIOUS" | "FAULT";
-interface Exception {
-    /** Severity of the error */
-    severity: Severity;
-    /** Nodejs Error */
-    error?: Error;
-    /** Message by lavalink */
-    message: string;
-    /** Cause by lavalink */
-    cause: string;
-    /** causeStackTrace by lavalink */
-    causeStackTrace: string;
-}
-interface PlayerEvent {
-    op: "event";
-    type: PlayerEventType;
-    guildId: string;
-}
-interface TrackStartEvent extends PlayerEvent {
-    type: "TrackStartEvent";
-    track: LavalinkTrack;
-}
-interface TrackEndEvent extends PlayerEvent {
-    type: "TrackEndEvent";
-    track: LavalinkTrack;
-    reason: TrackEndReason;
-}
-interface TrackExceptionEvent extends PlayerEvent {
-    type: "TrackExceptionEvent";
-    exception?: Exception;
-    track: LavalinkTrack;
-    error: string;
-}
-interface TrackStuckEvent extends PlayerEvent {
-    type: "TrackStuckEvent";
-    thresholdMs: number;
-    track: LavalinkTrack;
-}
-interface WebSocketClosedEvent extends PlayerEvent {
-    type: "WebSocketClosedEvent";
-    code: number;
-    byRemote: boolean;
-    reason: string;
-}
-/**
- * Types & Events for Sponsorblock-plugin from Lavalink: https://github.com/topi314/Sponsorblock-Plugin#segmentsloaded
- */
-type SponsorBlockSegmentEvents = SponsorBlockSegmentSkipped | SponsorBlockSegmentsLoaded | SponsorBlockChapterStarted | SponsorBlockChaptersLoaded;
-type SponsorBlockSegmentEventType = "SegmentSkipped" | "SegmentsLoaded" | "ChaptersLoaded" | "ChapterStarted";
-interface SponsorBlockSegmentsLoaded extends PlayerEvent {
-    type: "SegmentsLoaded";
-    segments: {
-        category: string;
-        start: number;
-        end: number;
-    }[];
-}
-interface SponsorBlockSegmentSkipped extends PlayerEvent {
-    type: "SegmentSkipped";
-    segment: {
-        category: string;
-        start: number;
-        end: number;
-    };
-}
-interface SponsorBlockChapterStarted extends PlayerEvent {
-    type: "ChapterStarted";
-    /** The Chapter which started */
-    chapter: {
-        /** The Name of the Chapter */
-        name: string;
-        start: number;
-        end: number;
-        duration: number;
-    };
-}
-interface SponsorBlockChaptersLoaded extends PlayerEvent {
-    type: "ChaptersLoaded";
-    /** All Chapters loaded */
-    chapters: {
-        /** The Name of the Chapter */
-        name: string;
-        start: number;
-        end: number;
-        duration: number;
-    }[];
-}
-/**
- * Types & Events for Lyrics plugin from Lavalink: https://github.com/topi314/LavaLyrics
- */
-type LyricsEvent = LyricsFoundEvent | LyricsNotFoundEvent | LyricsLineEvent;
-type LyricsEventType = "LyricsFoundEvent" | "LyricsNotFoundEvent" | "LyricsLineEvent";
-interface LyricsFoundEvent extends PlayerEvent {
-    /** The lyricsfound event */
-    type: "LyricsFoundEvent";
-    /** The guildId */
-    guildId: string;
-    /** The lyrics */
-    lyrics: LyricsResult;
-}
-interface LyricsNotFoundEvent extends PlayerEvent {
-    /**The lyricsnotfound event*/
-    type: "LyricsNotFoundEvent";
-    /**The guildId*/
-    guildId: string;
-}
-interface LyricsLineEvent extends PlayerEvent {
-    /**The lyricsline event*/
-    type: "LyricsLineEvent";
-    /** The guildId */
-    guildId: string;
-    /** The line number */
-    lineIndex: number;
-    /** The line */
-    line: LyricsLine;
-    /**skipped is true if the line was skipped */
-    skipped: boolean;
-}
-type LoadTypes = "track" | "playlist" | "search" | "error" | "empty";
-type State = "CONNECTED" | "CONNECTING" | "DISCONNECTED" | "DISCONNECTING" | "DESTROYING";
-type PlayerEventType = "TrackStartEvent" | "TrackEndEvent" | "TrackExceptionEvent" | "TrackStuckEvent" | "WebSocketClosedEvent" | SponsorBlockSegmentEventType | LyricsEventType;
-type TrackEndReason = "finished" | "loadFailed" | "stopped" | "replaced" | "cleanup";
-interface InvalidLavalinkRestRequest {
-    /** Rest Request Data for when it was made */
-    timestamp: number;
-    /** Status of the request */
-    status: number;
-    /** Specific Errro which was sent */
-    error: string;
-    /** Specific Message which was created */
-    message?: string;
-    /** The specific error trace from the request */
-    trace?: unknown;
-    /** Path of where it's from */
-    path: string;
-}
-interface LavalinkPlayerVoice {
-    /** The Voice Token */
-    token: string;
-    /** The Voice Server Endpoint  */
-    endpoint: string;
-    /** The Voice SessionId */
-    sessionId: string;
-    /** Wether or not the player is connected */
-    connected?: boolean;
-    /** The Ping to the voice server */
-    ping?: number;
-}
-type LavalinkPlayerVoiceOptions = Omit<LavalinkPlayerVoice, 'connected' | 'ping'>;
-interface FailingAddress {
-    /** The failing address */
-    failingAddress: string;
-    /** The timestamp when the address failed */
-    failingTimestamp: number;
-    /** The timestamp when the address failed as a pretty string */
-    failingTime: string;
-}
-type RoutePlannerTypes = "RotatingIpRoutePlanner" | "NanoIpRoutePlanner" | "RotatingNanoIpRoutePlanner" | "BalancingIpRoutePlanner";
-interface RoutePlanner {
-    class?: RoutePlannerTypes;
-    details?: {
-        /** The ip block being used */
-        ipBlock: {
-            /** The type of the ip block */
-            type: "Inet4Address" | "Inet6Address";
-            /** 	The size of the ip block */
-            size: string;
-        };
-        /** The failing addresses */
-        failingAddresses: FailingAddress[];
-        /** The number of rotations */
-        rotateIndex?: string;
-        /** The current offset in the block	 */
-        ipIndex?: string;
-        /** The current address being used	 */
-        currentAddress?: string;
-        /** The current offset in the ip block */
-        currentAddressIndex?: string;
-        /** The information in which /64 block ips are chosen. This number increases on each ban. */
-        blockIndex?: string;
-    };
+/** Sourcenames provided by lavalink server */
+type LavalinkSourceNames = "youtube" | "youtubemusic" | "soundcloud" | "bandcamp" | "twitch";
+/** Source Names provided by lava src plugin */
+type LavalinkPlugin_LavaSrc_SourceNames = "deezer" | "spotify" | "applemusic" | "yandexmusic" | "flowery-tts" | "vkmusic" | "tidal" | "qobuz" | "pandora";
+/** Source Names provided by jiosaavan plugin */
+type LavalinkPlugin_JioSaavn_SourceNames = "jiosaavn";
+/** The SourceNames provided by lavalink */
+type SourceNames = LavalinkSourceNames | LavalinkPlugin_LavaSrc_SourceNames | LavalinkPlugin_JioSaavn_SourceNames;
+interface LavalinkTrackInfo {
+    /** The Identifier of the Track */
+    identifier: string;
+    /** The Track Title / Name */
+    title: string;
+    /** The Name of the Author */
+    author: string;
+    /** The duration of the Track */
+    length: number;
+    /** The URL of the artwork if available */
+    artworkUrl: string | null;
+    /** The URL (aka Link) of the Track called URI */
+    uri: string;
+    /** The Source name of the Track, e.g. soundcloud, youtube, spotify */
+    sourceName: SourceNames;
+    /** Wether the audio is seekable */
+    isSeekable: boolean;
+    /** Wether the audio is of a live stream */
+    isStream: boolean;
+    /** If isrc code is available, it's provided */
+    isrc: string | null;
 }
-interface Session {
-    /** Wether or not session is resuming or not */
-    resuming: boolean;
-    /** For how long a session is lasting while not connected */
-    timeout: number;
+interface TrackInfo {
+    /** The Identifier of the Track */
+    identifier: string;
+    /** The Track Title / Name */
+    title: string;
+    /** The Name of the Author */
+    author: string;
+    /** The duration of the Track */
+    duration: number;
+    /** The URL of the artwork if available */
+    artworkUrl: string | null;
+    /** The URL (aka Link) of the Track called URI */
+    uri: string;
+    /** The Source name of the Track, e.g. soundcloud, youtube, spotify */
+    sourceName: SourceNames;
+    /** Wether the audio is seekable */
+    isSeekable: boolean;
+    /** Wether the audio is of a live stream */
+    isStream: boolean;
+    /** If isrc code is available, it's provided */
+    isrc: string | null;
 }
-interface GuildShardPayload {
-    /** The OP code */
-    op: number;
-    /** Data to send  */
-    d: {
-        /** Guild id to apply voice settings */
-        guild_id: string;
-        /** channel to move/connect to, or null to leave it */
-        channel_id: string | null;
-        /** wether or not mute yourself */
-        self_mute: boolean;
-        /** wether or not deafen yourself */
-        self_deaf: boolean;
+interface PluginInfo {
+    /** The Type provided by a plugin */
+    type?: "album" | "playlist" | "artist" | "recommendations" | string;
+    /** The Identifier provided by a plugin */
+    albumName?: string;
+    /** The url of the album */
+    albumUrl?: string;
+    /** The url of the album art */
+    albumArtUrl?: string;
+    /** The url of the artist */
+    artistUrl?: string;
+    /** The url of the artist artwork */
+    artistArtworkUrl?: string;
+    /** The url of the preview */
+    previewUrl?: string;
+    /** Whether the track is a preview */
+    isPreview?: boolean;
+    /** The total number of tracks in the playlist */
+    totalTracks?: number;
+    /** The Identifier provided by a plugin */
+    identifier?: string;
+    /** The ArtworkUrl provided by a plugin */
+    artworkUrl?: string;
+    /** The Author Information provided by a plugin */
+    author?: string;
+    /** The Url provided by a Plugin */
+    url?: string;
+    /** The Url provided by a Plugin */
+    uri?: string;
+    /** You can put specific track information here, to transform the tracks... */
+    clientData?: {
+        previousTrack?: boolean;
+        [key: string]: any;
     };
 }
-interface PlayerUpdateInfo {
-    /** guild id of the player */
-    guildId: string;
-    /** Player options to provide to lavalink */
-    playerOptions: LavalinkPlayOptions;
-    /** Whether or not replace the current track with the new one (true is recommended) */
-    noReplace?: boolean;
-}
-interface LavalinkPlayer {
-    /** Guild Id of the player */
-    guildId: string;
-    /** IF playing a track, all of the track information */
-    track?: LavalinkTrack;
-    /** Lavalink volume (mind volumedecrementer) */
-    volume: number;
-    /** Wether it's paused or not */
-    paused: boolean;
-    /** Voice Endpoint data */
-    voice: LavalinkPlayerVoice;
-    /** All Audio Filters */
-    filters: Partial<LavalinkFilterData>;
-    /** Lavalink-Voice-State Variables */
-    state: {
-        /** Time since connection established */
-        time: number;
-        /** Position of the track */
-        position: number;
-        /** COnnected or not */
-        connected: boolean;
-        /** Ping to voice server */
-        ping: number;
-    };
+interface LavalinkTrack {
+    /** The Base 64 encoded String */
+    encoded?: Base64;
+    /** Track Information */
+    info: LavalinkTrackInfo;
+    /** Plugin Information from Lavalink */
+    pluginInfo: Partial<PluginInfo>;
+    /** The userData Object from when you provide to the lavalink request */
+    userData?: anyObject;
 }
-interface ChannelDeletePacket {
-    /** Packet key for channel delete */
-    t: "CHANNEL_DELETE";
-    /** data which is sent and relevant */
-    d: {
-        /** guild id */
-        guild_id: string;
-        /** Channel id */
-        id: string;
-    };
+interface Track {
+    /** The Base 64 encoded String */
+    encoded?: Base64;
+    /** Track Information */
+    info: TrackInfo;
+    /** Plugin Information from Lavalink */
+    pluginInfo: Partial<PluginInfo>;
+    /** The Track's Requester */
+    requester?: unknown;
+    /** The userData Object from when you provide to the lavalink request */
+    userData?: anyObject;
 }
-interface VoiceState {
-    /** OP key from lavalink */
-    op: "voiceUpdate";
-    /** GuildId provided by lavalink */
-    guildId: string;
-    /** Event data */
-    event: VoiceServer;
-    /** Session Id of the voice connection */
-    sessionId?: string;
-    /** guild id of the voice channel */
-    guild_id: string;
-    /** user id from the voice connection */
-    user_id: string;
-    /** Session Id of the voice connection */
-    session_id: string;
-    /** Voice Channel Id */
-    channel_id: string;
-    /** Server Mute status */
-    mute: boolean;
-    /** Server Deaf status */
-    deaf: boolean;
-    /** Self Deaf status */
-    self_deaf: boolean;
-    /** Self Mute status */
-    self_mute: boolean;
-    /** Self Video (Camera) status */
-    self_video: boolean;
-    /** Self Stream status */
-    self_stream: boolean;
-    /** Wether the user requests to speak (stage channel) */
-    request_to_speak_timestamp: boolean;
-    /** Self suppressed status (stage channel) */
-    suppress: boolean;
+interface UnresolvedTrackInfo extends Partial<TrackInfo> {
+    /** Required */
+    title: string;
 }
-/** The Base64 decodes tring by lavalink */
-type Base64 = string;
-interface VoiceServer {
-    /** Voice Token */
-    token: string;
-    /** Guild Id of the voice server connection */
-    guild_id: string;
-    /** Server Endpoint */
-    endpoint: string;
+interface UnresolvedQuery extends UnresolvedTrackInfo {
+    /** The base64 of the unresolved track to "encode" */
+    encoded?: Base64;
 }
-interface VoicePacket {
-    /** Voice Packet Keys to send */
-    t?: "VOICE_SERVER_UPDATE" | "VOICE_STATE_UPDATE";
-    /** Voice Packets to send */
-    d: VoiceState | VoiceServer;
+interface UnresolvedTrack {
+    /** Required */
+    resolve: (player: Player) => Promise<void>;
+    /** The Base 64 encoded String */
+    encoded?: Base64;
+    /** Track Information */
+    info: UnresolvedTrackInfo;
+    /** Plugin Information from Lavalink */
+    pluginInfo: Partial<PluginInfo>;
+    /** The userData Object from when you provide to the lavalink request */
+    userData?: anyObject;
+    /** The Track's Requester */
+    requester?: unknown;
 }
-interface NodeMessage extends NodeStats {
-    /** The type of the event */
-    type: PlayerEventType;
-    /** what ops are applying to that event */
-    op: "stats" | "playerUpdate" | "event";
-    /** The specific guild id for that message */
-    guildId: string;
+
+interface StoredQueue {
+    current: Track | null;
+    previous: Track[];
+    tracks: (Track | UnresolvedTrack)[];
 }
-/** Specific types to filter for lavasearch, will be filtered to correct types */
-type LavaSearchType = "track" | "album" | "artist" | "playlist" | "text" | "tracks" | "albums" | "artists" | "playlists" | "texts";
-interface LavaSearchFilteredResponse {
-    /** The Information of a playlist provided by lavasearch */
-    info: PlaylistInfo;
-    /** additional plugin information */
-    pluginInfo: PluginInfo;
-    /** List of tracks  */
-    tracks: Track[];
+interface QueueStoreManager {
+    /** @async get a Value (MUST RETURN UNPARSED!) */
+    get: (guildId: string) => Awaitable<StoredQueue | string | undefined>;
+    /** @async Set a value inside a guildId (MUST BE UNPARSED) */
+    set: (guildId: string, value: StoredQueue | string) => Awaitable<void | boolean>;
+    /** @async Delete a Database Value based of it's guildId */
+    delete: (guildId: string) => Awaitable<void | boolean>;
+    /** @async Transform the value(s) inside of the QueueStoreManager (IF YOU DON'T NEED PARSING/STRINGIFY, then just return the value) */
+    stringify: (value: StoredQueue | string) => Awaitable<StoredQueue | string>;
+    /** @async Parse the saved value back to the Queue (IF YOU DON'T NEED PARSING/STRINGIFY, then just return the value) */
+    parse: (value: StoredQueue | string) => Awaitable<Partial<StoredQueue>>;
 }
-interface LavaSearchResponse {
-    /** An array of tracks, only present if track is in types */
-    tracks: Track[];
-    /** An array of albums, only present if album is in types */
-    albums: LavaSearchFilteredResponse[];
-    /** 	An array of artists, only present if artist is in types */
-    artists: LavaSearchFilteredResponse[];
-    /** 	An array of playlists, only present if playlist is in types */
-    playlists: LavaSearchFilteredResponse[];
-    /** An array of text results, only present if text is in types */
-    texts: {
-        text: string;
-        pluginInfo: PluginInfo;
-    }[];
-    /** Addition result data provided by plugins */
-    pluginInfo: PluginInfo;
+interface ManagerQueueOptions {
+    /** Maximum Amount of tracks for the queue.previous array. Set to 0 to not save previous songs. Defaults to 25 Tracks */
+    maxPreviousTracks?: number;
+    /** Custom Queue Store option */
+    queueStore?: QueueStoreManager;
+    /** Custom Queue Watcher class */
+    queueChangesWatcher?: QueueChangesWatcher;
+}
+interface QueueChangesWatcher {
+    /** get a Value (MUST RETURN UNPARSED!) */
+    tracksAdd: (guildId: string, tracks: (Track | UnresolvedTrack)[], position: number, oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
+    /** Set a value inside a guildId (MUST BE UNPARSED) */
+    tracksRemoved: (guildId: string, tracks: (Track | UnresolvedTrack)[], position: number | number[], oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
+    /** Set a value inside a guildId (MUST BE UNPARSED) */
+    shuffled: (guildId: string, oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
 }
-/** SearchQuery Object for raw lavalink requests */
-type SearchQuery = {
-    /** lavalink search Query / identifier string */
-    query: string;
-    /** Extra url query params to use, e.g. for flowertts */
-    extraQueryUrlParams?: URLSearchParams;
-    /** Source to append to the search query string */
-    source?: SearchPlatform;
-} | /** Our just the search query / identifier string */ string;
-/** SearchQuery Object for Lavalink LavaSearch Plugin requests */
-type LavaSearchQuery = {
-    /** lavalink search Query / identifier string */
-    query: string;
-    /** Source to append to the search query string */
-    source: LavaSrcSearchPlatformBase;
-    /** The Types to filter the search to */
-    types?: LavaSearchType[];
-};
-type Awaitable<T> = Promise<T> | T;
 
-/** The Audio Outputs type */
-type AudioOutputs = "mono" | "stereo" | "left" | "right";
-/** The "active" / "disabled" Player Filters */
-interface PlayerFilters {
-    /** Sets nightcore to false, and vaporwave to false */
-    custom: boolean;
-    /** Sets custom to false, and vaporwave to false */
-    nightcore: boolean;
-    /** Sets custom to false, and nightcore to false */
-    vaporwave: boolean;
-    /** If rotation filter is enabled / not */
-    rotation: boolean;
-    /** if karaoke filter is enabled / not */
-    karaoke: boolean;
-    /** if tremolo filter is enabled / not */
-    tremolo: boolean;
-    /** if vibrato filter is enabled / not */
-    vibrato: boolean;
-    lowPass: boolean;
-    /** audio Output (default stereo, mono sounds the fullest and best for not-stereo tracks) */
-    audioOutput: AudioOutputs;
-    /** Lavalink Volume FILTER (not player Volume, think of it as a gain booster) */
-    volume: boolean;
-    /** Filters for the Lavalink Filter Plugin */
-    lavalinkFilterPlugin: {
-        /** if echo filter is enabled / not */
-        echo: boolean;
-        /** if reverb filter is enabled / not */
-        reverb: boolean;
+type DestroyReasonsType = keyof typeof DestroyReasons | string;
+type DisconnectReasonsType = keyof typeof DisconnectReasons | string;
+interface PlayerJson {
+    /** Guild Id where the player was playing in */
+    guildId: string;
+    /** Options provided to the player */
+    options: PlayerOptions;
+    /** Voice Channel Id the player was playing in */
+    voiceChannelId: string;
+    /** Text Channel Id the player was synced to */
+    textChannelId?: string;
+    /** Position the player was at */
+    position: number;
+    /** Lavalink's position the player was at */
+    lastPosition: number;
+    /** Last time the position was sent from lavalink */
+    lastPositionChange: number | null;
+    /** Volume in % from the player (without volumeDecrementer) */
+    volume: number;
+    /** Real Volume used in lavalink (with the volumeDecrementer) */
+    lavalinkVolume: number;
+    /** The repeatmode from the player */
+    repeatMode: RepeatMode;
+    /** Pause state */
+    paused: boolean;
+    /** Wether the player was playing or not */
+    playing: boolean;
+    /** When the player was created */
+    createdTimeStamp?: number;
+    /** All current used fitlers Data */
+    filters: FilterData;
+    /** The player's ping object */
+    ping: {
+        /** Ping to the voice websocket server */
+        ws: number;
+        /** Avg. calc. Ping to the lavalink server */
+        lavalink: number;
     };
-    lavalinkLavaDspxPlugin: {
-        /** if lowPass filter is enabled / not */
-        lowPass: boolean;
-        /** if highPass filter is enabled / not */
-        highPass: boolean;
-        /** if normalization filter is enabled / not */
-        normalization: boolean;
-        /** if echo filter is enabled / not */
-        echo: boolean;
+    /** Equalizer Bands used in lavalink */
+    equalizer: EQBand[];
+    /** The Id of the last used node */
+    nodeId?: string;
+    /** The SessionId of the node */
+    nodeSessionId?: string;
+    /** The stored queue */
+    queue?: StoredQueue;
+    /** Custom Data for the player get/set datastorage */
+    data: {
+        [key: string]: object | string | number | null;
     };
 }
-/**
- * There are 15 bands (0-14) that can be changed.
- * "gain" is the multiplier for the given band.
- * The default value is 0.
- *  Valid values range from -0.25 to 1.0, where -0.25 means the given band is completely muted, and 0.25 means it is doubled.
- * Modifying the gain could also change the volume of the output.
- */
-interface EQBand {
-    /** On what band position (0-14) it should work */
-    band: IntegerNumber | number;
-    /** The gain (-0.25 to 1.0) */
-    gain: FloatNumber | number;
+type RepeatMode = "queue" | "track" | "off";
+interface PlayerOptions {
+    /** Guild id of the player */
+    guildId: string;
+    /** The Voice Channel Id */
+    voiceChannelId: string;
+    /** The Text Channel Id of the Player */
+    textChannelId?: string;
+    /** instantly change volume with the one play request */
+    volume?: number;
+    /** VC Region for node selections */
+    vcRegion?: string;
+    /** if it should join deafened */
+    selfDeaf?: boolean;
+    /** If it should join muted */
+    selfMute?: boolean;
+    /** If it should use a specific lavalink node */
+    node?: LavalinkNode | string;
+    /** If when applying filters, it should use the insta apply filters fix  */
+    instaUpdateFiltersFix?: boolean;
+    /** If a volume should be applied via filters instead of lavalink-volume */
+    applyVolumeAsFilter?: boolean;
+    /** Custom Data for the player get/set datastorage */
+    customData?: anyObject;
 }
-/**
- * Uses equalization to eliminate part of a band, usually targeting vocals.
- */
-interface KaraokeFilter {
-    /** The level (0 to 1.0 where 0.0 is no effect and 1.0 is full effect) */
-    level?: number;
-    /** The mono level (0 to 1.0 where 0.0 is no effect and 1.0 is full effect) */
-    monoLevel?: number;
-    /** The filter band (in Hz) */
-    filterBand?: number;
-    /**	The filter width */
-    filterWidth?: number;
+type anyObject = {
+    [key: string | number]: string | number | null | anyObject;
+};
+interface BasePlayOptions {
+    /** The position to start the track. */
+    position?: number;
+    /** The position to end the track. */
+    endTime?: number;
+    /** If to start "paused" */
+    paused?: boolean;
+    /** The Volume to start with */
+    volume?: number;
+    /** The Lavalink Filters to use | only with the new REST API */
+    filters?: Partial<LavalinkFilterData>;
+    /** Voice Update for Lavalink */
+    voice?: LavalinkPlayerVoiceOptions;
+}
+interface LavalinkPlayOptions extends BasePlayOptions {
+    /** Which Track to play | don't provide, if it should pick from the Queue */
+    track?: {
+        /** The track encoded base64 string to use instead of the one from the queue system */
+        encoded?: Base64 | null;
+        /** The identifier of the track to use */
+        identifier?: string;
+        /** Custom User Data for the track to provide, will then be on the userData object from the track */
+        userData?: anyObject;
+        /** The Track requester for when u provide encodedTrack / identifer */
+        requester?: unknown;
+    };
+}
+interface PlayOptions extends LavalinkPlayOptions {
+    /** Whether to not replace the track if a play payload is sent. */
+    noReplace?: boolean;
+    /** Adds track on queue and skips to it */
+    clientTrack?: Track | UnresolvedTrack;
 }
+
+/** Ability to manipulate fetch requests */
+type ModifyRequest = (options: RequestInit & {
+    path: string;
+    extraQueryUrlParams?: URLSearchParams;
+}) => void;
+type SponsorBlockSegment = "sponsor" | "selfpromo" | "interaction" | "intro" | "outro" | "preview" | "music_offtopic" | "filler";
 /**
- * Changes the speed, pitch, and rate
+ * Node Options for creating a lavalink node
  */
-interface TimescaleFilter {
-    /** The playback speed 0.0 ≤ x */
-    speed?: number;
-    /** The pitch 0.0 ≤ x */
-    pitch?: number;
-    /** The rate 0.0 ≤ x */
-    rate?: number;
+interface LavalinkNodeOptions {
+    /** The Lavalink Server-Ip / Domain-URL */
+    host: string;
+    /** The Lavalink Connection Port */
+    port: number;
+    /** The Lavalink Password / Authorization-Key */
+    authorization: string;
+    /** Does the Server use ssl (https) */
+    secure?: boolean;
+    /** RESUME THE PLAYER? by providing a sessionid on the node-creation */
+    sessionId?: string;
+    /** Add a Custom ID to the node, for later use */
+    id?: string;
+    /** Voice Regions of this Node */
+    regions?: string[];
+    /** The retryAmount for the node. */
+    retryAmount?: number;
+    /** The retryDelay for the node. */
+    retryDelay?: number;
+    /** signal for cancelling requests - default: AbortSignal.timeout(options.requestSignalTimeoutMS || 10000) - put <= 0 to disable */
+    requestSignalTimeoutMS?: number;
+    /** Close on error */
+    closeOnError?: boolean;
+    /** Heartbeat interval , set to <= 0 to disable heartbeat system */
+    heartBeatInterval?: number;
+    /** Recommended, to check wether the client is still connected or not on the stats endpoint */
+    enablePingOnStatsCheck?: boolean;
 }
 /**
- * Uses amplification to create a shuddering effect, where the volume quickly oscillates.
- * Demo: https://en.wikipedia.org/wiki/File:Fuse_Electronics_Tremolo_MK-III_Quick_Demo.ogv
+ * Memory Stats object from lavalink
  */
-interface TremoloFilter {
-    /** The frequency 0.0 < x */
-    frequency?: number;
-    /** The tremolo depth 0.0 < x ≤ 1.0 */
-    depth?: number;
+interface MemoryStats {
+    /** The free memory of the allocated amount. */
+    free: number;
+    /** The used memory of the allocated amount. */
+    used: number;
+    /** The total allocated memory. */
+    allocated: number;
+    /** The reservable memory. */
+    reservable: number;
 }
 /**
- * Similar to tremolo. While tremolo oscillates the volume, vibrato oscillates the pitch.
+ * CPU Stats object from lavalink
  */
-interface VibratoFilter {
-    /** The frequency 0.0 < x ≤ 14.0 */
-    frequency?: number;
-    /** The vibrato depth 0.0 < x ≤ 1.0 */
-    depth?: number;
+interface CPUStats {
+    /** The core amount the host machine has. */
+    cores: number;
+    /** The system load. */
+    systemLoad: number;
+    /** The lavalink load. */
+    lavalinkLoad: number;
 }
 /**
- * Rotates the sound around the stereo channels/user headphones (aka Audio Panning).
- * It can produce an effect similar to https://youtu.be/QB9EB8mTKcc (without the reverb).
+ * FrameStats Object from lavalink
  */
-interface RotationFilter {
-    /** The frequency of the audio rotating around the listener in Hz. 0.2 is similar to the example video above */
-    rotationHz?: number;
+interface FrameStats {
+    /** The amount of sent frames. */
+    sent?: number;
+    /** The amount of nulled frames. */
+    nulled?: number;
+    /** The amount of deficit frames. */
+    deficit?: number;
 }
 /**
- * Distortion effect. It can generate some pretty unique audio effects.
+ * BaseNodeStats object from Lavalink
  */
-interface DistortionFilter {
-    sinOffset?: number;
-    sinScale?: number;
-    cosOffset?: number;
-    cosScale?: number;
-    tanOffset?: number;
-    tanScale?: number;
-    offset?: number;
-    scale?: number;
+interface BaseNodeStats {
+    /** The amount of players on the node. */
+    players: number;
+    /** The amount of playing players on the node. */
+    playingPlayers: number;
+    /** The uptime for the node. */
+    uptime: number;
+    /** The memory stats for the node. */
+    memory: MemoryStats;
+    /** The cpu stats for the node. */
+    cpu: CPUStats;
+    /** The frame stats for the node. */
+    frameStats: FrameStats;
 }
 /**
- * Mixes both channels (left and right), with a configurable factor on how much each channel affects the other.
- * With the defaults, both channels are kept independent of each other.
- * Setting all factors to 0.5 means both channels get the same audio.
+ * Interface for nodeStats from lavalink
  */
-interface ChannelMixFilter {
-    /** The left to left channel mix factor (0.0 ≤ x ≤ 1.0) */
-    leftToLeft?: number;
-    /** The left to right channel mix factor (0.0 ≤ x ≤ 1.0) */
-    leftToRight?: number;
-    /** The right to left channel mix factor (0.0 ≤ x ≤ 1.0) */
-    rightToLeft?: number;
-    /** The right to right channel mix factor (0.0 ≤ x ≤ 1.0) */
-    rightToRight?: number;
+interface NodeStats extends BaseNodeStats {
+    /** The frame stats for the node. */
+    frameStats: FrameStats;
 }
 /**
- * Higher frequencies get suppressed, while lower frequencies pass through this filter, thus the name low pass.
- * Any smoothing values equal to or less than 1.0 will disable the filter.
+ * Entire lavalink information object from lavalink
  */
-interface LowPassFilter {
-    /** The smoothing factor (1.0 < x) */
-    smoothing?: number;
+interface LavalinkInfo {
+    /** The version of this Lavalink server */
+    version: VersionObject;
+    /** The millisecond unix timestamp when this Lavalink jar was built */
+    buildTime: number;
+    /** The git information of this Lavalink server */
+    git: GitObject;
+    /** The JVM version this Lavalink server runs on */
+    jvm: string;
+    /** The Lavaplayer version being used by this server */
+    lavaplayer: string;
+    /** The enabled source managers for this server */
+    sourceManagers: string[];
+    /** The enabled filters for this server */
+    filters: string[];
+    /** The enabled plugins for this server */
+    plugins: PluginObject[];
 }
 /**
- * Filter Data stored in the Client and partially sent to Lavalink
+ * Lavalink's version object from lavalink
  */
-interface FilterData {
-    volume?: number;
-    karaoke?: KaraokeFilter;
-    timescale?: TimescaleFilter;
-    tremolo?: TremoloFilter;
-    vibrato?: VibratoFilter;
-    rotation?: RotationFilter;
-    distortion?: DistortionFilter;
-    channelMix?: ChannelMixFilter;
-    lowPass?: LowPassFilter;
-    pluginFilters?: {
-        "lavalink-filter-plugin"?: {
-            "echo"?: {
-                delay?: number;
-                decay?: number;
-            };
-            "reverb"?: {
-                delays?: number[];
-                gains?: number[];
-            };
-        };
-        "high-pass"?: {
-            cutoffFrequency?: number;
-            boostFactor?: number;
-        };
-        "low-pass"?: {
-            cutoffFrequency?: number;
-            boostFactor?: number;
-        };
-        normalization?: {
-            maxAmplitude?: number;
-            adaptive?: boolean;
-        };
-        echo?: {
-            echoLength?: number;
-            decay?: number;
-        };
-    };
+interface VersionObject {
+    /** The full version string of this Lavalink server */
+    semver: string;
+    /** The major version of this Lavalink server */
+    major: number;
+    /** The minor version of this Lavalink server */
+    minor: number;
+    /** The patch version of this Lavalink server */
+    patch: number;
+    /** The pre-release version according to semver as a . separated list of identifiers */
+    preRelease?: string;
+    /** The build metadata according to semver as a . separated list of identifiers */
+    build?: string;
 }
 /**
- * Actual Filter Data sent to Lavalink
+ * Git information object from lavalink
  */
-interface LavalinkFilterData extends FilterData {
-    equalizer?: EQBand[];
+interface GitObject {
+    /** The branch this Lavalink server was built on */
+    branch: string;
+    /** The commit this Lavalink server was built on */
+    commit: string;
+    /** The millisecond unix timestamp for when the commit was created */
+    commitTime: string;
 }
-
 /**
- * Debug events for more detailed logging
+ * Lavalink's plugins object from lavalink's plugin
  */
-declare enum DebugEvents {
-    SetSponsorBlock = "SetSponsorBlock",
-    DeleteSponsorBlock = "DeleteSponsorBlock",
-    TrackEndReplaced = "TrackEndReplaced",
-    AutoplayExecution = "AutoplayExecution",
-    AutoplayNoSongsAdded = "AutoplayNoSongsAdded",
-    AutoplayThresholdSpamLimiter = "AutoplayThresholdSpamLimiter",
-    TriggerQueueEmptyInterval = "TriggerQueueEmptyInterval",
-    QueueEnded = "QueueEnded",
-    TrackStartNewSongsOnly = "TrackStartNewSongsOnly",
-    TrackStartNoTrack = "TrackStartNoTrack",
-    ResumingFetchingError = "ResumingFetchingError",
-    PlayerUpdateNoPlayer = "PlayerUpdateNoPlayer",
-    PlayerUpdateFilterFixApply = "PlayerUpdateFilterFixApply",
-    PlayerUpdateSuccess = "PlayerUpdateSuccess",
-    HeartBeatTriggered = "HeartBeatTriggered",
-    NoSocketOnDestroy = "NoSocketOnDestroy",
-    SocketCleanupError = "SocketCleanupError",
-    SocketTerminateHeartBeatTimeout = "SocketTerminateHeartBeatTimeout",
-    TryingConnectWhileConnected = "TryingConnectWhileConnected",
-    LavaSearchNothingFound = "LavaSearchNothingFound",
-    SearchNothingFound = "SearchNothingFound",
-    ValidatingBlacklistLinks = "ValidatingBlacklistLinks",
-    ValidatingWhitelistLinks = "ValidatingWhitelistLinks",
-    TrackErrorMaxTracksErroredPerTime = "TrackErrorMaxTracksErroredPerTime",
-    TrackStuckMaxTracksErroredPerTime = "TrackStuckMaxTracksErroredPerTime",
-    PlayerDestroyingSomewhereElse = "PlayerDestroyingSomewhereElse",
-    PlayerCreateNodeNotFound = "PlayerCreateNodeNotFound",
-    PlayerPlayQueueEmptyTimeoutClear = "PlayerPlayQueueEmptyTimeoutClear",
-    PlayerPlayWithTrackReplace = "PlayerPlayWithTrackReplace",
-    PlayerPlayUnresolvedTrack = "PlayerPlayUnresolvedTrack",
-    PlayerPlayUnresolvedTrackFailed = "PlayerPlayUnresolvedTrackFailed",
-    PlayerVolumeAsFilter = "PlayerVolumeAsFilter",
-    BandcampSearchLokalEngine = "BandcampSearchLokalEngine",
-    PlayerChangeNode = "PlayerChangeNode",
-    BuildTrackError = "BuildTrackError",
-    TransformRequesterFunctionFailed = "TransformRequesterFunctionFailed",
-    GetClosestTrackFailed = "GetClosestTrackFailed",
-    PlayerDeleteInsteadOfDestroy = "PlayerDeleteInsteadOfDestroy",
-    FailedToConnectToNodes = "FailedToConnectToNodes",
-    NoAudioDebug = "NoAudioDebug",
-    PlayerAutoReconnect = "PlayerAutoReconnect",
-    PlayerDestroyFail = "PlayerDestroyFail",
-    PlayerChangeNodeFailNoEligibleNode = "PlayerChangeNodeFailNoEligibleNode",
-    PlayerChangeNodeFail = "PlayerChangeNodeFail"
+interface PluginObject {
+    /** The name of the plugin */
+    name: string;
+    /** The version of the plugin */
+    version: string;
+}
+interface LyricsResult {
+    /**The name of the source */
+    sourceName: string;
+    /**The name of the provider */
+    provider: string;
+    /**The result text */
+    text: string | null;
+    /**The lyrics lines */
+    lines: LyricsLine[];
+    /**Information about the plugin */
+    plugin: PluginInfo;
+}
+interface LyricsLine {
+    /**The millisecond timestamp */
+    timestamp: number;
+    /**The line duration in milliseconds */
+    duration: number | null;
+    /**The line text */
+    line: string;
+    /**Information about the plugin */
+    plugin: PluginInfo;
+}
+type LavalinkNodeIdentifier = string;
+interface NodeManagerEvents {
+    /**
+     * Emitted when a Node is created.
+     * @event Manager.nodeManager#create
+     */
+    "create": (node: LavalinkNode) => void;
+    /**
+     * Emitted when a Node is destroyed.
+     * @event Manager.nodeManager#destroy
+     */
+    "destroy": (node: LavalinkNode, destroyReason?: DestroyReasonsType) => void;
+    /**
+     * Emitted when a Node is connected.
+     * @event Manager.nodeManager#connect
+     */
+    "connect": (node: LavalinkNode) => void;
+    /**
+     * Emitted when a Node is reconnecting.
+     * @event Manager.nodeManager#reconnecting
+    */
+    "reconnecting": (node: LavalinkNode) => void;
+    /**
+     * Emitted When a node starts to reconnect (if you have a reconnection delay, the reconnecting event will be emitted after the retryDelay.)
+     * Useful to check wether the internal node reconnect system works or not
+     * @event Manager.nodeManager#reconnectinprogress
+     */
+    "reconnectinprogress": (node: LavalinkNode) => void;
+    /**
+     * Emitted when a Node is disconnects.
+     * @event Manager.nodeManager#disconnect
+    */
+    "disconnect": (node: LavalinkNode, reason: {
+        code?: number;
+        reason?: string;
+    }) => void;
+    /**
+     * Emitted when a Node failed to reconnect after all retry attempts.
+     * @event Manager.nodeManager#reconnectFailed
+    */
+    "reconnectFailed": (node: LavalinkNode, errorMessage: string, attempts: number) => void;
+    /**
+     * Emitted when a Node is error.
+     * @event Manager.nodeManager#error
+    */
+    "error": (node: LavalinkNode, error: Error, payload?: unknown) => void;
+    /**
+     * Emits every single Node event.
+     * @event Manager.nodeManager#raw
+    */
+    "raw": (node: LavalinkNode, payload: unknown) => void;
+    /**
+     * Emits when the node connects resumed. You then need to create all players within this event for your usecase.
+     * Aka for that you need to be able to save player data like vc channel + text channel in a db and then sync it again
+     * @event Manager.nodeManager#nodeResumed
+     */
+    "resumed": (node: LavalinkNode, payload: {
+        resumed: true;
+        sessionId: string;
+        op: "ready";
+    }, players: LavalinkPlayer[] | InvalidLavalinkRestRequest) => void;
 }
-/**
- * Reasons why a player got destroyed
- */
-declare enum DestroyReasons {
-    QueueEmpty = "QueueEmpty",
-    NodeDestroy = "NodeDestroy",
-    NodeDeleted = "NodeDeleted",
-    LavalinkNoVoice = "LavalinkNoVoice",
-    NodeReconnectFail = "NodeReconnectFail",
-    Disconnected = "Disconnected",
-    PlayerReconnectFail = "PlayerReconnectFail",
-    PlayerChangeNodeFail = "PlayerChangeNodeFail",
-    PlayerChangeNodeFailNoEligibleNode = "PlayerChangeNodeFailNoEligibleNode",
-    ChannelDeleted = "ChannelDeleted",
-    DisconnectAllNodes = "DisconnectAllNodes",
-    ReconnectAllNodes = "ReconnectAllNodes",
-    TrackErrorMaxTracksErroredPerTime = "TrackErrorMaxTracksErroredPerTime",
-    TrackStuckMaxTracksErroredPerTime = "TrackStuckMaxTracksErroredPerTime"
+declare enum ReconnectionState {
+    IDLE = "IDLE",
+    RECONNECTING = "RECONNECTING",
+    PENDING = "PENDING",
+    DESTROYING = "DESTROYING"
 }
+
+declare const TrackSymbol: unique symbol;
+declare const UnresolvedTrackSymbol: unique symbol;
+declare const QueueSymbol: unique symbol;
+declare const NodeSymbol: unique symbol;
 /**
- *  Reasons why a player got disconnected
+ * Parses Node Connection Url: "lavalink://<nodeId>:<nodeAuthorization(Password)>@<NodeHost>:<NodePort>"
+ * @param connectionUrl
+ * @returns
  */
-declare enum DisconnectReasons {
-    Disconnected = "Disconnected",
-    DisconnectAllNodes = "DisconnectAllNodes"
-}
-/** The valid SponsorBlock categories */
-declare const validSponsorBlocks: string[];
-/**  The audio Outputs Data map declaration */
-declare const audioOutputsData: Record<AudioOutputs, ChannelMixFilter>;
-/**  Equalizer Presets */
-declare const EQList: {
-    /** A Bassboost Equalizer, so high it distorts the audio */
-    BassboostEarrape: EQBand[];
-    /** A High and decent Bassboost Equalizer */
-    BassboostHigh: EQBand[];
-    /** A decent Bassboost Equalizer */
-    BassboostMedium: EQBand[];
-    /** A slight Bassboost Equalizer */
-    BassboostLow: EQBand[];
-    /** Makes the Music slightly "better" */
-    BetterMusic: EQBand[];
-    /** Makes the Music sound like rock music / sound rock music better */
-    Rock: EQBand[];
-    /** Makes the Music sound like Classic music / sound Classic music better */
-    Classic: EQBand[];
-    /** Makes the Music sound like Pop music / sound Pop music better */
-    Pop: EQBand[];
-    /** Makes the Music sound like Electronic music / sound Electronic music better */
-    Electronic: EQBand[];
-    /** Boosts all Bands slightly for louder and fuller sound */
-    FullSound: EQBand[];
-    /** Boosts basses + lower highs for a pro gaming sound */
-    Gaming: EQBand[];
-};
-
-type DestroyReasonsType = keyof typeof DestroyReasons | string;
-type DisconnectReasonsType = keyof typeof DisconnectReasons | string;
-interface PlayerJson {
-    /** Guild Id where the player was playing in */
-    guildId: string;
-    /** Options provided to the player */
-    options: PlayerOptions;
-    /** Voice Channel Id the player was playing in */
-    voiceChannelId: string;
-    /** Text Channel Id the player was synced to */
-    textChannelId?: string;
-    /** Position the player was at */
-    position: number;
-    /** Lavalink's position the player was at */
-    lastPosition: number;
-    /** Last time the position was sent from lavalink */
-    lastPositionChange: number | null;
-    /** Volume in % from the player (without volumeDecrementer) */
-    volume: number;
-    /** Real Volume used in lavalink (with the volumeDecrementer) */
-    lavalinkVolume: number;
-    /** The repeatmode from the player */
-    repeatMode: RepeatMode;
-    /** Pause state */
-    paused: boolean;
-    /** Wether the player was playing or not */
-    playing: boolean;
-    /** When the player was created */
-    createdTimeStamp?: number;
-    /** All current used fitlers Data */
-    filters: FilterData;
-    /** The player's ping object */
-    ping: {
-        /** Ping to the voice websocket server */
-        ws: number;
-        /** Avg. calc. Ping to the lavalink server */
-        lavalink: number;
-    };
-    /** Equalizer Bands used in lavalink */
-    equalizer: EQBand[];
-    /** The Id of the last used node */
-    nodeId?: string;
-    /** The SessionId of the node */
-    nodeSessionId?: string;
-    /** The stored queue */
-    queue?: StoredQueue;
-}
-type RepeatMode = "queue" | "track" | "off";
-interface PlayerOptions {
-    /** Guild id of the player */
-    guildId: string;
-    /** The Voice Channel Id */
-    voiceChannelId: string;
-    /** The Text Channel Id of the Player */
-    textChannelId?: string;
-    /** instantly change volume with the one play request */
-    volume?: number;
-    /** VC Region for node selections */
-    vcRegion?: string;
-    /** if it should join deafened */
-    selfDeaf?: boolean;
-    /** If it should join muted */
-    selfMute?: boolean;
-    /** If it should use a specific lavalink node */
-    node?: LavalinkNode | string;
-    /** If when applying filters, it should use the insta apply filters fix  */
-    instaUpdateFiltersFix?: boolean;
-    /** If a volume should be applied via filters instead of lavalink-volume */
-    applyVolumeAsFilter?: boolean;
-    /** Custom Data for the player get/set datastorage */
-    customData?: anyObject;
-}
-type anyObject = {
-    [key: string | number]: string | number | null | anyObject;
+declare function parseLavalinkConnUrl(connectionUrl: string): {
+    authorization: string;
+    id: string;
+    host: string;
+    port: number;
 };
-interface BasePlayOptions {
-    /** The position to start the track. */
-    position?: number;
-    /** The position to end the track. */
-    endTime?: number;
-    /** If to start "paused" */
-    paused?: boolean;
-    /** The Volume to start with */
-    volume?: number;
-    /** The Lavalink Filters to use | only with the new REST API */
-    filters?: Partial<LavalinkFilterData>;
-    /** Voice Update for Lavalink */
-    voice?: LavalinkPlayerVoiceOptions;
-}
-interface LavalinkPlayOptions extends BasePlayOptions {
-    /** Which Track to play | don't provide, if it should pick from the Queue */
-    track?: {
-        /** The track encoded base64 string to use instead of the one from the queue system */
-        encoded?: Base64 | null;
-        /** The identifier of the track to use */
-        identifier?: string;
-        /** Custom User Data for the track to provide, will then be on the userData object from the track */
-        userData?: anyObject;
-        /** The Track requester for when u provide encodedTrack / identifer */
-        requester?: unknown;
+declare class ManagerUtils {
+    LavalinkManager: LavalinkManager | undefined;
+    constructor(LavalinkManager?: LavalinkManager);
+    buildPluginInfo(data: any, clientData?: any): any;
+    buildTrack(data: LavalinkTrack | Track, requester: unknown): Track;
+    /**
+     * Builds a UnresolvedTrack to be resolved before being played  .
+     * @param query
+     * @param requester
+     */
+    buildUnresolvedTrack(query: UnresolvedQuery | UnresolvedTrack, requester: unknown): UnresolvedTrack;
+    /**
+     * Validate if a data is equal to a node
+     * @param data
+     */
+    isNode(data: LavalinkNode): boolean;
+    getTransformedRequester(requester: unknown): unknown;
+    /**
+     * Validate if a data is equal to node options
+     * @param data
+     */
+    isNodeOptions(data: LavalinkNodeOptions): boolean;
+    /**
+     * Validate tracks based on duration wether they are playble or broken tracks.
+     * most tracks should be longer than 30s, so you can put a minDuration of 29e3 (cause preview tracks are exactly 30s) or put 0.
+     * This check is not done automatically, you need to check it yourself by doing:
+     * @example
+     * ```ts
+     * const res = await player.search("Adele");
+     *
+     * // short hand:
+     * const validTracks = res.tracks.filter(client.lavalink.utils.isNotBrokenTrack)
+     * // or with options:
+     * const validTracks = res.tracks.filter(t => client.lavalink.utils.isNotBrokenTrack(t, 29e3));
+     *
+     * // then you can add it to the queue.
+     * await player.queue.add(validTracks);
+     * ```
+     */
+    isNotBrokenTrack(data: Track | UnresolvedTrack, minDuration?: number): data is Track;
+    /**
+     * Validate if a data is equal to a track
+     * @param data the Track to validate
+     * @returns
+     */
+    isTrack(data: Track | UnresolvedTrack): data is Track;
+    /**
+     * Checks if the provided argument is a valid UnresolvedTrack.
+     * @param track
+     */
+    isUnresolvedTrack(data: UnresolvedTrack | Track): data is UnresolvedTrack;
+    /**
+     * Checks if the provided argument is a valid UnresolvedTrack.
+     * @param track
+     */
+    isUnresolvedTrackQuery(data: UnresolvedQuery): boolean;
+    getClosestTrack(data: UnresolvedTrack, player: Player): Promise<Track | undefined>;
+    validateQueryString(node: LavalinkNode, queryString: string, sourceString?: LavalinkSearchPlatform): void;
+    transformQuery(query: SearchQuery): {
+        query: string;
+        extraQueryUrlParams: URLSearchParams;
+        source: any;
     };
+    transformLavaSearchQuery(query: LavaSearchQuery): {
+        query: string;
+        types: string[];
+        source: any;
+    };
+    validateSourceString(node: LavalinkNode, sourceString: SearchPlatform): void;
 }
-interface PlayOptions extends LavalinkPlayOptions {
-    /** Whether to not replace the track if a play payload is sent. */
-    noReplace?: boolean;
-    /** Adds track on queue and skips to it */
-    clientTrack?: Track | UnresolvedTrack;
+/**
+ * Separate interface for the constructor so that emitted js does not have a constructor that overwrites itself
+ *
+ * @internal
+ */
+interface MiniMap<K, V> extends Map<K, V> {
+    constructor: MiniMapConstructor;
 }
-
-type NodeLinkEventTypes = "PlayerCreatedEvent" | "PlayerDestroyedEvent" | "PlayerConnectedEvent" | "PlayerReconnectingEvent" | "VolumeChangedEvent" | "FiltersChangedEvent" | "SeekEvent" | "PauseEvent" | "ConnectionStatusEvent" | "MixStartedEvent" | "MixEndedEvent";
-interface NodeLinkBaseEvent {
-    op: "event";
-    type: NodeLinkEventTypes;
-    guildId: string;
+declare class MiniMap<K, V> extends Map<K, V> {
+    constructor(data?: [K, V][]);
+    /**
+     * Identical to
+     * [Array.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
+     * but returns a MiniMap instead of an Array.
+     *
+     * @param fn The function to test with (should return boolean)
+     * @param thisArg Value to use as `this` when executing function
+     *
+     * @example
+     * miniMap.filter(user => user.username === 'Bob');
+     */
+    filter<K2 extends K>(fn: (value: V, key: K, miniMap: this) => key is K2): MiniMap<K2, V>;
+    filter<V2 extends V>(fn: (value: V, key: K, miniMap: this) => value is V2): MiniMap<K, V2>;
+    filter(fn: (value: V, key: K, miniMap: this) => boolean): MiniMap<K, V>;
+    filter<This, K2 extends K>(fn: (this: This, value: V, key: K, miniMap: this) => key is K2, thisArg: This): MiniMap<K2, V>;
+    filter<This, V2 extends V>(fn: (this: This, value: V, key: K, miniMap: this) => value is V2, thisArg: This): MiniMap<K, V2>;
+    filter<This>(fn: (this: This, value: V, key: K, miniMap: this) => boolean, thisArg: This): MiniMap<K, V>;
+    toJSON(): [K, V][];
+    /**
+     * Maps each item to another value into an array. Identical in behavior to
+     * [Array.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).
+     *
+     * @param fn Function that produces an element of the new array, taking three arguments
+     * @param thisArg Value to use as `this` when executing function
+     *
+     * @example
+     * miniMap.map(user => user.tag);
+     */
+    map<T>(fn: (value: V, key: K, miniMap: this) => T): T[];
+    map<This, T>(fn: (this: This, value: V, key: K, miniMap: this) => T, thisArg: This): T[];
 }
-interface PlayerCreatedEvent extends NodeLinkBaseEvent {
-    type: "PlayerCreatedEvent";
+declare function queueTrackEnd(player: Player, dontShiftQueue?: boolean): Promise<Track>;
+declare function safeStringify(obj: any, padding?: number): string;
+
+/** Helper for generating Opaque types. */
+type Opaque<T, K> = T & {
+    __opaque__: K;
+};
+/** Opqaue tyep for integernumber */
+type IntegerNumber = Opaque<number, 'Int'>;
+/** Opqaue tyep for floatnumber */
+type FloatNumber = Opaque<number, 'Float'>;
+type LavaSrcSearchPlatformBase = "spsearch" | "sprec" | "amsearch" | "dzsearch" | "dzisrc" | "dzrec" | "ymsearch" | "ymrec" | "vksearch" | "vkrec" | "tdsearch" | "tdrec" | "qbsearch" | "qbisrc" | "qbrec" | "pdsearch" | "pdisrc" | "pdrec";
+type LavaSrcSearchPlatform = LavaSrcSearchPlatformBase | "ftts";
+type JioSaavnSearchPlatform = "jssearch" | "jsrec";
+type DuncteSearchPlatform = "speak" | "phsearch" | "pornhub" | "porn" | "tts";
+type LavalinkClientSearchPlatform = "bcsearch";
+type LavalinkClientSearchPlatformResolve = "bandcamp" | "bc";
+type LavalinkSearchPlatform = "ytsearch" | "ytmsearch" | "scsearch" | "bcsearch" | LavaSrcSearchPlatform | DuncteSearchPlatform | JioSaavnSearchPlatform | LavalinkClientSearchPlatform;
+type ClientCustomSearchPlatformUtils = "local" | "http" | "https" | "link" | "uri";
+type ClientSearchPlatform = ClientCustomSearchPlatformUtils | // for file/link requests
+"youtube" | "yt" | "youtube music" | "youtubemusic" | "ytm" | "musicyoutube" | "music youtube" | "soundcloud" | "sc" | "am" | "apple music" | "applemusic" | "apple" | "musicapple" | "music apple" | "sp" | "spsuggestion" | "spotify" | "spotify.com" | "spotifycom" | "dz" | "deezer" | "yandex" | "yandex music" | "yandexmusic" | "vk" | "vk music" | "vkmusic" | "tidal" | "tidal music" | "qobuz" | "pandora" | "pd" | "pandora music" | "pandoramusic" | "flowerytts" | "flowery" | "flowery.tts" | LavalinkClientSearchPlatformResolve | LavalinkClientSearchPlatform | "js" | "jiosaavn" | "td" | "tidal" | "tdrec";
+type SearchPlatform = LavalinkSearchPlatform | ClientSearchPlatform;
+type SourcesRegex = "YoutubeRegex" | "YoutubeMusicRegex" | "SoundCloudRegex" | "SoundCloudMobileRegex" | "DeezerTrackRegex" | "DeezerArtistRegex" | "DeezerEpisodeRegex" | "DeezerMixesRegex" | "DeezerPageLinkRegex" | "DeezerPlaylistRegex" | "DeezerAlbumRegex" | "AllDeezerRegex" | "AllDeezerRegexWithoutPageLink" | "SpotifySongRegex" | "SpotifyPlaylistRegex" | "SpotifyArtistRegex" | "SpotifyEpisodeRegex" | "SpotifyShowRegex" | "SpotifyAlbumRegex" | "AllSpotifyRegex" | "mp3Url" | "m3uUrl" | "m3u8Url" | "mp4Url" | "m4aUrl" | "wavUrl" | "aacpUrl" | "tiktok" | "mixcloud" | "musicYandex" | "radiohost" | "bandcamp" | "jiosaavn" | "appleMusic" | "tidal" | "PandoraTrackRegex" | "PandoraAlbumRegex" | "PandoraArtistRegex" | "PandoraPlaylistRegex" | "AllPandoraRegex" | "TwitchTv" | "vimeo";
+interface PlaylistInfo {
+    /** The playlist name */
+    name: string;
+    /** The playlist title (same as name) */
+    title: string;
+    /** The playlist Author */
+    author?: string;
+    /** The playlist Thumbnail */
+    thumbnail?: string;
+    /** A Uri to the playlist */
+    uri?: string;
+    /** The playlist selected track. */
+    selectedTrack: Track | null;
+    /** The duration of the entire playlist. (calcualted) */
+    duration: number;
 }
-interface PlayerDestroyedEvent extends NodeLinkBaseEvent {
-    type: "PlayerDestroyedEvent";
+interface SearchResult {
+    loadType: LoadTypes;
+    exception: Exception | null;
+    pluginInfo: PluginInfo;
+    playlist: PlaylistInfo | null;
+    tracks: Track[];
 }
-interface PlayerConnectedEvent extends NodeLinkBaseEvent {
-    type: "PlayerConnectedEvent";
+interface UnresolvedSearchResult {
+    loadType: LoadTypes;
+    exception: Exception | null;
+    pluginInfo: PluginInfo;
+    playlist: PlaylistInfo | null;
+    tracks: UnresolvedTrack[];
 }
-interface PlayerReconnectingEvent extends NodeLinkBaseEvent {
-    type: "PlayerReconnectingEvent";
+/**
+ * @internal
+ */
+interface MiniMapConstructor {
+    new (): MiniMap<unknown, unknown>;
+    new <K, V>(entries?: ReadonlyArray<readonly [K, V]> | null): MiniMap<K, V>;
+    new <K, V>(iterable: Iterable<readonly [K, V]>): MiniMap<K, V>;
+    readonly prototype: MiniMap<unknown, unknown>;
+    readonly [Symbol.species]: MiniMapConstructor;
 }
-interface VolumeChangedEvent extends NodeLinkBaseEvent {
-    type: "VolumeChangedEvent";
-    /** New volume level (0-1000) */
-    volume: number;
+type PlayerEvents = TrackStartEvent | TrackEndEvent | TrackStuckEvent | TrackExceptionEvent | WebSocketClosedEvent | SponsorBlockSegmentEvents | LyricsEvent;
+type Severity = "COMMON" | "SUSPICIOUS" | "FAULT";
+interface Exception {
+    /** Severity of the error */
+    severity: Severity;
+    /** Nodejs Error */
+    error?: Error;
+    /** Message by lavalink */
+    message: string;
+    /** Cause by lavalink */
+    cause: string;
+    /** causeStackTrace by lavalink */
+    causeStackTrace: string;
 }
-interface FiltersChangedEvent extends NodeLinkBaseEvent {
-    type: "FiltersChangedEvent";
-    filters: LavalinkFilterData;
+interface PlayerEvent {
+    op: "event";
+    type: PlayerEventType;
+    guildId: string;
 }
-interface SeekEvent extends NodeLinkBaseEvent {
-    type: "SeekEvent";
-    /** New position in milliseconds */
-    position: number;
+interface TrackStartEvent extends PlayerEvent {
+    type: "TrackStartEvent";
+    track: LavalinkTrack;
 }
-interface PauseEvent extends NodeLinkBaseEvent {
-    type: "PauseEvent";
-    /** Whether playback is now paused (true) or resumed (false) */
-    paused: boolean;
+interface TrackEndEvent extends PlayerEvent {
+    type: "TrackEndEvent";
+    track: LavalinkTrack;
+    reason: TrackEndReason;
 }
-interface ConnectionStatusEvent extends NodeLinkBaseEvent {
-    type: "ConnectionStatusEvent";
-    /** Current connection status */
-    connected: boolean;
+interface TrackExceptionEvent extends PlayerEvent {
+    type: "TrackExceptionEvent";
+    exception?: Exception;
+    track: LavalinkTrack;
+    error: string;
 }
-interface MixStartedEvent extends NodeLinkBaseEvent {
-    type: "MixStartedEvent";
-    /** Unique identifier for the mix layer */
-    mixId: string;
-    /** Full track information of the mixed layer */
+interface TrackStuckEvent extends PlayerEvent {
+    type: "TrackStuckEvent";
+    thresholdMs: number;
     track: LavalinkTrack;
-    /** Volume of the mixed layer (0.0 to 1.0) */
-    volume: number;
 }
-interface MixEndedEvent extends NodeLinkBaseEvent {
-    type: "MixEndedEvent";
-    /** Unique identifier for the mix layer */
-    mixId: string;
-    /** Reason the mix layer ended (FINISHED, REMOVED, ERROR, MAIN_ENDED) */
-    reason: "FINISHED" | "REMOVED" | "ERROR" | "MAIN_ENDED" | string;
+interface WebSocketClosedEvent extends PlayerEvent {
+    type: "WebSocketClosedEvent";
+    code: number;
+    byRemote: boolean;
+    reason: string;
 }
-type NodeLinkEventPayload<T extends NodeLinkEventTypes> = T extends "PlayerCreatedEvent" ? PlayerCreatedEvent : T extends "PlayerDestroyedEvent" ? PlayerDestroyedEvent : T extends "PlayerConnectedEvent" ? PlayerConnectedEvent : T extends "PlayerReconnectingEvent" ? PlayerReconnectingEvent : T extends "VolumeChangedEvent" ? VolumeChangedEvent : T extends "FiltersChangedEvent" ? FiltersChangedEvent : T extends "SeekEvent" ? SeekEvent : T extends "PauseEvent" ? PauseEvent : T extends "ConnectionStatusEvent" ? ConnectionStatusEvent : T extends "MixStartedEvent" ? MixStartedEvent : T extends "MixEndedEvent" ? MixEndedEvent : never;
-
-/** Ability to manipulate fetch requests */
-type ModifyRequest = (options: RequestInit & {
-    path: string;
-    extraQueryUrlParams?: URLSearchParams;
-}) => void;
-type SponsorBlockSegment = "sponsor" | "selfpromo" | "interaction" | "intro" | "outro" | "preview" | "music_offtopic" | "filler";
 /**
- * Node Options for creating a lavalink node
+ * Types & Events for Sponsorblock-plugin from Lavalink: https://github.com/topi314/Sponsorblock-Plugin#segmentsloaded
  */
-interface LavalinkNodeOptions {
-    /** The Lavalink Server-Ip / Domain-URL */
-    host: string;
-    /** The Lavalink Connection Port */
-    port: number;
-    /** The Lavalink Password / Authorization-Key */
-    authorization: string;
-    /** Does the Server use ssl (https) */
-    secure?: boolean;
-    /** RESUME THE PLAYER? by providing a sessionid on the node-creation */
-    sessionId?: string;
-    /** Add a Custom ID to the node, for later use */
-    id?: string;
-    /** Voice Regions of this Node */
-    regions?: string[];
-    /** The max amount of retries for this node. */
-    retryAmount?: number;
-    /** The delay of how often to retry a reconnection. */
-    retryDelay?: number;
-    /** How long a retry is a valid retry, it should be at least retryAmount*retryDelay. if <= 0 (default) then this won't be accounted. */
-    retryTimespan?: number;
-    /** signal for cancelling requests - default: AbortSignal.timeout(options.requestSignalTimeoutMS || 10000) - put <= 0 to disable */
-    requestSignalTimeoutMS?: number;
-    /** Close on error */
-    closeOnError?: boolean;
-    /** Heartbeat interval , set to <= 0 to disable heartbeat system */
-    heartBeatInterval?: number;
-    /** Recommended, to check wether the client is still connected or not on the stats endpoint */
-    enablePingOnStatsCheck?: boolean;
+type SponsorBlockSegmentEvents = SponsorBlockSegmentSkipped | SponsorBlockSegmentsLoaded | SponsorBlockChapterStarted | SponsorBlockChaptersLoaded;
+type SponsorBlockSegmentEventType = "SegmentSkipped" | "SegmentsLoaded" | "ChaptersLoaded" | "ChapterStarted";
+interface SponsorBlockSegmentsLoaded extends PlayerEvent {
+    type: "SegmentsLoaded";
+    segments: {
+        category: string;
+        start: number;
+        end: number;
+    }[];
 }
-/**
- * Memory Stats object from lavalink
- */
-interface MemoryStats {
-    /** The free memory of the allocated amount. */
-    free: number;
-    /** The used memory of the allocated amount. */
-    used: number;
-    /** The total allocated memory. */
-    allocated: number;
-    /** The reservable memory. */
-    reservable: number;
+interface SponsorBlockSegmentSkipped extends PlayerEvent {
+    type: "SegmentSkipped";
+    segment: {
+        category: string;
+        start: number;
+        end: number;
+    };
+}
+interface SponsorBlockChapterStarted extends PlayerEvent {
+    type: "ChapterStarted";
+    /** The Chapter which started */
+    chapter: {
+        /** The Name of the Chapter */
+        name: string;
+        start: number;
+        end: number;
+        duration: number;
+    };
+}
+interface SponsorBlockChaptersLoaded extends PlayerEvent {
+    type: "ChaptersLoaded";
+    /** All Chapters loaded */
+    chapters: {
+        /** The Name of the Chapter */
+        name: string;
+        start: number;
+        end: number;
+        duration: number;
+    }[];
 }
 /**
- * CPU Stats object from lavalink
+ * Types & Events for Lyrics plugin from Lavalink: https://github.com/topi314/LavaLyrics
  */
-interface CPUStats {
-    /** The core amount the host machine has. */
-    cores: number;
-    /** The system load. */
-    systemLoad: number;
-    /** The lavalink load. */
-    lavalinkLoad: number;
+type LyricsEvent = LyricsFoundEvent | LyricsNotFoundEvent | LyricsLineEvent;
+type LyricsEventType = "LyricsFoundEvent" | "LyricsNotFoundEvent" | "LyricsLineEvent";
+interface LyricsFoundEvent extends PlayerEvent {
+    /** The lyricsfound event */
+    type: "LyricsFoundEvent";
+    /** The guildId */
+    guildId: string;
+    /** The lyrics */
+    lyrics: LyricsResult;
 }
-/**
- * FrameStats Object from lavalink
- */
-interface FrameStats {
-    /** The amount of sent frames. */
-    sent?: number;
-    /** The amount of nulled frames. */
-    nulled?: number;
-    /** The amount of deficit frames. */
-    deficit?: number;
+interface LyricsNotFoundEvent extends PlayerEvent {
+    /**The lyricsnotfound event*/
+    type: "LyricsNotFoundEvent";
+    /**The guildId*/
+    guildId: string;
 }
-/**
- * BaseNodeStats object from Lavalink
- */
-interface BaseNodeStats {
-    /** The amount of players on the node. */
-    players: number;
-    /** The amount of playing players on the node. */
-    playingPlayers: number;
-    /** The uptime for the node. */
-    uptime: number;
-    /** The memory stats for the node. */
-    memory: MemoryStats;
-    /** The cpu stats for the node. */
-    cpu: CPUStats;
-    /** The frame stats for the node. */
-    frameStats: FrameStats;
+interface LyricsLineEvent extends PlayerEvent {
+    /**The lyricsline event*/
+    type: "LyricsLineEvent";
+    /** The guildId */
+    guildId: string;
+    /** The line number */
+    lineIndex: number;
+    /** The line */
+    line: LyricsLine;
+    /**skipped is true if the line was skipped */
+    skipped: boolean;
+}
+type LoadTypes = "track" | "playlist" | "search" | "error" | "empty";
+type State = "CONNECTED" | "CONNECTING" | "DISCONNECTED" | "DISCONNECTING" | "DESTROYING";
+type PlayerEventType = "TrackStartEvent" | "TrackEndEvent" | "TrackExceptionEvent" | "TrackStuckEvent" | "WebSocketClosedEvent" | SponsorBlockSegmentEventType | LyricsEventType;
+type TrackEndReason = "finished" | "loadFailed" | "stopped" | "replaced" | "cleanup";
+interface InvalidLavalinkRestRequest {
+    /** Rest Request Data for when it was made */
+    timestamp: number;
+    /** Status of the request */
+    status: number;
+    /** Specific Errro which was sent */
+    error: string;
+    /** Specific Message which was created */
+    message?: string;
+    /** The specific error trace from the request */
+    trace?: unknown;
+    /** Path of where it's from */
+    path: string;
+}
+interface LavalinkPlayerVoice {
+    /** The Voice Token */
+    token: string;
+    /** The Voice Server Endpoint  */
+    endpoint: string;
+    /** The Voice SessionId */
+    sessionId: string;
+    /** Wether or not the player is connected */
+    connected?: boolean;
+    /** The Ping to the voice server */
+    ping?: number;
+}
+type LavalinkPlayerVoiceOptions = Omit<LavalinkPlayerVoice, 'connected' | 'ping'>;
+interface FailingAddress {
+    /** The failing address */
+    failingAddress: string;
+    /** The timestamp when the address failed */
+    failingTimestamp: number;
+    /** The timestamp when the address failed as a pretty string */
+    failingTime: string;
 }
-interface NodeLinkConnectionMetrics {
-    status: string;
-    metrics: {
-        speed: {
-            bps: number;
-            kbps: number;
-            mbps: number;
+type RoutePlannerTypes = "RotatingIpRoutePlanner" | "NanoIpRoutePlanner" | "RotatingNanoIpRoutePlanner" | "BalancingIpRoutePlanner";
+interface RoutePlanner {
+    class?: RoutePlannerTypes;
+    details?: {
+        /** The ip block being used */
+        ipBlock: {
+            /** The type of the ip block */
+            type: "Inet4Address" | "Inet6Address";
+            /** 	The size of the ip block */
+            size: string;
         };
-        downloadedBytes: number;
-        durationSeconds: number;
-        timestamp: number;
+        /** The failing addresses */
+        failingAddresses: FailingAddress[];
+        /** The number of rotations */
+        rotateIndex?: string;
+        /** The current offset in the block	 */
+        ipIndex?: string;
+        /** The current address being used	 */
+        currentAddress?: string;
+        /** The current offset in the ip block */
+        currentAddressIndex?: string;
+        /** The information in which /64 block ips are chosen. This number increases on each ban. */
+        blockIndex?: string;
     };
 }
-/**
- * Interface for nodeStats from lavalink
- */
-interface NodeStats extends BaseNodeStats {
-    /** The frame stats for the node. */
-    frameStats: FrameStats;
-    /** something from nodeLink https://nodelink.js.org/docs/differences#detailed-statistics */
-    detailedStats?: {
-        api: {
-            /** e.g. { "/v4/loadtracks": 150, "/v4/info": 5 }  */
-            requests: Record<string, number>;
-            errors: unknown;
-        };
-        /** e.g. { "youtube": 150, "soundcloud": 5 } */
-        sources: Record<string, number>;
-        playback: {
-            /** e.g. { "TrackStartEvent": 150, "TrackEndEvent": 5 } */
-            events: Record<string, number>;
-        };
-        /** and potential others */
-        [key: string]: unknown;
+interface Session {
+    /** Wether or not session is resuming or not */
+    resuming: boolean;
+    /** For how long a session is lasting while not connected */
+    timeout: number;
+}
+interface GuildShardPayload {
+    /** The OP code */
+    op: number;
+    /** Data to send  */
+    d: {
+        /** Guild id to apply voice settings */
+        guild_id: string;
+        /** channel to move/connect to, or null to leave it */
+        channel_id: string | null;
+        /** wether or not mute yourself */
+        self_mute: boolean;
+        /** wether or not deafen yourself */
+        self_deaf: boolean;
     };
 }
-/**
- * Entire lavalink information object from lavalink
- */
-interface LavalinkInfo {
-    /** The version of this Lavalink server */
-    version: VersionObject;
-    /** The millisecond unix timestamp when this Lavalink jar was built */
-    buildTime: number;
-    /** The git information of this Lavalink server */
-    git: GitObject;
-    /** The JVM version this Lavalink server runs on */
-    jvm: string;
-    /** The Lavaplayer version being used by this server */
-    lavaplayer: string;
-    /** The enabled source managers for this server */
-    sourceManagers: string[];
-    /** The enabled filters for this server */
-    filters: string[];
-    /** The enabled plugins for this server */
-    plugins: PluginObject[];
-    /** Something from NodeLink: https://nodelink.js.org/docs/differences#server-info */
-    isNodelink?: boolean;
+interface PlayerUpdateInfo {
+    /** guild id of the player */
+    guildId: string;
+    /** Player options to provide to lavalink */
+    playerOptions: LavalinkPlayOptions;
+    /** Whether or not replace the current track with the new one (true is recommended) */
+    noReplace?: boolean;
 }
-/**
- * Lavalink's version object from lavalink
- */
-interface VersionObject {
-    /** The full version string of this Lavalink server */
-    semver: string;
-    /** The major version of this Lavalink server */
-    major: number;
-    /** The minor version of this Lavalink server */
-    minor: number;
-    /** The patch version of this Lavalink server */
-    patch: number;
-    /** The pre-release version according to semver as a . separated list of identifiers */
-    preRelease?: string;
-    /** The build metadata according to semver as a . separated list of identifiers */
-    build?: string;
+interface LavalinkPlayer {
+    /** Guild Id of the player */
+    guildId: string;
+    /** IF playing a track, all of the track information */
+    track?: LavalinkTrack;
+    /** Lavalink volume (mind volumedecrementer) */
+    volume: number;
+    /** Wether it's paused or not */
+    paused: boolean;
+    /** Voice Endpoint data */
+    voice: LavalinkPlayerVoice;
+    /** All Audio Filters */
+    filters: Partial<LavalinkFilterData>;
+    /** Lavalink-Voice-State Variables */
+    state: {
+        /** Time since connection established */
+        time: number;
+        /** Position of the track */
+        position: number;
+        /** COnnected or not */
+        connected: boolean;
+        /** Ping to voice server */
+        ping: number;
+    };
 }
-/**
- * Git information object from lavalink
- */
-interface GitObject {
-    /** The branch this Lavalink server was built on */
-    branch: string;
-    /** The commit this Lavalink server was built on */
-    commit: string;
-    /** The millisecond unix timestamp for when the commit was created */
-    commitTime: string;
+interface ChannelDeletePacket {
+    /** Packet key for channel delete */
+    t: "CHANNEL_DELETE";
+    /** data which is sent and relevant */
+    d: {
+        /** guild id */
+        guild_id: string;
+        /** Channel id */
+        id: string;
+    };
+}
+interface VoiceState {
+    /** OP key from lavalink */
+    op: "voiceUpdate";
+    /** GuildId provided by lavalink */
+    guildId: string;
+    /** Event data */
+    event: VoiceServer;
+    /** Session Id of the voice connection */
+    sessionId?: string;
+    /** guild id of the voice channel */
+    guild_id: string;
+    /** user id from the voice connection */
+    user_id: string;
+    /** Session Id of the voice connection */
+    session_id: string;
+    /** Voice Channel Id */
+    channel_id: string;
+    /** Server Mute status */
+    mute: boolean;
+    /** Server Deaf status */
+    deaf: boolean;
+    /** Self Deaf status */
+    self_deaf: boolean;
+    /** Self Mute status */
+    self_mute: boolean;
+    /** Self Video (Camera) status */
+    self_video: boolean;
+    /** Self Stream status */
+    self_stream: boolean;
+    /** Wether the user requests to speak (stage channel) */
+    request_to_speak_timestamp: boolean;
+    /** Self suppressed status (stage channel) */
+    suppress: boolean;
 }
-/**
- * Lavalink's plugins object from lavalink's plugin
- */
-interface PluginObject {
-    /** The name of the plugin */
-    name: string;
-    /** The version of the plugin */
-    version: string;
+/** The Base64 decodes tring by lavalink */
+type Base64 = string;
+interface VoiceServer {
+    /** Voice Token */
+    token: string;
+    /** Guild Id of the voice server connection */
+    guild_id: string;
+    /** Server Endpoint */
+    endpoint: string;
 }
-interface LyricsResult {
-    /**The name of the source */
-    sourceName: string;
-    /**The name of the provider */
-    provider: string;
-    /**The result text */
-    text: string | null;
-    /**The lyrics lines */
-    lines: LyricsLine[];
-    /**Information about the plugin */
-    plugin: PluginInfo;
+interface VoicePacket {
+    /** Voice Packet Keys to send */
+    t?: "VOICE_SERVER_UPDATE" | "VOICE_STATE_UPDATE";
+    /** Voice Packets to send */
+    d: VoiceState | VoiceServer;
 }
-interface LyricsLine {
-    /**The millisecond timestamp */
-    timestamp: number;
-    /**The line duration in milliseconds */
-    duration: number | null;
-    /**The line text */
-    line: string;
-    /**Information about the plugin */
-    plugin: PluginInfo;
+interface NodeMessage extends NodeStats {
+    /** The type of the event */
+    type: PlayerEventType;
+    /** what ops are applying to that event */
+    op: "stats" | "playerUpdate" | "event";
+    /** The specific guild id for that message */
+    guildId: string;
 }
-type LavalinkNodeIdentifier = string;
-interface NodeManagerEvents {
-    /**
-     * Emitted when a Node is created.
-     * @event Manager.nodeManager#create
-     */
-    "create": (node: LavalinkNode) => void;
-    /**
-     * Emitted when a Node is destroyed.
-     * @event Manager.nodeManager#destroy
-     */
-    "destroy": (node: LavalinkNode, destroyReason?: DestroyReasonsType) => void;
-    /**
-     * Emitted when a Node is connected.
-     * @event Manager.nodeManager#connect
-     */
-    "connect": (node: LavalinkNode) => void;
-    /**
-     * Emitted when a Node is reconnecting.
-     * @event Manager.nodeManager#reconnecting
-    */
-    "reconnecting": (node: LavalinkNode) => void;
-    /**
-     * Emitted When a node starts to reconnect (if you have a reconnection delay, the reconnecting event will be emitted after the retryDelay.)
-     * Useful to check wether the internal node reconnect system works or not
-     * @event Manager.nodeManager#reconnectinprogress
-     */
-    "reconnectinprogress": (node: LavalinkNode) => void;
-    /**
-     * Emitted when a Node is disconnects.
-     * @event Manager.nodeManager#disconnect
-    */
-    "disconnect": (node: LavalinkNode, reason: {
-        code?: number;
-        reason?: string;
-    }) => void;
-    /**
-     * Emitted when a Node is error.
-     * @event Manager.nodeManager#error
-    */
-    "error": (node: LavalinkNode, error: Error, payload?: unknown) => void;
-    /**
-     * Emits every single Node event.
-     * @event Manager.nodeManager#raw
-    */
-    "raw": (node: LavalinkNode, payload: unknown) => void;
-    /**
-     * Emits when the node connects resumed. You then need to create all players within this event for your usecase.
-     * Aka for that you need to be able to save player data like vc channel + text channel in a db and then sync it again
-     * @event Manager.nodeManager#nodeResumed
-     */
-    "resumed": (node: LavalinkNode, payload: {
-        resumed: true;
-        sessionId: string;
-        op: "ready";
-    }, players: LavalinkPlayer[] | InvalidLavalinkRestRequest) => void;
-    /**
-     * Event Handler for Nodelink specific events https://nodelink.js.org/docs/api/websocket Fully typed and generic based on the eventName.
-     * @event Manager.nodeManager#nodeLinkEvent
-     * @example
-     *
-     * ```ts
-     * this.nodeManager.on("nodeLinkEvent", (node, event, player, track, payload) => {
-     *   if (event === "SeekEvent") {
-     *       console.log("new position:", payload.position);
-     *   }
-     *   if (event === "FiltersChangedEvent") {
-     *       console.log("new filters state", payload.filters);
-     *   }
-     * });
-     * ```
-     */
-    "nodeLinkEvent": (...args: {
-        [K in NodeLinkEventTypes]: [node: LavalinkNode, event: K, player: Player, track: Track | null, payload: NodeLinkEventPayload<K>];
-    }[NodeLinkEventTypes]) => void;
+/** Specific types to filter for lavasearch, will be filtered to correct types */
+type LavaSearchType = "track" | "album" | "artist" | "playlist" | "text" | "tracks" | "albums" | "artists" | "playlists" | "texts";
+interface LavaSearchFilteredResponse {
+    /** The Information of a playlist provided by lavasearch */
+    info: PlaylistInfo;
+    /** additional plugin information */
+    pluginInfo: PluginInfo;
+    /** List of tracks  */
+    tracks: Track[];
 }
-declare enum ReconnectionState {
-    IDLE = "IDLE",
-    RECONNECTING = "RECONNECTING",
-    PENDING = "PENDING",
-    DESTROYING = "DESTROYING"
+interface LavaSearchResponse {
+    /** An array of tracks, only present if track is in types */
+    tracks: Track[];
+    /** An array of albums, only present if album is in types */
+    albums: LavaSearchFilteredResponse[];
+    /** 	An array of artists, only present if artist is in types */
+    artists: LavaSearchFilteredResponse[];
+    /** 	An array of playlists, only present if playlist is in types */
+    playlists: LavaSearchFilteredResponse[];
+    /** An array of text results, only present if text is in types */
+    texts: {
+        text: string;
+        pluginInfo: PluginInfo;
+    }[];
+    /** Addition result data provided by plugins */
+    pluginInfo: PluginInfo;
 }
+/** SearchQuery Object for raw lavalink requests */
+type SearchQuery = {
+    /** lavalink search Query / identifier string */
+    query: string;
+    /** Extra url query params to use, e.g. for flowertts */
+    extraQueryUrlParams?: URLSearchParams;
+    /** Source to append to the search query string */
+    source?: SearchPlatform;
+} | /** Our just the search query / identifier string */ string;
+/** SearchQuery Object for Lavalink LavaSearch Plugin requests */
+type LavaSearchQuery = {
+    /** lavalink search Query / identifier string */
+    query: string;
+    /** Source to append to the search query string */
+    source: LavaSrcSearchPlatformBase;
+    /** The Types to filter the search to */
+    types?: LavaSearchType[];
+};
+type Awaitable<T> = Promise<T> | T;
 
 /**
  * Lavalink Node creator class
@@ -2317,6 +2191,7 @@ declare enum ReconnectionState {
 declare class LavalinkNode {
     private heartBeatPingTimestamp;
     private heartBeatPongTimestamp;
+    get heartBeatPing(): number;
     private heartBeatInterval?;
     private pingTimeout?;
     isAlive: boolean;
@@ -2335,64 +2210,18 @@ declare class LavalinkNode {
     };
     /** Actual Lavalink Information of the Node */
     info: LavalinkInfo | null;
-    /** current state of the Reconnections */
-    reconnectionState: ReconnectionState;
     /** The Node Manager of this Node */
     private NodeManager;
     /** The Reconnection Timeout */
     private reconnectTimeout?;
-    /** The Reconnection Attempt counter (array of datetimes when it tried it.) */
+    /** The Reconnection Attempt counter */
     private reconnectAttempts;
+    /** Reconnection current state */
+    private reconnectionState;
     /** The Socket of the Lavalink */
     private socket;
     /** Version of what the Lavalink Server should be */
     private version;
-    /**
-     * Returns the LavalinkManager of the Node
-     */
-    private get _LManager();
-    /**
-     * Returns the Heartbeat Ping of the Node
-     */
-    get heartBeatPing(): number;
-    /**
-     * Returns wether the plugin validations are enabled or not
-     */
-    private get _checkForPlugins();
-    /**
-     * Returns wether the source validations are enabled or not
-     */
-    private get _checkForSources();
-    /**
-     * Emits a debug event to the LavalinkManager
-     * @param name name of the event
-     * @param eventData event data
-     */
-    private _emitDebugEvent;
-    /**
-     * Returns if connected to the Node.
-     *
-     * @example
-     * ```ts
-     * const isConnected = player.node.connected;
-     * console.log("node is connected: ", isConnected ? "yes" : "no")
-     * ```
-     */
-    get connected(): boolean;
-    /**
-     * Returns the current ConnectionStatus
-     *
-     * @example
-     * ```ts
-     * try {
-     *     const statusOfConnection = player.node.connectionStatus;
-     *     console.log("node's connection status is:", statusOfConnection)
-     * } catch (error) {
-     *     console.error("no socket available?", error)
-     * }
-     * ```
-     */
-    get connectionStatus(): string;
     /**
      * Create a new Node
      * @param options Lavalink Node Options
@@ -2538,10 +2367,34 @@ declare class LavalinkNode {
      *
      * @example
      * ```ts
-     * player.node.disconnect("Forcefully disconnect the connection to the node.");
+     * player.node.destroy("custom Player Destroy Reason", true);
      * ```
      */
     disconnect(disconnectReason?: DisconnectReasonsType): void;
+    /**
+     * Returns if connected to the Node.
+     *
+     * @example
+     * ```ts
+     * const isConnected = player.node.connected;
+     * console.log("node is connected: ", isConnected ? "yes" : "no")
+     * ```
+     */
+    get connected(): boolean;
+    /**
+     * Returns the current ConnectionStatus
+     *
+     * @example
+     * ```ts
+     * try {
+     *     const statusOfConnection = player.node.connectionStatus;
+     *     console.log("node's connection status is:", statusOfConnection)
+     * } catch (error) {
+     *     console.error("no socket available?", error)
+     * }
+     * ```
+     */
+    get connectionStatus(): string;
     /**
      * Gets all Players of a Node
      * @returns array of players inside of lavalink
@@ -2675,16 +2528,6 @@ declare class LavalinkNode {
      * ```
      */
     fetchStats(): Promise<BaseNodeStats>;
-    /**
-     * Request NodeLink connection metrics. https://nodelink.js.org/docs/differences#connection-metrics
-     * @returns the connection metrics of the node
-     *
-     * @example
-     * ```ts
-     * const connectionMetrics = await player.node.fetchConnectionMetrics();
-     * ```
-     */
-    fetchConnectionMetrics(): Promise<NodeLinkConnectionMetrics>;
     /**
      * Request Lavalink version.
      * @returns the current used lavalink version
@@ -2758,26 +2601,17 @@ declare class LavalinkNode {
      * Get the rest Adress for making requests
      */
     private get restAddress();
-    /**
-     * If already trying to reconnect or pending, return
-     */
-    get isNodeReconnecting(): boolean;
     /**
      * Reconnect to the lavalink node
-     * @param force @default false Wether to instantly try to reconnect (force it)
+     * @param instaReconnect @default false wether to instantly try to reconnect
      * @returns void
      *
      * @example
      * ```ts
-     * await player.node.reconnect(true); //true forcefully trys the reconnect
+     * await player.node.reconnect();
      * ```
      */
     private reconnect;
-    get reconnectionAttemptCount(): number;
-    /**
-     * Private Utility function to execute the reconnection
-    */
-    private executeReconnect;
     /**
      * Private function to reset the reconnection attempts
      * @returns
@@ -2800,14 +2634,6 @@ declare class LavalinkNode {
     private message;
     /** @private middleware util function for handling all kind of events from websocket */
     private handleEvent;
-    /**
-     * nodeLink specific events handling https://nodelink.js.org/docs/api/websocket#incoming-events-server--client
-     * @param eventName
-     * @param player
-     * @param track
-     * @param payload
-     */
-    private nodeLinkEventHandler;
     private getTrackOfPayload;
     /** @private util function for handling trackStart event */
     private trackStart;
@@ -3238,13 +3064,6 @@ interface ManagerOptions<CustomPlayerT extends Player = Player> {
     linksBlacklist?: (RegExp | string)[];
     /** If links should be allowed or not. If set to false, it will throw an error if a link was provided. */
     linksAllowed?: boolean;
-    /** If the library should automatically check something, on default everything is enabled */
-    autoChecks?: {
-        /** Wether or not the client should check if the requested source's plugin is available on the node. */
-        pluginValidations?: boolean;
-        /** Wether or not the client should check if the requested source is available on the node */
-        sourcesValidations?: boolean;
-    };
     /** Advanced Options for the Library, which may or may not be "library breaking" */
     advancedOptions?: {
         /** Max duration for that the filter fix duration works (in ms) - default is 8mins */
@@ -3325,12 +3144,6 @@ declare class LavalinkManager<CustomPlayerT extends Player = Player> extends Eve
      * @param options
      */
     private validateOptions;
-    /**
-     * Emits a debug event to the LavalinkManager
-     * @param name name of the event
-     * @param eventData event data
-     */
-    private _emitDebugEvent;
     /**
      * Create the Lavalink Manager
      * @param options
@@ -3515,4 +3328,4 @@ declare const LavalinkPlugins: {
 /** Lavalink Sources regexes for url validations */
 declare const SourceLinksRegexes: Record<SourcesRegex, RegExp>;
 
-export { type AudioOutputs, type Awaitable, type Base64, type BaseNodeStats, type BasePlayOptions, type BotClientOptions, type CPUStats, type ChannelDeletePacket, type ChannelMixFilter, type ClientCustomSearchPlatformUtils, type ClientSearchPlatform, DebugEvents, type DeepRequired, DefaultQueueStore, DefaultSources, DestroyReasons, type DestroyReasonsType, DisconnectReasons, type DisconnectReasonsType, type DistortionFilter, type DuncteSearchPlatform, type EQBand, EQList, type Exception, type FailingAddress, type FilterData, FilterManager, type FloatNumber, type FrameStats, type GitObject, type GuildShardPayload, type IntegerNumber, type InvalidLavalinkRestRequest, type JioSaavnSearchPlatform, type KaraokeFilter, type LavaSearchFilteredResponse, type LavaSearchQuery, type LavaSearchResponse, type LavaSearchType, type LavaSrcSearchPlatform, type LavaSrcSearchPlatformBase, type LavalinkClientSearchPlatform, type LavalinkClientSearchPlatformResolve, type LavalinkFilterData, type LavalinkInfo, LavalinkManager, type LavalinkManagerEvents, LavalinkNode, type LavalinkNodeIdentifier, type LavalinkNodeOptions, type LavalinkPlayOptions, type LavalinkPlayer, type LavalinkPlayerVoice, type LavalinkPlayerVoiceOptions, type LavalinkPlugin_JioSaavn_SourceNames, type LavalinkPlugin_LavaSrc_SourceNames, LavalinkPlugins, type LavalinkSearchPlatform, type LavalinkSourceNames, type LavalinkTrack, type LavalinkTrackInfo, type LoadTypes, type LowPassFilter, type LyricsEvent, type LyricsEventType, type LyricsFoundEvent, type LyricsLine, type LyricsLineEvent, type LyricsNotFoundEvent, type LyricsResult, type ManagerOptions, type ManagerPlayerOptions, type ManagerQueueOptions, ManagerUtils, type MemoryStats, MiniMap, type MiniMapConstructor, type ModifyRequest, type NodeLinkConnectionMetrics, NodeManager, type NodeManagerEvents, type NodeMessage, type NodeStats, NodeSymbol, type Opaque, type PlayOptions, Player, type PlayerEvent, type PlayerEventType, type PlayerEvents, type PlayerFilters, type PlayerJson, type PlayerOptions, type PlayerUpdateInfo, type PlaylistInfo, type PluginInfo, type PluginObject, Queue, type QueueChangesWatcher, QueueSaver, type QueueStoreManager, QueueSymbol, ReconnectionState, type RepeatMode, type RequiredManagerOptions, type RotationFilter, type RoutePlanner, type RoutePlannerTypes, type SearchPlatform, type SearchQuery, type SearchResult, type Session, type Severity, SourceLinksRegexes, type SourceNames, type SourcesRegex, type SponsorBlockChapterStarted, type SponsorBlockChaptersLoaded, type SponsorBlockSegment, type SponsorBlockSegmentEventType, type SponsorBlockSegmentEvents, type SponsorBlockSegmentSkipped, type SponsorBlockSegmentsLoaded, type State, type StoredQueue, type TimescaleFilter, type Track, type TrackEndEvent, type TrackEndReason, type TrackExceptionEvent, type TrackInfo, type TrackStartEvent, type TrackStuckEvent, TrackSymbol, type TremoloFilter, type UnresolvedQuery, type UnresolvedSearchResult, type UnresolvedTrack, type UnresolvedTrackInfo, UnresolvedTrackSymbol, type VersionObject, type VibratoFilter, type VoicePacket, type VoiceServer, type VoiceState, type WebSocketClosedEvent, type anyObject, audioOutputsData, parseLavalinkConnUrl, queueTrackEnd, safeStringify, validSponsorBlocks };
+export { type AudioOutputs, type Awaitable, type Base64, type BaseNodeStats, type BasePlayOptions, type BotClientOptions, type CPUStats, type ChannelDeletePacket, type ChannelMixFilter, type ClientCustomSearchPlatformUtils, type ClientSearchPlatform, DebugEvents, type DeepRequired, DefaultQueueStore, DefaultSources, DestroyReasons, type DestroyReasonsType, DisconnectReasons, type DisconnectReasonsType, type DistortionFilter, type DuncteSearchPlatform, type EQBand, EQList, type Exception, type FailingAddress, type FilterData, FilterManager, type FloatNumber, type FrameStats, type GitObject, type GuildShardPayload, type IntegerNumber, type InvalidLavalinkRestRequest, type JioSaavnSearchPlatform, type KaraokeFilter, type LavaSearchFilteredResponse, type LavaSearchQuery, type LavaSearchResponse, type LavaSearchType, type LavaSrcSearchPlatform, type LavaSrcSearchPlatformBase, type LavalinkClientSearchPlatform, type LavalinkClientSearchPlatformResolve, type LavalinkFilterData, type LavalinkInfo, LavalinkManager, type LavalinkManagerEvents, LavalinkNode, type LavalinkNodeIdentifier, type LavalinkNodeOptions, type LavalinkPlayOptions, type LavalinkPlayer, type LavalinkPlayerVoice, type LavalinkPlayerVoiceOptions, type LavalinkPlugin_JioSaavn_SourceNames, type LavalinkPlugin_LavaSrc_SourceNames, LavalinkPlugins, type LavalinkSearchPlatform, type LavalinkSourceNames, type LavalinkTrack, type LavalinkTrackInfo, type LoadTypes, type LowPassFilter, type LyricsEvent, type LyricsEventType, type LyricsFoundEvent, type LyricsLine, type LyricsLineEvent, type LyricsNotFoundEvent, type LyricsResult, type ManagerOptions, type ManagerPlayerOptions, type ManagerQueueOptions, ManagerUtils, type MemoryStats, MiniMap, type MiniMapConstructor, type ModifyRequest, NodeManager, type NodeManagerEvents, type NodeMessage, type NodeStats, NodeSymbol, type Opaque, type PlayOptions, Player, type PlayerEvent, type PlayerEventType, type PlayerEvents, type PlayerFilters, type PlayerJson, type PlayerOptions, type PlayerUpdateInfo, type PlaylistInfo, type PluginInfo, type PluginObject, Queue, type QueueChangesWatcher, QueueSaver, type QueueStoreManager, QueueSymbol, ReconnectionState, type RepeatMode, type RequiredManagerOptions, type RotationFilter, type RoutePlanner, type RoutePlannerTypes, type SearchPlatform, type SearchQuery, type SearchResult, type Session, type Severity, SourceLinksRegexes, type SourceNames, type SourcesRegex, type SponsorBlockChapterStarted, type SponsorBlockChaptersLoaded, type SponsorBlockSegment, type SponsorBlockSegmentEventType, type SponsorBlockSegmentEvents, type SponsorBlockSegmentSkipped, type SponsorBlockSegmentsLoaded, type State, type StoredQueue, type TimescaleFilter, type Track, type TrackEndEvent, type TrackEndReason, type TrackExceptionEvent, type TrackInfo, type TrackStartEvent, type TrackStuckEvent, TrackSymbol, type TremoloFilter, type UnresolvedQuery, type UnresolvedSearchResult, type UnresolvedTrack, type UnresolvedTrackInfo, UnresolvedTrackSymbol, type VersionObject, type VibratoFilter, type VoicePacket, type VoiceServer, type VoiceState, type WebSocketClosedEvent, type anyObject, audioOutputsData, parseLavalinkConnUrl, queueTrackEnd, safeStringify, validSponsorBlocks };
diff --git a/node_modules/lavalink-client/dist/index.d.ts b/node_modules/lavalink-client/dist/index.d.ts
index 7e40972..8d31168 100644
--- a/node_modules/lavalink-client/dist/index.d.ts
+++ b/node_modules/lavalink-client/dist/index.d.ts
@@ -1,5 +1,297 @@
 import { EventEmitter } from 'events';
 
+/** The Audio Outputs type */
+type AudioOutputs = "mono" | "stereo" | "left" | "right";
+/** The "active" / "disabled" Player Filters */
+interface PlayerFilters {
+    /** Sets nightcore to false, and vaporwave to false */
+    custom: boolean;
+    /** Sets custom to false, and vaporwave to false */
+    nightcore: boolean;
+    /** Sets custom to false, and nightcore to false */
+    vaporwave: boolean;
+    /** If rotation filter is enabled / not */
+    rotation: boolean;
+    /** if karaoke filter is enabled / not */
+    karaoke: boolean;
+    /** if tremolo filter is enabled / not */
+    tremolo: boolean;
+    /** if vibrato filter is enabled / not */
+    vibrato: boolean;
+    lowPass: boolean;
+    /** audio Output (default stereo, mono sounds the fullest and best for not-stereo tracks) */
+    audioOutput: AudioOutputs;
+    /** Lavalink Volume FILTER (not player Volume, think of it as a gain booster) */
+    volume: boolean;
+    /** Filters for the Lavalink Filter Plugin */
+    lavalinkFilterPlugin: {
+        /** if echo filter is enabled / not */
+        echo: boolean;
+        /** if reverb filter is enabled / not */
+        reverb: boolean;
+    };
+    lavalinkLavaDspxPlugin: {
+        /** if lowPass filter is enabled / not */
+        lowPass: boolean;
+        /** if highPass filter is enabled / not */
+        highPass: boolean;
+        /** if normalization filter is enabled / not */
+        normalization: boolean;
+        /** if echo filter is enabled / not */
+        echo: boolean;
+    };
+}
+/**
+ * There are 15 bands (0-14) that can be changed.
+ * "gain" is the multiplier for the given band.
+ * The default value is 0.
+ *  Valid values range from -0.25 to 1.0, where -0.25 means the given band is completely muted, and 0.25 means it is doubled.
+ * Modifying the gain could also change the volume of the output.
+ */
+interface EQBand {
+    /** On what band position (0-14) it should work */
+    band: IntegerNumber | number;
+    /** The gain (-0.25 to 1.0) */
+    gain: FloatNumber | number;
+}
+/**
+ * Uses equalization to eliminate part of a band, usually targeting vocals.
+ */
+interface KaraokeFilter {
+    /** The level (0 to 1.0 where 0.0 is no effect and 1.0 is full effect) */
+    level?: number;
+    /** The mono level (0 to 1.0 where 0.0 is no effect and 1.0 is full effect) */
+    monoLevel?: number;
+    /** The filter band (in Hz) */
+    filterBand?: number;
+    /**	The filter width */
+    filterWidth?: number;
+}
+/**
+ * Changes the speed, pitch, and rate
+ */
+interface TimescaleFilter {
+    /** The playback speed 0.0 ≤ x */
+    speed?: number;
+    /** The pitch 0.0 ≤ x */
+    pitch?: number;
+    /** The rate 0.0 ≤ x */
+    rate?: number;
+}
+/**
+ * Uses amplification to create a shuddering effect, where the volume quickly oscillates.
+ * Demo: https://en.wikipedia.org/wiki/File:Fuse_Electronics_Tremolo_MK-III_Quick_Demo.ogv
+ */
+interface TremoloFilter {
+    /** The frequency 0.0 < x */
+    frequency?: number;
+    /** The tremolo depth 0.0 < x ≤ 1.0 */
+    depth?: number;
+}
+/**
+ * Similar to tremolo. While tremolo oscillates the volume, vibrato oscillates the pitch.
+ */
+interface VibratoFilter {
+    /** The frequency 0.0 < x ≤ 14.0 */
+    frequency?: number;
+    /** The vibrato depth 0.0 < x ≤ 1.0 */
+    depth?: number;
+}
+/**
+ * Rotates the sound around the stereo channels/user headphones (aka Audio Panning).
+ * It can produce an effect similar to https://youtu.be/QB9EB8mTKcc (without the reverb).
+ */
+interface RotationFilter {
+    /** The frequency of the audio rotating around the listener in Hz. 0.2 is similar to the example video above */
+    rotationHz?: number;
+}
+/**
+ * Distortion effect. It can generate some pretty unique audio effects.
+ */
+interface DistortionFilter {
+    sinOffset?: number;
+    sinScale?: number;
+    cosOffset?: number;
+    cosScale?: number;
+    tanOffset?: number;
+    tanScale?: number;
+    offset?: number;
+    scale?: number;
+}
+/**
+ * Mixes both channels (left and right), with a configurable factor on how much each channel affects the other.
+ * With the defaults, both channels are kept independent of each other.
+ * Setting all factors to 0.5 means both channels get the same audio.
+ */
+interface ChannelMixFilter {
+    /** The left to left channel mix factor (0.0 ≤ x ≤ 1.0) */
+    leftToLeft?: number;
+    /** The left to right channel mix factor (0.0 ≤ x ≤ 1.0) */
+    leftToRight?: number;
+    /** The right to left channel mix factor (0.0 ≤ x ≤ 1.0) */
+    rightToLeft?: number;
+    /** The right to right channel mix factor (0.0 ≤ x ≤ 1.0) */
+    rightToRight?: number;
+}
+/**
+ * Higher frequencies get suppressed, while lower frequencies pass through this filter, thus the name low pass.
+ * Any smoothing values equal to or less than 1.0 will disable the filter.
+ */
+interface LowPassFilter {
+    /** The smoothing factor (1.0 < x) */
+    smoothing?: number;
+}
+/**
+ * Filter Data stored in the Client and partially sent to Lavalink
+ */
+interface FilterData {
+    volume?: number;
+    karaoke?: KaraokeFilter;
+    timescale?: TimescaleFilter;
+    tremolo?: TremoloFilter;
+    vibrato?: VibratoFilter;
+    rotation?: RotationFilter;
+    distortion?: DistortionFilter;
+    channelMix?: ChannelMixFilter;
+    lowPass?: LowPassFilter;
+    pluginFilters?: {
+        "lavalink-filter-plugin"?: {
+            "echo"?: {
+                delay?: number;
+                decay?: number;
+            };
+            "reverb"?: {
+                delays?: number[];
+                gains?: number[];
+            };
+        };
+        "high-pass"?: {
+            cutoffFrequency?: number;
+            boostFactor?: number;
+        };
+        "low-pass"?: {
+            cutoffFrequency?: number;
+            boostFactor?: number;
+        };
+        normalization?: {
+            maxAmplitude?: number;
+            adaptive?: boolean;
+        };
+        echo?: {
+            echoLength?: number;
+            decay?: number;
+        };
+    };
+}
+/**
+ * Actual Filter Data sent to Lavalink
+ */
+interface LavalinkFilterData extends FilterData {
+    equalizer?: EQBand[];
+}
+
+/**
+ * Debug events for more detailed logging
+ */
+declare enum DebugEvents {
+    SetSponsorBlock = "SetSponsorBlock",
+    DeleteSponsorBlock = "DeleteSponsorBlock",
+    TrackEndReplaced = "TrackEndReplaced",
+    AutoplayExecution = "AutoplayExecution",
+    AutoplayNoSongsAdded = "AutoplayNoSongsAdded",
+    AutoplayThresholdSpamLimiter = "AutoplayThresholdSpamLimiter",
+    TriggerQueueEmptyInterval = "TriggerQueueEmptyInterval",
+    QueueEnded = "QueueEnded",
+    TrackStartNewSongsOnly = "TrackStartNewSongsOnly",
+    TrackStartNoTrack = "TrackStartNoTrack",
+    ResumingFetchingError = "ResumingFetchingError",
+    PlayerUpdateNoPlayer = "PlayerUpdateNoPlayer",
+    PlayerUpdateFilterFixApply = "PlayerUpdateFilterFixApply",
+    PlayerUpdateSuccess = "PlayerUpdateSuccess",
+    HeartBeatTriggered = "HeartBeatTriggered",
+    NoSocketOnDestroy = "NoSocketOnDestroy",
+    SocketCleanupError = "SocketCleanupError",
+    SocketTerminateHeartBeatTimeout = "SocketTerminateHeartBeatTimeout",
+    TryingConnectWhileConnected = "TryingConnectWhileConnected",
+    LavaSearchNothingFound = "LavaSearchNothingFound",
+    SearchNothingFound = "SearchNothingFound",
+    ValidatingBlacklistLinks = "ValidatingBlacklistLinks",
+    ValidatingWhitelistLinks = "ValidatingWhitelistLinks",
+    TrackErrorMaxTracksErroredPerTime = "TrackErrorMaxTracksErroredPerTime",
+    TrackStuckMaxTracksErroredPerTime = "TrackStuckMaxTracksErroredPerTime",
+    PlayerDestroyingSomewhereElse = "PlayerDestroyingSomewhereElse",
+    PlayerCreateNodeNotFound = "PlayerCreateNodeNotFound",
+    PlayerPlayQueueEmptyTimeoutClear = "PlayerPlayQueueEmptyTimeoutClear",
+    PlayerPlayWithTrackReplace = "PlayerPlayWithTrackReplace",
+    PlayerPlayUnresolvedTrack = "PlayerPlayUnresolvedTrack",
+    PlayerPlayUnresolvedTrackFailed = "PlayerPlayUnresolvedTrackFailed",
+    PlayerVolumeAsFilter = "PlayerVolumeAsFilter",
+    BandcampSearchLokalEngine = "BandcampSearchLokalEngine",
+    PlayerChangeNode = "PlayerChangeNode",
+    BuildTrackError = "BuildTrackError",
+    TransformRequesterFunctionFailed = "TransformRequesterFunctionFailed",
+    GetClosestTrackFailed = "GetClosestTrackFailed",
+    PlayerDeleteInsteadOfDestroy = "PlayerDeleteInsteadOfDestroy",
+    FailedToConnectToNodes = "FailedToConnectToNodes",
+    NoAudioDebug = "NoAudioDebug",
+    PlayerAutoReconnect = "PlayerAutoReconnect"
+}
+/**
+ * Reasons why a player got destroyed
+ */
+declare enum DestroyReasons {
+    QueueEmpty = "QueueEmpty",
+    NodeDestroy = "NodeDestroy",
+    NodeDeleted = "NodeDeleted",
+    LavalinkNoVoice = "LavalinkNoVoice",
+    NodeReconnectFail = "NodeReconnectFail",
+    Disconnected = "Disconnected",
+    PlayerReconnectFail = "PlayerReconnectFail",
+    PlayerChangeNodeFail = "PlayerChangeNodeFail",
+    PlayerChangeNodeFailNoEligibleNode = "PlayerChangeNodeFailNoEligibleNode",
+    ChannelDeleted = "ChannelDeleted",
+    DisconnectAllNodes = "DisconnectAllNodes",
+    ReconnectAllNodes = "ReconnectAllNodes",
+    TrackErrorMaxTracksErroredPerTime = "TrackErrorMaxTracksErroredPerTime",
+    TrackStuckMaxTracksErroredPerTime = "TrackStuckMaxTracksErroredPerTime"
+}
+/**
+ *  Reasons why a player got disconnected
+ */
+declare enum DisconnectReasons {
+    Disconnected = "Disconnected",
+    DisconnectAllNodes = "DisconnectAllNodes"
+}
+/** The valid SponsorBlock categories */
+declare const validSponsorBlocks: string[];
+/**  The audio Outputs Data map declaration */
+declare const audioOutputsData: Record<AudioOutputs, ChannelMixFilter>;
+/**  Equalizer Presets */
+declare const EQList: {
+    /** A Bassboost Equalizer, so high it distorts the audio */
+    BassboostEarrape: EQBand[];
+    /** A High and decent Bassboost Equalizer */
+    BassboostHigh: EQBand[];
+    /** A decent Bassboost Equalizer */
+    BassboostMedium: EQBand[];
+    /** A slight Bassboost Equalizer */
+    BassboostLow: EQBand[];
+    /** Makes the Music slightly "better" */
+    BetterMusic: EQBand[];
+    /** Makes the Music sound like rock music / sound rock music better */
+    Rock: EQBand[];
+    /** Makes the Music sound like Classic music / sound Classic music better */
+    Classic: EQBand[];
+    /** Makes the Music sound like Pop music / sound Pop music better */
+    Pop: EQBand[];
+    /** Makes the Music sound like Electronic music / sound Electronic music better */
+    Electronic: EQBand[];
+    /** Boosts all Bands slightly for louder and fuller sound */
+    FullSound: EQBand[];
+    /** Boosts basses + lower highs for a pro gaming sound */
+    Gaming: EQBand[];
+};
+
 declare class FilterManager {
     static EQList: {
         BassboostEarrape: EQBand[];
@@ -24,15 +316,6 @@ declare class FilterManager {
     data: FilterData;
     /** The Player assigned to this Filter Manager */
     player: Player;
-    private get _LManager();
-    /**
-     * Returns wether the plugin validations are enabled or not
-     */
-    private get _checkForPlugins();
-    /**
-     * Returns wether the source validations are enabled or not
-     */
-    private get _checkForSources();
     /** The Constructor for the FilterManager */
     constructor(player: Player);
     /**
@@ -50,8 +333,7 @@ declare class FilterManager {
      * ```
      */
     applyPlayerFilters(): Promise<void>;
-    private privateNot0;
-    private getLavalinkFilterData;
+    privateNot0(value: number | undefined): boolean;
     /**
      * Checks if the filters are correctly stated (active / not-active) - mostly used internally.
      * @param oldFilterTimescale
@@ -208,385 +490,219 @@ declare class FilterManager {
      * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
      * ```
      */
-    toggleLowPass(smoothing?: number): Promise<FilterManager>;
-    /**
-     * Lavalink LavaDspx Plugin Filters
-     */
-    lavalinkLavaDspxPlugin: {
-        /**
-         * Enables / Disables the LowPass effect, (Optional: provide your Own Data)
-         * @param {number} boostFactor set the boost factor of the filter
-         * @param {number} cutoffFrequency set the cutoff frequency of the filter
-         * @returns  {Promise<boolean>} the state of the filter after execution.
-         *
-         * @example
-         * ```ts
-         * // Toggle LowPass filter with custom settings
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleLowPass(1.2, 300);
-         * // or use the defaults
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleLowPass();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleLowPass: (boostFactor?: number, cutoffFrequency?: number) => Promise<FilterManager>;
-        /**
-         * Enables / Disables the HighPass effect, (Optional: provide your Own Data)
-         * @param {number} boostFactor [] set the boost factor of the filter
-         * @param {number} cutoffFrequency set the cutoff frequency of the filter
-         * @returns  {Promise<boolean>} the state of the filter after execution.
-         *
-         * @example
-         * ```ts
-         * // Toggle HighPass filter with custom settings
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleHighPass(1.2, 150); // custom values
-         * // or use the defaults
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleHighPass();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleHighPass: (boostFactor?: number, cutoffFrequency?: number) => Promise<FilterManager>;
-        /**
-         * Enables / Disables the Normalization effect.
-         * @param {number} [maxAmplitude=0.75] - The maximum amplitude of the audio.
-         * @param {boolean} [adaptive=true] Whether to use adaptive normalization or not.
-         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-         *
-         * @example
-         * ```ts
-         * // Toggle Normalization filter with custom settings
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleNormalization(0.9, false); // custom values
-         * // or use the defaults
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleNormalization();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleNormalization: (maxAmplitude?: number, adaptive?: boolean) => Promise<FilterManager>;
-        /**
-         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
-         * @param {number} [decay=0.5] The decay of the echo effect.
-         * @param {number} [echoLength=0.5] The length of the echo effect.
-         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-         *
-         * @example
-         * ```ts
-         * // Toggle Echo filter with custom settings
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleEcho(0.7, 0.6); // custom values
-         * // or use the defaults
-         * await player.filterManager.lavalinkLavaDspxPlugin.toggleEcho();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleEcho: (decay?: number, echoLength?: number) => Promise<FilterManager>;
-    };
-    /**
-     * LavalinkFilter Plugin specific Filters
-     */
-    lavalinkFilterPlugin: {
-        /**
-         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
-         * @param {number} delay set the delay of the echo
-         * @param {number} decay set the decay of the echo
-         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-         *
-         * @example
-         * ```ts
-         * // Toggle Echo filter with custom settings
-         * await player.filterManager.lavalinkFilterPlugin.toggleEcho(3, 0.7); // custom values
-         * // or use the defaults
-         * await player.filterManager.lavalinkFilterPlugin.toggleEcho();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleEcho: (delay?: number, decay?: number) => Promise<FilterManager>;
-        /**
-         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
-         * @param {number} delays set the delays of the reverb
-         * @param {number} gains set the gains of the reverb
-         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-         *
-         * @example
-         * ```ts
-         * // Toggle Reverb filter with custom settings
-         * await player.filterManager.lavalinkFilterPlugin.toggleReverb([0.04, 0.045, 0.05, 0.055], [0.85, 0.84, 0.83, 0.82]);
-         * // or use the defaults
-         * await player.filterManager.lavalinkFilterPlugin.toggleReverb();
-         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-         * ```
-         */
-        toggleReverb: (delays?: number[], gains?: number[]) => Promise<FilterManager>;
-    };
-    /**
-     * Enables / Disables a Nightcore-like filter Effect. Disables/Overrides both: custom and Vaporwave Filter
-     * @param {number} speed set the speed of the filter
-     * @param {number} pitch set the pitch of the filter
-     * @param {number} rate set the rate of the filter
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Toggle Nightcore filter with custom settings
-     * await player.filterManager.toggleNightcore(1.3, 1.3, 0.9);
-     * // or use the defaults
-     * await player.filterManager.toggleNightcore();
-     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-     * ```
-     */
-    toggleNightcore(speed?: number, pitch?: number, rate?: number): Promise<FilterManager>;
-    /**
-     * Enables / Disables a Vaporwave-like filter Effect. Disables/Overrides both: custom and nightcore Filter
-     * @param {number} speed set the speed of the filterq
-     * @param {number} pitch set the pitch of the filter
-     * @param {number} rate set the rate of the filter
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Toggle Vaporwave filter with custom settings
-     * await player.filterManager.toggleVaporwave(0.9, 0.7, 1);
-     * // or use the defaults
-     * await player.filterManager.toggleVaporwave();
-     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-     * ```
-     */
-    toggleVaporwave(speed?: number, pitch?: number, rate?: number): Promise<FilterManager>;
-    /**
-     * Enable / Disables a Karaoke like Filter Effect
-     * @param {number} level set the level of the filter
-     * @param {number} monoLevel set the mono level of the filter
-     * @param {number} filterBand set the filter band of the filter
-     * @param {number} filterWidth set the filter width of the filter
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Toggle Karaoke filter with custom settings
-     * await player.filterManager.toggleKaraoke(1.5, 1.0, 220, 100);
-     * // or use the defaults
-     * await player.filterManager.toggleKaraoke();
-     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
-     * ```
-     */
-    toggleKaraoke(level?: number, monoLevel?: number, filterBand?: number, filterWidth?: number): Promise<FilterManager>;
-    /**
-     * Function to find out if currently there is a custom timescamle etc. filter applied
-     * @returns {boolean} whether a custom filter is active
-     *
-     * @example
-     * ```ts
-     * // Check if a custom filter is active
-     * const isCustom = player.filterManager.isCustomFilterActive();
-     * console.log(`Is custom filter active? ${isCustom}`);
-     * ```
-     */
-    isCustomFilterActive(): boolean;
-    /**
-     * Sets the players equalizer bands using one of the predefined presets.
-     * @param {keyof typeof EQList} preset The preset to use.
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Set EQ preset
-     * await player.filterManager.setEQPreset('BassboostMedium');
-     * ```
-     */
-    setEQPreset(preset: keyof typeof EQList): Promise<this>;
-    /**
-     * Sets the players equalizer band on-top of the existing ones.
-     * @param {number} bands
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Set EQ bands
-     * await player.filterManager.setEQ([
-     *   { band: 0, gain: 0.3 },
-     *   { band: 1, gain: -0.2 },
-     *   { band: 2, gain: 0.1 }
-     * ]);
-     *
-     * // or use one of the templates:
-     * await player.filterManager.setEQ(player.filterManager.EQList.BassboostMedium); // you can also import EQList from somewhere package if wanted.
-     * ```
-     */
-    setEQ(bands: EQBand | EQBand[]): Promise<this>;
-    /**
-     * Clears the equalizer bands.
-     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
-     *
-     * @example
-     * ```ts
-     * // Clear all EQ bands
-     * await player.filterManager.clearEQ();
-     * ```
+    toggleLowPass(smoothing?: number): Promise<FilterManager>;
+    /**
+     * Lavalink LavaDspx Plugin Filters
      */
-    clearEQ(): Promise<this>;
-}
-
-/** Sourcenames provided by lavalink server */
-type LavalinkSourceNames = "youtube" | "youtubemusic" | "soundcloud" | "bandcamp" | "twitch";
-/** Source Names provided by lava src plugin */
-type LavalinkPlugin_LavaSrc_SourceNames = "deezer" | "spotify" | "applemusic" | "yandexmusic" | "flowery-tts" | "vkmusic" | "tidal" | "qobuz" | "pandora";
-/** Source Names provided by jiosaavan plugin */
-type LavalinkPlugin_JioSaavn_SourceNames = "jiosaavn";
-/** The SourceNames provided by lavalink */
-type SourceNames = LavalinkSourceNames | LavalinkPlugin_LavaSrc_SourceNames | LavalinkPlugin_JioSaavn_SourceNames;
-interface LavalinkTrackInfo {
-    /** The Identifier of the Track */
-    identifier: string;
-    /** The Track Title / Name */
-    title: string;
-    /** The Name of the Author */
-    author: string;
-    /** The duration of the Track */
-    length: number;
-    /** The URL of the artwork if available */
-    artworkUrl: string | null;
-    /** The URL (aka Link) of the Track called URI */
-    uri: string;
-    /** The Source name of the Track, e.g. soundcloud, youtube, spotify */
-    sourceName: SourceNames;
-    /** Wether the audio is seekable */
-    isSeekable: boolean;
-    /** Wether the audio is of a live stream */
-    isStream: boolean;
-    /** If isrc code is available, it's provided */
-    isrc: string | null;
-}
-interface TrackInfo {
-    /** The Identifier of the Track */
-    identifier: string;
-    /** The Track Title / Name */
-    title: string;
-    /** The Name of the Author */
-    author: string;
-    /** The duration of the Track */
-    duration: number;
-    /** The URL of the artwork if available */
-    artworkUrl: string | null;
-    /** The URL (aka Link) of the Track called URI */
-    uri: string;
-    /** The Source name of the Track, e.g. soundcloud, youtube, spotify */
-    sourceName: SourceNames;
-    /** Wether the audio is seekable */
-    isSeekable: boolean;
-    /** Wether the audio is of a live stream */
-    isStream: boolean;
-    /** If isrc code is available, it's provided */
-    isrc: string | null;
-}
-interface PluginInfo {
-    /** The Type provided by a plugin */
-    type?: "album" | "playlist" | "artist" | "recommendations" | string;
-    /** The Identifier provided by a plugin */
-    albumName?: string;
-    /** The url of the album */
-    albumUrl?: string;
-    /** The url of the album art */
-    albumArtUrl?: string;
-    /** The url of the artist */
-    artistUrl?: string;
-    /** The url of the artist artwork */
-    artistArtworkUrl?: string;
-    /** The url of the preview */
-    previewUrl?: string;
-    /** Whether the track is a preview */
-    isPreview?: boolean;
-    /** The total number of tracks in the playlist */
-    totalTracks?: number;
-    /** The Identifier provided by a plugin */
-    identifier?: string;
-    /** The ArtworkUrl provided by a plugin */
-    artworkUrl?: string;
-    /** The Author Information provided by a plugin */
-    author?: string;
-    /** The Url provided by a Plugin */
-    url?: string;
-    /** The Url provided by a Plugin */
-    uri?: string;
-    /** You can put specific track information here, to transform the tracks... */
-    clientData?: {
-        previousTrack?: boolean;
-        [key: string]: any;
+    lavalinkLavaDspxPlugin: {
+        /**
+         * Enables / Disables the LowPass effect, (Optional: provide your Own Data)
+         * @param {number} boostFactor set the boost factor of the filter
+         * @param {number} cutoffFrequency set the cutoff frequency of the filter
+         * @returns  {Promise<boolean>} the state of the filter after execution.
+         *
+         * @example
+         * ```ts
+         * // Toggle LowPass filter with custom settings
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleLowPass(1.2, 300);
+         * // or use the defaults
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleLowPass();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleLowPass: (boostFactor?: number, cutoffFrequency?: number) => Promise<FilterManager>;
+        /**
+         * Enables / Disables the HighPass effect, (Optional: provide your Own Data)
+         * @param {number} boostFactor [] set the boost factor of the filter
+         * @param {number} cutoffFrequency set the cutoff frequency of the filter
+         * @returns  {Promise<boolean>} the state of the filter after execution.
+         *
+         * @example
+         * ```ts
+         * // Toggle HighPass filter with custom settings
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleHighPass(1.2, 150); // custom values
+         * // or use the defaults
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleHighPass();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleHighPass: (boostFactor?: number, cutoffFrequency?: number) => Promise<FilterManager>;
+        /**
+         * Enables / Disables the Normalization effect.
+         * @param {number} [maxAmplitude=0.75] - The maximum amplitude of the audio.
+         * @param {boolean} [adaptive=true] Whether to use adaptive normalization or not.
+         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+         *
+         * @example
+         * ```ts
+         * // Toggle Normalization filter with custom settings
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleNormalization(0.9, false); // custom values
+         * // or use the defaults
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleNormalization();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleNormalization: (maxAmplitude?: number, adaptive?: boolean) => Promise<FilterManager>;
+        /**
+         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
+         * @param {number} [decay=0.5] The decay of the echo effect.
+         * @param {number} [echoLength=0.5] The length of the echo effect.
+         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+         *
+         * @example
+         * ```ts
+         * // Toggle Echo filter with custom settings
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleEcho(0.7, 0.6); // custom values
+         * // or use the defaults
+         * await player.filterManager.lavalinkLavaDspxPlugin.toggleEcho();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleEcho: (decay?: number, echoLength?: number) => Promise<FilterManager>;
     };
-}
-interface LavalinkTrack {
-    /** The Base 64 encoded String */
-    encoded?: Base64;
-    /** Track Information */
-    info: LavalinkTrackInfo;
-    /** Plugin Information from Lavalink */
-    pluginInfo: Partial<PluginInfo>;
-    /** The userData Object from when you provide to the lavalink request */
-    userData?: anyObject;
-}
-interface Track {
-    /** The Base 64 encoded String */
-    encoded?: Base64;
-    /** Track Information */
-    info: TrackInfo;
-    /** Plugin Information from Lavalink */
-    pluginInfo: Partial<PluginInfo>;
-    /** The Track's Requester */
-    requester?: unknown;
-    /** The userData Object from when you provide to the lavalink request */
-    userData?: anyObject;
-}
-interface UnresolvedTrackInfo extends Partial<TrackInfo> {
-    /** Required */
-    title: string;
-}
-interface UnresolvedQuery extends UnresolvedTrackInfo {
-    /** The base64 of the unresolved track to "encode" */
-    encoded?: Base64;
-}
-interface UnresolvedTrack {
-    /** Required */
-    resolve: (player: Player) => Promise<void>;
-    /** The Base 64 encoded String */
-    encoded?: Base64;
-    /** Track Information */
-    info: UnresolvedTrackInfo;
-    /** Plugin Information from Lavalink */
-    pluginInfo: Partial<PluginInfo>;
-    /** The userData Object from when you provide to the lavalink request */
-    userData?: anyObject;
-    /** The Track's Requester */
-    requester?: unknown;
-}
-
-interface StoredQueue {
-    current: Track | null;
-    previous: Track[];
-    tracks: (Track | UnresolvedTrack)[];
-}
-interface QueueStoreManager {
-    /** @async get a Value (MUST RETURN UNPARSED!) */
-    get: (guildId: string) => Awaitable<StoredQueue | string | undefined>;
-    /** @async Set a value inside a guildId (MUST BE UNPARSED) */
-    set: (guildId: string, value: StoredQueue | string) => Awaitable<void | boolean>;
-    /** @async Delete a Database Value based of it's guildId */
-    delete: (guildId: string) => Awaitable<void | boolean>;
-    /** @async Transform the value(s) inside of the QueueStoreManager (IF YOU DON'T NEED PARSING/STRINGIFY, then just return the value) */
-    stringify: (value: StoredQueue | string) => Awaitable<StoredQueue | string>;
-    /** @async Parse the saved value back to the Queue (IF YOU DON'T NEED PARSING/STRINGIFY, then just return the value) */
-    parse: (value: StoredQueue | string) => Awaitable<Partial<StoredQueue>>;
-}
-interface ManagerQueueOptions {
-    /** Maximum Amount of tracks for the queue.previous array. Set to 0 to not save previous songs. Defaults to 25 Tracks */
-    maxPreviousTracks?: number;
-    /** Custom Queue Store option */
-    queueStore?: QueueStoreManager;
-    /** Custom Queue Watcher class */
-    queueChangesWatcher?: QueueChangesWatcher;
-}
-interface QueueChangesWatcher {
-    /** get a Value (MUST RETURN UNPARSED!) */
-    tracksAdd: (guildId: string, tracks: (Track | UnresolvedTrack)[], position: number, oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
-    /** Set a value inside a guildId (MUST BE UNPARSED) */
-    tracksRemoved: (guildId: string, tracks: (Track | UnresolvedTrack)[], position: number | number[], oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
-    /** Set a value inside a guildId (MUST BE UNPARSED) */
-    shuffled: (guildId: string, oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
+    /**
+     * LavalinkFilter Plugin specific Filters
+     */
+    lavalinkFilterPlugin: {
+        /**
+         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
+         * @param {number} delay set the delay of the echo
+         * @param {number} decay set the decay of the echo
+         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+         *
+         * @example
+         * ```ts
+         * // Toggle Echo filter with custom settings
+         * await player.filterManager.lavalinkFilterPlugin.toggleEcho(3, 0.7); // custom values
+         * // or use the defaults
+         * await player.filterManager.lavalinkFilterPlugin.toggleEcho();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleEcho: (delay?: number, decay?: number) => Promise<FilterManager>;
+        /**
+         * Enables / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
+         * @param {number} delays set the delays of the reverb
+         * @param {number} gains set the gains of the reverb
+         * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+         *
+         * @example
+         * ```ts
+         * // Toggle Reverb filter with custom settings
+         * await player.filterManager.lavalinkFilterPlugin.toggleReverb([0.04, 0.045, 0.05, 0.055], [0.85, 0.84, 0.83, 0.82]);
+         * // or use the defaults
+         * await player.filterManager.lavalinkFilterPlugin.toggleReverb();
+         * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+         * ```
+         */
+        toggleReverb: (delays?: number[], gains?: number[]) => Promise<FilterManager>;
+    };
+    /**
+     * Enables / Disables a Nightcore-like filter Effect. Disables/Overrides both: custom and Vaporwave Filter
+     * @param {number} speed set the speed of the filter
+     * @param {number} pitch set the pitch of the filter
+     * @param {number} rate set the rate of the filter
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Toggle Nightcore filter with custom settings
+     * await player.filterManager.toggleNightcore(1.3, 1.3, 0.9);
+     * // or use the defaults
+     * await player.filterManager.toggleNightcore();
+     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+     * ```
+     */
+    toggleNightcore(speed?: number, pitch?: number, rate?: number): Promise<FilterManager>;
+    /**
+     * Enables / Disables a Vaporwave-like filter Effect. Disables/Overrides both: custom and nightcore Filter
+     * @param {number} speed set the speed of the filterq
+     * @param {number} pitch set the pitch of the filter
+     * @param {number} rate set the rate of the filter
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Toggle Vaporwave filter with custom settings
+     * await player.filterManager.toggleVaporwave(0.9, 0.7, 1);
+     * // or use the defaults
+     * await player.filterManager.toggleVaporwave();
+     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+     * ```
+     */
+    toggleVaporwave(speed?: number, pitch?: number, rate?: number): Promise<FilterManager>;
+    /**
+     * Enable / Disables a Karaoke like Filter Effect
+     * @param {number} level set the level of the filter
+     * @param {number} monoLevel set the mono level of the filter
+     * @param {number} filterBand set the filter band of the filter
+     * @param {number} filterWidth set the filter width of the filter
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Toggle Karaoke filter with custom settings
+     * await player.filterManager.toggleKaraoke(1.5, 1.0, 220, 100);
+     * // or use the defaults
+     * await player.filterManager.toggleKaraoke();
+     * // when it's enabled before calling the toggle function, it disables it, so you might need to do some if/else logic.
+     * ```
+     */
+    toggleKaraoke(level?: number, monoLevel?: number, filterBand?: number, filterWidth?: number): Promise<FilterManager>;
+    /**
+     * Function to find out if currently there is a custom timescamle etc. filter applied
+     * @returns {boolean} whether a custom filter is active
+     *
+     * @example
+     * ```ts
+     * // Check if a custom filter is active
+     * const isCustom = player.filterManager.isCustomFilterActive();
+     * console.log(`Is custom filter active? ${isCustom}`);
+     * ```
+     */
+    isCustomFilterActive(): boolean;
+    /**
+     * Sets the players equalizer bands using one of the predefined presets.
+     * @param {keyof typeof EQList} preset The preset to use.
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Set EQ preset
+     * await player.filterManager.setEQPreset('BassboostMedium');
+     * ```
+     */
+    setEQPreset(preset: keyof typeof EQList): Promise<this>;
+    /**
+     * Sets the players equalizer band on-top of the existing ones.
+     * @param {number} bands
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Set EQ bands
+     * await player.filterManager.setEQ([
+     *   { band: 0, gain: 0.3 },
+     *   { band: 1, gain: -0.2 },
+     *   { band: 2, gain: 0.1 }
+     * ]);
+     *
+     * // or use one of the templates:
+     * await player.filterManager.setEQ(player.filterManager.EQList.BassboostMedium); // you can also import EQList from somewhere package if wanted.
+     * ```
+     */
+    setEQ(bands: EQBand | EQBand[]): Promise<this>;
+    /**
+     * Clears the equalizer bands.
+     * @returns {Promise<FilterManager>} The Filter Manager, for chaining.
+     *
+     * @example
+     * ```ts
+     * // Clear all EQ bands
+     * await player.filterManager.clearEQ();
+     * ```
+     */
+    clearEQ(): Promise<this>;
 }
 
 declare class QueueSaver {
@@ -829,12 +945,6 @@ declare class Player {
     };
     /** Custom data for the player */
     private readonly data;
-    /**
-     * Emits a debug event to the LavalinkManager
-     * @param name name of the event
-     * @param eventData event data
-     */
-    private _emitDebugEvent;
     /**
      * Create a new Player
      * @param options
@@ -998,1318 +1108,1082 @@ declare class Player {
      */
     changeNode(newNode: LavalinkNode | string, checkSources?: boolean): Promise<string>;
     /**
-     * (Wrapper-FN for changeNode) Move the player to a different node. If no node is provided, it will find the least used node that is not the same as the current node.
+     * Move the player to a different node. If no node is provided, it will find the least used node that is not the same as the current node.
      * @param node the id of the node to move to
      * @returns the player
-     * @throws RangeError if there is no available nodes.
-     * @throws Error if the node to move to is the same as the current node.
-     * @example
-     * ```ts
-     * const newNodeMovedTo = await player.moveNode(); // no need to specify the new node, it will find a least used node automatically, but you can ofc. use a custom node id.
-     * ```
-     */
-    moveNode(node?: string): Promise<string | this>;
-    /** Converts the Player including Queue to a Json state */
-    toJSON(): PlayerJson;
-}
-
-declare const TrackSymbol: unique symbol;
-declare const UnresolvedTrackSymbol: unique symbol;
-declare const QueueSymbol: unique symbol;
-declare const NodeSymbol: unique symbol;
-/**
- * Parses Node Connection Url: "lavalink://<nodeId>:<nodeAuthorization(Password)>@<NodeHost>:<NodePort>"
- * @param connectionUrl
- * @returns
- */
-declare function parseLavalinkConnUrl(connectionUrl: string): {
-    authorization: string;
-    id: string;
-    host: string;
-    port: number;
-};
-declare class ManagerUtils {
-    LavalinkManager: LavalinkManager | undefined;
-    constructor(LavalinkManager?: LavalinkManager);
-    buildPluginInfo(data: any, clientData?: any): any;
-    buildTrack(data: LavalinkTrack | Track, requester: unknown): Track;
-    /**
-     * Builds a UnresolvedTrack to be resolved before being played  .
-     * @param query
-     * @param requester
-     */
-    buildUnresolvedTrack(query: UnresolvedQuery | UnresolvedTrack, requester: unknown): UnresolvedTrack;
-    /**
-     * Validate if a data is equal to a node
-     * @param data
-     */
-    isNode(data: LavalinkNode): boolean;
-    getTransformedRequester(requester: unknown): unknown;
-    /**
-     * Validate if a data is equal to node options
-     * @param data
-     */
-    isNodeOptions(data: LavalinkNodeOptions): boolean;
-    /**
-     * Validate tracks based on duration wether they are playble or broken tracks.
-     * most tracks should be longer than 30s, so you can put a minDuration of 29e3 (cause preview tracks are exactly 30s) or put 0.
-     * This check is not done automatically, you need to check it yourself by doing:
-     * @example
-     * ```ts
-     * const res = await player.search("Adele");
-     *
-     * // short hand:
-     * const validTracks = res.tracks.filter(client.lavalink.utils.isNotBrokenTrack)
-     * // or with options:
-     * const validTracks = res.tracks.filter(t => client.lavalink.utils.isNotBrokenTrack(t, 29e3));
-     *
-     * // then you can add it to the queue.
-     * await player.queue.add(validTracks);
-     * ```
-     */
-    isNotBrokenTrack(data: Track | UnresolvedTrack, minDuration?: number): data is Track;
-    /**
-     * Validate if a data is equal to a track
-     * @param data the Track to validate
-     * @returns
-     */
-    isTrack(data: Track | UnresolvedTrack): data is Track;
-    /**
-     * Checks if the provided argument is a valid UnresolvedTrack.
-     * @param track
-     */
-    isUnresolvedTrack(data: UnresolvedTrack | Track): data is UnresolvedTrack;
-    /**
-     * Checks if the provided argument is a valid UnresolvedTrack.
-     * @param track
-     */
-    isUnresolvedTrackQuery(data: UnresolvedQuery): boolean;
-    getClosestTrack(data: UnresolvedTrack, player: Player): Promise<Track | undefined>;
-    validateQueryString(node: LavalinkNode, queryString: string, sourceString?: LavalinkSearchPlatform): void;
-    transformQuery(query: SearchQuery): {
-        query: string;
-        extraQueryUrlParams: URLSearchParams;
-        source: any;
-    };
-    transformLavaSearchQuery(query: LavaSearchQuery): {
-        query: string;
-        types: string[];
-        source: any;
-    };
-    validateSourceString(node: LavalinkNode, sourceString: SearchPlatform): void;
-}
-/**
- * Separate interface for the constructor so that emitted js does not have a constructor that overwrites itself
- *
- * @internal
- */
-interface MiniMap<K, V> extends Map<K, V> {
-    constructor: MiniMapConstructor;
-}
-declare class MiniMap<K, V> extends Map<K, V> {
-    constructor(data?: [K, V][]);
-    /**
-     * Identical to
-     * [Array.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
-     * but returns a MiniMap instead of an Array.
-     *
-     * @param fn The function to test with (should return boolean)
-     * @param thisArg Value to use as `this` when executing function
-     *
-     * @example
-     * miniMap.filter(user => user.username === 'Bob');
-     */
-    filter<K2 extends K>(fn: (value: V, key: K, miniMap: this) => key is K2): MiniMap<K2, V>;
-    filter<V2 extends V>(fn: (value: V, key: K, miniMap: this) => value is V2): MiniMap<K, V2>;
-    filter(fn: (value: V, key: K, miniMap: this) => boolean): MiniMap<K, V>;
-    filter<This, K2 extends K>(fn: (this: This, value: V, key: K, miniMap: this) => key is K2, thisArg: This): MiniMap<K2, V>;
-    filter<This, V2 extends V>(fn: (this: This, value: V, key: K, miniMap: this) => value is V2, thisArg: This): MiniMap<K, V2>;
-    filter<This>(fn: (this: This, value: V, key: K, miniMap: this) => boolean, thisArg: This): MiniMap<K, V>;
-    toJSON(): [K, V][];
-    /**
-     * Maps each item to another value into an array. Identical in behavior to
-     * [Array.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).
-     *
-     * @param fn Function that produces an element of the new array, taking three arguments
-     * @param thisArg Value to use as `this` when executing function
-     *
-     * @example
-     * miniMap.map(user => user.tag);
+     * @throws RangeError if there is no available nodes.
+     * @throws Error if the node to move to is the same as the current node.
      */
-    map<T>(fn: (value: V, key: K, miniMap: this) => T): T[];
-    map<This, T>(fn: (this: This, value: V, key: K, miniMap: this) => T, thisArg: This): T[];
+    moveNode(node?: string): Promise<string | this>;
+    /** Converts the Player including Queue to a Json state */
+    toJSON(): PlayerJson;
 }
-declare function queueTrackEnd(player: Player, dontShiftQueue?: boolean): Promise<Track>;
-declare function safeStringify(obj: any, padding?: number): string;
 
-/** Helper for generating Opaque types. */
-type Opaque<T, K> = T & {
-    __opaque__: K;
-};
-/** Opqaue tyep for integernumber */
-type IntegerNumber = Opaque<number, 'Int'>;
-/** Opqaue tyep for floatnumber */
-type FloatNumber = Opaque<number, 'Float'>;
-type LavaSrcSearchPlatformBase = "spsearch" | "sprec" | "amsearch" | "dzsearch" | "dzisrc" | "dzrec" | "ymsearch" | "ymrec" | "vksearch" | "vkrec" | "tdsearch" | "tdrec" | "qbsearch" | "qbisrc" | "qbrec" | "pdsearch" | "pdisrc" | "pdrec";
-type LavaSrcSearchPlatform = LavaSrcSearchPlatformBase | "ftts";
-type JioSaavnSearchPlatform = "jssearch" | "jsrec";
-type DuncteSearchPlatform = "speak" | "phsearch" | "pornhub" | "porn" | "tts";
-type LavalinkClientSearchPlatform = "bcsearch";
-type LavalinkClientSearchPlatformResolve = "bandcamp" | "bc";
-type LavalinkSearchPlatform = "ytsearch" | "ytmsearch" | "scsearch" | "bcsearch" | LavaSrcSearchPlatform | DuncteSearchPlatform | JioSaavnSearchPlatform | LavalinkClientSearchPlatform;
-type ClientCustomSearchPlatformUtils = "local" | "http" | "https" | "link" | "uri";
-type ClientSearchPlatform = ClientCustomSearchPlatformUtils | // for file/link requests
-"youtube" | "yt" | "youtube music" | "youtubemusic" | "ytm" | "musicyoutube" | "music youtube" | "soundcloud" | "sc" | "am" | "apple music" | "applemusic" | "apple" | "musicapple" | "music apple" | "sp" | "spsuggestion" | "spotify" | "spotify.com" | "spotifycom" | "dz" | "deezer" | "yandex" | "yandex music" | "yandexmusic" | "vk" | "vk music" | "vkmusic" | "tidal" | "tidal music" | "qobuz" | "pandora" | "pd" | "pandora music" | "pandoramusic" | "flowerytts" | "flowery" | "flowery.tts" | LavalinkClientSearchPlatformResolve | LavalinkClientSearchPlatform | "js" | "jiosaavn" | "td" | "tidal" | "tdrec";
-type SearchPlatform = LavalinkSearchPlatform | ClientSearchPlatform;
-type SourcesRegex = "YoutubeRegex" | "YoutubeMusicRegex" | "SoundCloudRegex" | "SoundCloudMobileRegex" | "DeezerTrackRegex" | "DeezerArtistRegex" | "DeezerEpisodeRegex" | "DeezerMixesRegex" | "DeezerPageLinkRegex" | "DeezerPlaylistRegex" | "DeezerAlbumRegex" | "AllDeezerRegex" | "AllDeezerRegexWithoutPageLink" | "SpotifySongRegex" | "SpotifyPlaylistRegex" | "SpotifyArtistRegex" | "SpotifyEpisodeRegex" | "SpotifyShowRegex" | "SpotifyAlbumRegex" | "AllSpotifyRegex" | "mp3Url" | "m3uUrl" | "m3u8Url" | "mp4Url" | "m4aUrl" | "wavUrl" | "aacpUrl" | "tiktok" | "mixcloud" | "musicYandex" | "radiohost" | "bandcamp" | "jiosaavn" | "appleMusic" | "tidal" | "PandoraTrackRegex" | "PandoraAlbumRegex" | "PandoraArtistRegex" | "PandoraPlaylistRegex" | "AllPandoraRegex" | "TwitchTv" | "vimeo";
-interface PlaylistInfo {
-    /** The playlist name */
-    name: string;
-    /** The playlist title (same as name) */
-    title: string;
-    /** The playlist Author */
-    author?: string;
-    /** The playlist Thumbnail */
-    thumbnail?: string;
-    /** A Uri to the playlist */
-    uri?: string;
-    /** The playlist selected track. */
-    selectedTrack: Track | null;
-    /** The duration of the entire playlist. (calcualted) */
-    duration: number;
-}
-interface SearchResult {
-    loadType: LoadTypes;
-    exception: Exception | null;
-    pluginInfo: PluginInfo;
-    playlist: PlaylistInfo | null;
-    tracks: Track[];
-}
-interface UnresolvedSearchResult {
-    loadType: LoadTypes;
-    exception: Exception | null;
-    pluginInfo: PluginInfo;
-    playlist: PlaylistInfo | null;
-    tracks: UnresolvedTrack[];
-}
-/**
- * @internal
- */
-interface MiniMapConstructor {
-    new (): MiniMap<unknown, unknown>;
-    new <K, V>(entries?: ReadonlyArray<readonly [K, V]> | null): MiniMap<K, V>;
-    new <K, V>(iterable: Iterable<readonly [K, V]>): MiniMap<K, V>;
-    readonly prototype: MiniMap<unknown, unknown>;
-    readonly [Symbol.species]: MiniMapConstructor;
-}
-type PlayerEvents = TrackStartEvent | TrackEndEvent | TrackStuckEvent | TrackExceptionEvent | WebSocketClosedEvent | SponsorBlockSegmentEvents | LyricsEvent;
-type Severity = "COMMON" | "SUSPICIOUS" | "FAULT";
-interface Exception {
-    /** Severity of the error */
-    severity: Severity;
-    /** Nodejs Error */
-    error?: Error;
-    /** Message by lavalink */
-    message: string;
-    /** Cause by lavalink */
-    cause: string;
-    /** causeStackTrace by lavalink */
-    causeStackTrace: string;
-}
-interface PlayerEvent {
-    op: "event";
-    type: PlayerEventType;
-    guildId: string;
-}
-interface TrackStartEvent extends PlayerEvent {
-    type: "TrackStartEvent";
-    track: LavalinkTrack;
-}
-interface TrackEndEvent extends PlayerEvent {
-    type: "TrackEndEvent";
-    track: LavalinkTrack;
-    reason: TrackEndReason;
-}
-interface TrackExceptionEvent extends PlayerEvent {
-    type: "TrackExceptionEvent";
-    exception?: Exception;
-    track: LavalinkTrack;
-    error: string;
-}
-interface TrackStuckEvent extends PlayerEvent {
-    type: "TrackStuckEvent";
-    thresholdMs: number;
-    track: LavalinkTrack;
-}
-interface WebSocketClosedEvent extends PlayerEvent {
-    type: "WebSocketClosedEvent";
-    code: number;
-    byRemote: boolean;
-    reason: string;
-}
-/**
- * Types & Events for Sponsorblock-plugin from Lavalink: https://github.com/topi314/Sponsorblock-Plugin#segmentsloaded
- */
-type SponsorBlockSegmentEvents = SponsorBlockSegmentSkipped | SponsorBlockSegmentsLoaded | SponsorBlockChapterStarted | SponsorBlockChaptersLoaded;
-type SponsorBlockSegmentEventType = "SegmentSkipped" | "SegmentsLoaded" | "ChaptersLoaded" | "ChapterStarted";
-interface SponsorBlockSegmentsLoaded extends PlayerEvent {
-    type: "SegmentsLoaded";
-    segments: {
-        category: string;
-        start: number;
-        end: number;
-    }[];
-}
-interface SponsorBlockSegmentSkipped extends PlayerEvent {
-    type: "SegmentSkipped";
-    segment: {
-        category: string;
-        start: number;
-        end: number;
-    };
-}
-interface SponsorBlockChapterStarted extends PlayerEvent {
-    type: "ChapterStarted";
-    /** The Chapter which started */
-    chapter: {
-        /** The Name of the Chapter */
-        name: string;
-        start: number;
-        end: number;
-        duration: number;
-    };
-}
-interface SponsorBlockChaptersLoaded extends PlayerEvent {
-    type: "ChaptersLoaded";
-    /** All Chapters loaded */
-    chapters: {
-        /** The Name of the Chapter */
-        name: string;
-        start: number;
-        end: number;
-        duration: number;
-    }[];
-}
-/**
- * Types & Events for Lyrics plugin from Lavalink: https://github.com/topi314/LavaLyrics
- */
-type LyricsEvent = LyricsFoundEvent | LyricsNotFoundEvent | LyricsLineEvent;
-type LyricsEventType = "LyricsFoundEvent" | "LyricsNotFoundEvent" | "LyricsLineEvent";
-interface LyricsFoundEvent extends PlayerEvent {
-    /** The lyricsfound event */
-    type: "LyricsFoundEvent";
-    /** The guildId */
-    guildId: string;
-    /** The lyrics */
-    lyrics: LyricsResult;
-}
-interface LyricsNotFoundEvent extends PlayerEvent {
-    /**The lyricsnotfound event*/
-    type: "LyricsNotFoundEvent";
-    /**The guildId*/
-    guildId: string;
-}
-interface LyricsLineEvent extends PlayerEvent {
-    /**The lyricsline event*/
-    type: "LyricsLineEvent";
-    /** The guildId */
-    guildId: string;
-    /** The line number */
-    lineIndex: number;
-    /** The line */
-    line: LyricsLine;
-    /**skipped is true if the line was skipped */
-    skipped: boolean;
-}
-type LoadTypes = "track" | "playlist" | "search" | "error" | "empty";
-type State = "CONNECTED" | "CONNECTING" | "DISCONNECTED" | "DISCONNECTING" | "DESTROYING";
-type PlayerEventType = "TrackStartEvent" | "TrackEndEvent" | "TrackExceptionEvent" | "TrackStuckEvent" | "WebSocketClosedEvent" | SponsorBlockSegmentEventType | LyricsEventType;
-type TrackEndReason = "finished" | "loadFailed" | "stopped" | "replaced" | "cleanup";
-interface InvalidLavalinkRestRequest {
-    /** Rest Request Data for when it was made */
-    timestamp: number;
-    /** Status of the request */
-    status: number;
-    /** Specific Errro which was sent */
-    error: string;
-    /** Specific Message which was created */
-    message?: string;
-    /** The specific error trace from the request */
-    trace?: unknown;
-    /** Path of where it's from */
-    path: string;
-}
-interface LavalinkPlayerVoice {
-    /** The Voice Token */
-    token: string;
-    /** The Voice Server Endpoint  */
-    endpoint: string;
-    /** The Voice SessionId */
-    sessionId: string;
-    /** Wether or not the player is connected */
-    connected?: boolean;
-    /** The Ping to the voice server */
-    ping?: number;
-}
-type LavalinkPlayerVoiceOptions = Omit<LavalinkPlayerVoice, 'connected' | 'ping'>;
-interface FailingAddress {
-    /** The failing address */
-    failingAddress: string;
-    /** The timestamp when the address failed */
-    failingTimestamp: number;
-    /** The timestamp when the address failed as a pretty string */
-    failingTime: string;
-}
-type RoutePlannerTypes = "RotatingIpRoutePlanner" | "NanoIpRoutePlanner" | "RotatingNanoIpRoutePlanner" | "BalancingIpRoutePlanner";
-interface RoutePlanner {
-    class?: RoutePlannerTypes;
-    details?: {
-        /** The ip block being used */
-        ipBlock: {
-            /** The type of the ip block */
-            type: "Inet4Address" | "Inet6Address";
-            /** 	The size of the ip block */
-            size: string;
-        };
-        /** The failing addresses */
-        failingAddresses: FailingAddress[];
-        /** The number of rotations */
-        rotateIndex?: string;
-        /** The current offset in the block	 */
-        ipIndex?: string;
-        /** The current address being used	 */
-        currentAddress?: string;
-        /** The current offset in the ip block */
-        currentAddressIndex?: string;
-        /** The information in which /64 block ips are chosen. This number increases on each ban. */
-        blockIndex?: string;
-    };
+/** Sourcenames provided by lavalink server */
+type LavalinkSourceNames = "youtube" | "youtubemusic" | "soundcloud" | "bandcamp" | "twitch";
+/** Source Names provided by lava src plugin */
+type LavalinkPlugin_LavaSrc_SourceNames = "deezer" | "spotify" | "applemusic" | "yandexmusic" | "flowery-tts" | "vkmusic" | "tidal" | "qobuz" | "pandora";
+/** Source Names provided by jiosaavan plugin */
+type LavalinkPlugin_JioSaavn_SourceNames = "jiosaavn";
+/** The SourceNames provided by lavalink */
+type SourceNames = LavalinkSourceNames | LavalinkPlugin_LavaSrc_SourceNames | LavalinkPlugin_JioSaavn_SourceNames;
+interface LavalinkTrackInfo {
+    /** The Identifier of the Track */
+    identifier: string;
+    /** The Track Title / Name */
+    title: string;
+    /** The Name of the Author */
+    author: string;
+    /** The duration of the Track */
+    length: number;
+    /** The URL of the artwork if available */
+    artworkUrl: string | null;
+    /** The URL (aka Link) of the Track called URI */
+    uri: string;
+    /** The Source name of the Track, e.g. soundcloud, youtube, spotify */
+    sourceName: SourceNames;
+    /** Wether the audio is seekable */
+    isSeekable: boolean;
+    /** Wether the audio is of a live stream */
+    isStream: boolean;
+    /** If isrc code is available, it's provided */
+    isrc: string | null;
 }
-interface Session {
-    /** Wether or not session is resuming or not */
-    resuming: boolean;
-    /** For how long a session is lasting while not connected */
-    timeout: number;
+interface TrackInfo {
+    /** The Identifier of the Track */
+    identifier: string;
+    /** The Track Title / Name */
+    title: string;
+    /** The Name of the Author */
+    author: string;
+    /** The duration of the Track */
+    duration: number;
+    /** The URL of the artwork if available */
+    artworkUrl: string | null;
+    /** The URL (aka Link) of the Track called URI */
+    uri: string;
+    /** The Source name of the Track, e.g. soundcloud, youtube, spotify */
+    sourceName: SourceNames;
+    /** Wether the audio is seekable */
+    isSeekable: boolean;
+    /** Wether the audio is of a live stream */
+    isStream: boolean;
+    /** If isrc code is available, it's provided */
+    isrc: string | null;
 }
-interface GuildShardPayload {
-    /** The OP code */
-    op: number;
-    /** Data to send  */
-    d: {
-        /** Guild id to apply voice settings */
-        guild_id: string;
-        /** channel to move/connect to, or null to leave it */
-        channel_id: string | null;
-        /** wether or not mute yourself */
-        self_mute: boolean;
-        /** wether or not deafen yourself */
-        self_deaf: boolean;
+interface PluginInfo {
+    /** The Type provided by a plugin */
+    type?: "album" | "playlist" | "artist" | "recommendations" | string;
+    /** The Identifier provided by a plugin */
+    albumName?: string;
+    /** The url of the album */
+    albumUrl?: string;
+    /** The url of the album art */
+    albumArtUrl?: string;
+    /** The url of the artist */
+    artistUrl?: string;
+    /** The url of the artist artwork */
+    artistArtworkUrl?: string;
+    /** The url of the preview */
+    previewUrl?: string;
+    /** Whether the track is a preview */
+    isPreview?: boolean;
+    /** The total number of tracks in the playlist */
+    totalTracks?: number;
+    /** The Identifier provided by a plugin */
+    identifier?: string;
+    /** The ArtworkUrl provided by a plugin */
+    artworkUrl?: string;
+    /** The Author Information provided by a plugin */
+    author?: string;
+    /** The Url provided by a Plugin */
+    url?: string;
+    /** The Url provided by a Plugin */
+    uri?: string;
+    /** You can put specific track information here, to transform the tracks... */
+    clientData?: {
+        previousTrack?: boolean;
+        [key: string]: any;
     };
 }
-interface PlayerUpdateInfo {
-    /** guild id of the player */
-    guildId: string;
-    /** Player options to provide to lavalink */
-    playerOptions: LavalinkPlayOptions;
-    /** Whether or not replace the current track with the new one (true is recommended) */
-    noReplace?: boolean;
-}
-interface LavalinkPlayer {
-    /** Guild Id of the player */
-    guildId: string;
-    /** IF playing a track, all of the track information */
-    track?: LavalinkTrack;
-    /** Lavalink volume (mind volumedecrementer) */
-    volume: number;
-    /** Wether it's paused or not */
-    paused: boolean;
-    /** Voice Endpoint data */
-    voice: LavalinkPlayerVoice;
-    /** All Audio Filters */
-    filters: Partial<LavalinkFilterData>;
-    /** Lavalink-Voice-State Variables */
-    state: {
-        /** Time since connection established */
-        time: number;
-        /** Position of the track */
-        position: number;
-        /** COnnected or not */
-        connected: boolean;
-        /** Ping to voice server */
-        ping: number;
-    };
+interface LavalinkTrack {
+    /** The Base 64 encoded String */
+    encoded?: Base64;
+    /** Track Information */
+    info: LavalinkTrackInfo;
+    /** Plugin Information from Lavalink */
+    pluginInfo: Partial<PluginInfo>;
+    /** The userData Object from when you provide to the lavalink request */
+    userData?: anyObject;
 }
-interface ChannelDeletePacket {
-    /** Packet key for channel delete */
-    t: "CHANNEL_DELETE";
-    /** data which is sent and relevant */
-    d: {
-        /** guild id */
-        guild_id: string;
-        /** Channel id */
-        id: string;
-    };
+interface Track {
+    /** The Base 64 encoded String */
+    encoded?: Base64;
+    /** Track Information */
+    info: TrackInfo;
+    /** Plugin Information from Lavalink */
+    pluginInfo: Partial<PluginInfo>;
+    /** The Track's Requester */
+    requester?: unknown;
+    /** The userData Object from when you provide to the lavalink request */
+    userData?: anyObject;
 }
-interface VoiceState {
-    /** OP key from lavalink */
-    op: "voiceUpdate";
-    /** GuildId provided by lavalink */
-    guildId: string;
-    /** Event data */
-    event: VoiceServer;
-    /** Session Id of the voice connection */
-    sessionId?: string;
-    /** guild id of the voice channel */
-    guild_id: string;
-    /** user id from the voice connection */
-    user_id: string;
-    /** Session Id of the voice connection */
-    session_id: string;
-    /** Voice Channel Id */
-    channel_id: string;
-    /** Server Mute status */
-    mute: boolean;
-    /** Server Deaf status */
-    deaf: boolean;
-    /** Self Deaf status */
-    self_deaf: boolean;
-    /** Self Mute status */
-    self_mute: boolean;
-    /** Self Video (Camera) status */
-    self_video: boolean;
-    /** Self Stream status */
-    self_stream: boolean;
-    /** Wether the user requests to speak (stage channel) */
-    request_to_speak_timestamp: boolean;
-    /** Self suppressed status (stage channel) */
-    suppress: boolean;
+interface UnresolvedTrackInfo extends Partial<TrackInfo> {
+    /** Required */
+    title: string;
 }
-/** The Base64 decodes tring by lavalink */
-type Base64 = string;
-interface VoiceServer {
-    /** Voice Token */
-    token: string;
-    /** Guild Id of the voice server connection */
-    guild_id: string;
-    /** Server Endpoint */
-    endpoint: string;
+interface UnresolvedQuery extends UnresolvedTrackInfo {
+    /** The base64 of the unresolved track to "encode" */
+    encoded?: Base64;
 }
-interface VoicePacket {
-    /** Voice Packet Keys to send */
-    t?: "VOICE_SERVER_UPDATE" | "VOICE_STATE_UPDATE";
-    /** Voice Packets to send */
-    d: VoiceState | VoiceServer;
+interface UnresolvedTrack {
+    /** Required */
+    resolve: (player: Player) => Promise<void>;
+    /** The Base 64 encoded String */
+    encoded?: Base64;
+    /** Track Information */
+    info: UnresolvedTrackInfo;
+    /** Plugin Information from Lavalink */
+    pluginInfo: Partial<PluginInfo>;
+    /** The userData Object from when you provide to the lavalink request */
+    userData?: anyObject;
+    /** The Track's Requester */
+    requester?: unknown;
 }
-interface NodeMessage extends NodeStats {
-    /** The type of the event */
-    type: PlayerEventType;
-    /** what ops are applying to that event */
-    op: "stats" | "playerUpdate" | "event";
-    /** The specific guild id for that message */
-    guildId: string;
+
+interface StoredQueue {
+    current: Track | null;
+    previous: Track[];
+    tracks: (Track | UnresolvedTrack)[];
 }
-/** Specific types to filter for lavasearch, will be filtered to correct types */
-type LavaSearchType = "track" | "album" | "artist" | "playlist" | "text" | "tracks" | "albums" | "artists" | "playlists" | "texts";
-interface LavaSearchFilteredResponse {
-    /** The Information of a playlist provided by lavasearch */
-    info: PlaylistInfo;
-    /** additional plugin information */
-    pluginInfo: PluginInfo;
-    /** List of tracks  */
-    tracks: Track[];
+interface QueueStoreManager {
+    /** @async get a Value (MUST RETURN UNPARSED!) */
+    get: (guildId: string) => Awaitable<StoredQueue | string | undefined>;
+    /** @async Set a value inside a guildId (MUST BE UNPARSED) */
+    set: (guildId: string, value: StoredQueue | string) => Awaitable<void | boolean>;
+    /** @async Delete a Database Value based of it's guildId */
+    delete: (guildId: string) => Awaitable<void | boolean>;
+    /** @async Transform the value(s) inside of the QueueStoreManager (IF YOU DON'T NEED PARSING/STRINGIFY, then just return the value) */
+    stringify: (value: StoredQueue | string) => Awaitable<StoredQueue | string>;
+    /** @async Parse the saved value back to the Queue (IF YOU DON'T NEED PARSING/STRINGIFY, then just return the value) */
+    parse: (value: StoredQueue | string) => Awaitable<Partial<StoredQueue>>;
 }
-interface LavaSearchResponse {
-    /** An array of tracks, only present if track is in types */
-    tracks: Track[];
-    /** An array of albums, only present if album is in types */
-    albums: LavaSearchFilteredResponse[];
-    /** 	An array of artists, only present if artist is in types */
-    artists: LavaSearchFilteredResponse[];
-    /** 	An array of playlists, only present if playlist is in types */
-    playlists: LavaSearchFilteredResponse[];
-    /** An array of text results, only present if text is in types */
-    texts: {
-        text: string;
-        pluginInfo: PluginInfo;
-    }[];
-    /** Addition result data provided by plugins */
-    pluginInfo: PluginInfo;
+interface ManagerQueueOptions {
+    /** Maximum Amount of tracks for the queue.previous array. Set to 0 to not save previous songs. Defaults to 25 Tracks */
+    maxPreviousTracks?: number;
+    /** Custom Queue Store option */
+    queueStore?: QueueStoreManager;
+    /** Custom Queue Watcher class */
+    queueChangesWatcher?: QueueChangesWatcher;
+}
+interface QueueChangesWatcher {
+    /** get a Value (MUST RETURN UNPARSED!) */
+    tracksAdd: (guildId: string, tracks: (Track | UnresolvedTrack)[], position: number, oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
+    /** Set a value inside a guildId (MUST BE UNPARSED) */
+    tracksRemoved: (guildId: string, tracks: (Track | UnresolvedTrack)[], position: number | number[], oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
+    /** Set a value inside a guildId (MUST BE UNPARSED) */
+    shuffled: (guildId: string, oldStoredQueue: StoredQueue, newStoredQueue: StoredQueue) => void;
 }
-/** SearchQuery Object for raw lavalink requests */
-type SearchQuery = {
-    /** lavalink search Query / identifier string */
-    query: string;
-    /** Extra url query params to use, e.g. for flowertts */
-    extraQueryUrlParams?: URLSearchParams;
-    /** Source to append to the search query string */
-    source?: SearchPlatform;
-} | /** Our just the search query / identifier string */ string;
-/** SearchQuery Object for Lavalink LavaSearch Plugin requests */
-type LavaSearchQuery = {
-    /** lavalink search Query / identifier string */
-    query: string;
-    /** Source to append to the search query string */
-    source: LavaSrcSearchPlatformBase;
-    /** The Types to filter the search to */
-    types?: LavaSearchType[];
-};
-type Awaitable<T> = Promise<T> | T;
 
-/** The Audio Outputs type */
-type AudioOutputs = "mono" | "stereo" | "left" | "right";
-/** The "active" / "disabled" Player Filters */
-interface PlayerFilters {
-    /** Sets nightcore to false, and vaporwave to false */
-    custom: boolean;
-    /** Sets custom to false, and vaporwave to false */
-    nightcore: boolean;
-    /** Sets custom to false, and nightcore to false */
-    vaporwave: boolean;
-    /** If rotation filter is enabled / not */
-    rotation: boolean;
-    /** if karaoke filter is enabled / not */
-    karaoke: boolean;
-    /** if tremolo filter is enabled / not */
-    tremolo: boolean;
-    /** if vibrato filter is enabled / not */
-    vibrato: boolean;
-    lowPass: boolean;
-    /** audio Output (default stereo, mono sounds the fullest and best for not-stereo tracks) */
-    audioOutput: AudioOutputs;
-    /** Lavalink Volume FILTER (not player Volume, think of it as a gain booster) */
-    volume: boolean;
-    /** Filters for the Lavalink Filter Plugin */
-    lavalinkFilterPlugin: {
-        /** if echo filter is enabled / not */
-        echo: boolean;
-        /** if reverb filter is enabled / not */
-        reverb: boolean;
+type DestroyReasonsType = keyof typeof DestroyReasons | string;
+type DisconnectReasonsType = keyof typeof DisconnectReasons | string;
+interface PlayerJson {
+    /** Guild Id where the player was playing in */
+    guildId: string;
+    /** Options provided to the player */
+    options: PlayerOptions;
+    /** Voice Channel Id the player was playing in */
+    voiceChannelId: string;
+    /** Text Channel Id the player was synced to */
+    textChannelId?: string;
+    /** Position the player was at */
+    position: number;
+    /** Lavalink's position the player was at */
+    lastPosition: number;
+    /** Last time the position was sent from lavalink */
+    lastPositionChange: number | null;
+    /** Volume in % from the player (without volumeDecrementer) */
+    volume: number;
+    /** Real Volume used in lavalink (with the volumeDecrementer) */
+    lavalinkVolume: number;
+    /** The repeatmode from the player */
+    repeatMode: RepeatMode;
+    /** Pause state */
+    paused: boolean;
+    /** Wether the player was playing or not */
+    playing: boolean;
+    /** When the player was created */
+    createdTimeStamp?: number;
+    /** All current used fitlers Data */
+    filters: FilterData;
+    /** The player's ping object */
+    ping: {
+        /** Ping to the voice websocket server */
+        ws: number;
+        /** Avg. calc. Ping to the lavalink server */
+        lavalink: number;
     };
-    lavalinkLavaDspxPlugin: {
-        /** if lowPass filter is enabled / not */
-        lowPass: boolean;
-        /** if highPass filter is enabled / not */
-        highPass: boolean;
-        /** if normalization filter is enabled / not */
-        normalization: boolean;
-        /** if echo filter is enabled / not */
-        echo: boolean;
+    /** Equalizer Bands used in lavalink */
+    equalizer: EQBand[];
+    /** The Id of the last used node */
+    nodeId?: string;
+    /** The SessionId of the node */
+    nodeSessionId?: string;
+    /** The stored queue */
+    queue?: StoredQueue;
+    /** Custom Data for the player get/set datastorage */
+    data: {
+        [key: string]: object | string | number | null;
     };
 }
-/**
- * There are 15 bands (0-14) that can be changed.
- * "gain" is the multiplier for the given band.
- * The default value is 0.
- *  Valid values range from -0.25 to 1.0, where -0.25 means the given band is completely muted, and 0.25 means it is doubled.
- * Modifying the gain could also change the volume of the output.
- */
-interface EQBand {
-    /** On what band position (0-14) it should work */
-    band: IntegerNumber | number;
-    /** The gain (-0.25 to 1.0) */
-    gain: FloatNumber | number;
+type RepeatMode = "queue" | "track" | "off";
+interface PlayerOptions {
+    /** Guild id of the player */
+    guildId: string;
+    /** The Voice Channel Id */
+    voiceChannelId: string;
+    /** The Text Channel Id of the Player */
+    textChannelId?: string;
+    /** instantly change volume with the one play request */
+    volume?: number;
+    /** VC Region for node selections */
+    vcRegion?: string;
+    /** if it should join deafened */
+    selfDeaf?: boolean;
+    /** If it should join muted */
+    selfMute?: boolean;
+    /** If it should use a specific lavalink node */
+    node?: LavalinkNode | string;
+    /** If when applying filters, it should use the insta apply filters fix  */
+    instaUpdateFiltersFix?: boolean;
+    /** If a volume should be applied via filters instead of lavalink-volume */
+    applyVolumeAsFilter?: boolean;
+    /** Custom Data for the player get/set datastorage */
+    customData?: anyObject;
 }
-/**
- * Uses equalization to eliminate part of a band, usually targeting vocals.
- */
-interface KaraokeFilter {
-    /** The level (0 to 1.0 where 0.0 is no effect and 1.0 is full effect) */
-    level?: number;
-    /** The mono level (0 to 1.0 where 0.0 is no effect and 1.0 is full effect) */
-    monoLevel?: number;
-    /** The filter band (in Hz) */
-    filterBand?: number;
-    /**	The filter width */
-    filterWidth?: number;
+type anyObject = {
+    [key: string | number]: string | number | null | anyObject;
+};
+interface BasePlayOptions {
+    /** The position to start the track. */
+    position?: number;
+    /** The position to end the track. */
+    endTime?: number;
+    /** If to start "paused" */
+    paused?: boolean;
+    /** The Volume to start with */
+    volume?: number;
+    /** The Lavalink Filters to use | only with the new REST API */
+    filters?: Partial<LavalinkFilterData>;
+    /** Voice Update for Lavalink */
+    voice?: LavalinkPlayerVoiceOptions;
+}
+interface LavalinkPlayOptions extends BasePlayOptions {
+    /** Which Track to play | don't provide, if it should pick from the Queue */
+    track?: {
+        /** The track encoded base64 string to use instead of the one from the queue system */
+        encoded?: Base64 | null;
+        /** The identifier of the track to use */
+        identifier?: string;
+        /** Custom User Data for the track to provide, will then be on the userData object from the track */
+        userData?: anyObject;
+        /** The Track requester for when u provide encodedTrack / identifer */
+        requester?: unknown;
+    };
+}
+interface PlayOptions extends LavalinkPlayOptions {
+    /** Whether to not replace the track if a play payload is sent. */
+    noReplace?: boolean;
+    /** Adds track on queue and skips to it */
+    clientTrack?: Track | UnresolvedTrack;
 }
+
+/** Ability to manipulate fetch requests */
+type ModifyRequest = (options: RequestInit & {
+    path: string;
+    extraQueryUrlParams?: URLSearchParams;
+}) => void;
+type SponsorBlockSegment = "sponsor" | "selfpromo" | "interaction" | "intro" | "outro" | "preview" | "music_offtopic" | "filler";
 /**
- * Changes the speed, pitch, and rate
+ * Node Options for creating a lavalink node
  */
-interface TimescaleFilter {
-    /** The playback speed 0.0 ≤ x */
-    speed?: number;
-    /** The pitch 0.0 ≤ x */
-    pitch?: number;
-    /** The rate 0.0 ≤ x */
-    rate?: number;
+interface LavalinkNodeOptions {
+    /** The Lavalink Server-Ip / Domain-URL */
+    host: string;
+    /** The Lavalink Connection Port */
+    port: number;
+    /** The Lavalink Password / Authorization-Key */
+    authorization: string;
+    /** Does the Server use ssl (https) */
+    secure?: boolean;
+    /** RESUME THE PLAYER? by providing a sessionid on the node-creation */
+    sessionId?: string;
+    /** Add a Custom ID to the node, for later use */
+    id?: string;
+    /** Voice Regions of this Node */
+    regions?: string[];
+    /** The retryAmount for the node. */
+    retryAmount?: number;
+    /** The retryDelay for the node. */
+    retryDelay?: number;
+    /** signal for cancelling requests - default: AbortSignal.timeout(options.requestSignalTimeoutMS || 10000) - put <= 0 to disable */
+    requestSignalTimeoutMS?: number;
+    /** Close on error */
+    closeOnError?: boolean;
+    /** Heartbeat interval , set to <= 0 to disable heartbeat system */
+    heartBeatInterval?: number;
+    /** Recommended, to check wether the client is still connected or not on the stats endpoint */
+    enablePingOnStatsCheck?: boolean;
 }
 /**
- * Uses amplification to create a shuddering effect, where the volume quickly oscillates.
- * Demo: https://en.wikipedia.org/wiki/File:Fuse_Electronics_Tremolo_MK-III_Quick_Demo.ogv
+ * Memory Stats object from lavalink
  */
-interface TremoloFilter {
-    /** The frequency 0.0 < x */
-    frequency?: number;
-    /** The tremolo depth 0.0 < x ≤ 1.0 */
-    depth?: number;
+interface MemoryStats {
+    /** The free memory of the allocated amount. */
+    free: number;
+    /** The used memory of the allocated amount. */
+    used: number;
+    /** The total allocated memory. */
+    allocated: number;
+    /** The reservable memory. */
+    reservable: number;
 }
 /**
- * Similar to tremolo. While tremolo oscillates the volume, vibrato oscillates the pitch.
+ * CPU Stats object from lavalink
  */
-interface VibratoFilter {
-    /** The frequency 0.0 < x ≤ 14.0 */
-    frequency?: number;
-    /** The vibrato depth 0.0 < x ≤ 1.0 */
-    depth?: number;
+interface CPUStats {
+    /** The core amount the host machine has. */
+    cores: number;
+    /** The system load. */
+    systemLoad: number;
+    /** The lavalink load. */
+    lavalinkLoad: number;
 }
 /**
- * Rotates the sound around the stereo channels/user headphones (aka Audio Panning).
- * It can produce an effect similar to https://youtu.be/QB9EB8mTKcc (without the reverb).
+ * FrameStats Object from lavalink
  */
-interface RotationFilter {
-    /** The frequency of the audio rotating around the listener in Hz. 0.2 is similar to the example video above */
-    rotationHz?: number;
+interface FrameStats {
+    /** The amount of sent frames. */
+    sent?: number;
+    /** The amount of nulled frames. */
+    nulled?: number;
+    /** The amount of deficit frames. */
+    deficit?: number;
 }
 /**
- * Distortion effect. It can generate some pretty unique audio effects.
+ * BaseNodeStats object from Lavalink
  */
-interface DistortionFilter {
-    sinOffset?: number;
-    sinScale?: number;
-    cosOffset?: number;
-    cosScale?: number;
-    tanOffset?: number;
-    tanScale?: number;
-    offset?: number;
-    scale?: number;
+interface BaseNodeStats {
+    /** The amount of players on the node. */
+    players: number;
+    /** The amount of playing players on the node. */
+    playingPlayers: number;
+    /** The uptime for the node. */
+    uptime: number;
+    /** The memory stats for the node. */
+    memory: MemoryStats;
+    /** The cpu stats for the node. */
+    cpu: CPUStats;
+    /** The frame stats for the node. */
+    frameStats: FrameStats;
 }
 /**
- * Mixes both channels (left and right), with a configurable factor on how much each channel affects the other.
- * With the defaults, both channels are kept independent of each other.
- * Setting all factors to 0.5 means both channels get the same audio.
+ * Interface for nodeStats from lavalink
  */
-interface ChannelMixFilter {
-    /** The left to left channel mix factor (0.0 ≤ x ≤ 1.0) */
-    leftToLeft?: number;
-    /** The left to right channel mix factor (0.0 ≤ x ≤ 1.0) */
-    leftToRight?: number;
-    /** The right to left channel mix factor (0.0 ≤ x ≤ 1.0) */
-    rightToLeft?: number;
-    /** The right to right channel mix factor (0.0 ≤ x ≤ 1.0) */
-    rightToRight?: number;
+interface NodeStats extends BaseNodeStats {
+    /** The frame stats for the node. */
+    frameStats: FrameStats;
 }
 /**
- * Higher frequencies get suppressed, while lower frequencies pass through this filter, thus the name low pass.
- * Any smoothing values equal to or less than 1.0 will disable the filter.
+ * Entire lavalink information object from lavalink
  */
-interface LowPassFilter {
-    /** The smoothing factor (1.0 < x) */
-    smoothing?: number;
+interface LavalinkInfo {
+    /** The version of this Lavalink server */
+    version: VersionObject;
+    /** The millisecond unix timestamp when this Lavalink jar was built */
+    buildTime: number;
+    /** The git information of this Lavalink server */
+    git: GitObject;
+    /** The JVM version this Lavalink server runs on */
+    jvm: string;
+    /** The Lavaplayer version being used by this server */
+    lavaplayer: string;
+    /** The enabled source managers for this server */
+    sourceManagers: string[];
+    /** The enabled filters for this server */
+    filters: string[];
+    /** The enabled plugins for this server */
+    plugins: PluginObject[];
 }
 /**
- * Filter Data stored in the Client and partially sent to Lavalink
+ * Lavalink's version object from lavalink
  */
-interface FilterData {
-    volume?: number;
-    karaoke?: KaraokeFilter;
-    timescale?: TimescaleFilter;
-    tremolo?: TremoloFilter;
-    vibrato?: VibratoFilter;
-    rotation?: RotationFilter;
-    distortion?: DistortionFilter;
-    channelMix?: ChannelMixFilter;
-    lowPass?: LowPassFilter;
-    pluginFilters?: {
-        "lavalink-filter-plugin"?: {
-            "echo"?: {
-                delay?: number;
-                decay?: number;
-            };
-            "reverb"?: {
-                delays?: number[];
-                gains?: number[];
-            };
-        };
-        "high-pass"?: {
-            cutoffFrequency?: number;
-            boostFactor?: number;
-        };
-        "low-pass"?: {
-            cutoffFrequency?: number;
-            boostFactor?: number;
-        };
-        normalization?: {
-            maxAmplitude?: number;
-            adaptive?: boolean;
-        };
-        echo?: {
-            echoLength?: number;
-            decay?: number;
-        };
-    };
+interface VersionObject {
+    /** The full version string of this Lavalink server */
+    semver: string;
+    /** The major version of this Lavalink server */
+    major: number;
+    /** The minor version of this Lavalink server */
+    minor: number;
+    /** The patch version of this Lavalink server */
+    patch: number;
+    /** The pre-release version according to semver as a . separated list of identifiers */
+    preRelease?: string;
+    /** The build metadata according to semver as a . separated list of identifiers */
+    build?: string;
 }
 /**
- * Actual Filter Data sent to Lavalink
+ * Git information object from lavalink
  */
-interface LavalinkFilterData extends FilterData {
-    equalizer?: EQBand[];
+interface GitObject {
+    /** The branch this Lavalink server was built on */
+    branch: string;
+    /** The commit this Lavalink server was built on */
+    commit: string;
+    /** The millisecond unix timestamp for when the commit was created */
+    commitTime: string;
 }
-
 /**
- * Debug events for more detailed logging
+ * Lavalink's plugins object from lavalink's plugin
  */
-declare enum DebugEvents {
-    SetSponsorBlock = "SetSponsorBlock",
-    DeleteSponsorBlock = "DeleteSponsorBlock",
-    TrackEndReplaced = "TrackEndReplaced",
-    AutoplayExecution = "AutoplayExecution",
-    AutoplayNoSongsAdded = "AutoplayNoSongsAdded",
-    AutoplayThresholdSpamLimiter = "AutoplayThresholdSpamLimiter",
-    TriggerQueueEmptyInterval = "TriggerQueueEmptyInterval",
-    QueueEnded = "QueueEnded",
-    TrackStartNewSongsOnly = "TrackStartNewSongsOnly",
-    TrackStartNoTrack = "TrackStartNoTrack",
-    ResumingFetchingError = "ResumingFetchingError",
-    PlayerUpdateNoPlayer = "PlayerUpdateNoPlayer",
-    PlayerUpdateFilterFixApply = "PlayerUpdateFilterFixApply",
-    PlayerUpdateSuccess = "PlayerUpdateSuccess",
-    HeartBeatTriggered = "HeartBeatTriggered",
-    NoSocketOnDestroy = "NoSocketOnDestroy",
-    SocketCleanupError = "SocketCleanupError",
-    SocketTerminateHeartBeatTimeout = "SocketTerminateHeartBeatTimeout",
-    TryingConnectWhileConnected = "TryingConnectWhileConnected",
-    LavaSearchNothingFound = "LavaSearchNothingFound",
-    SearchNothingFound = "SearchNothingFound",
-    ValidatingBlacklistLinks = "ValidatingBlacklistLinks",
-    ValidatingWhitelistLinks = "ValidatingWhitelistLinks",
-    TrackErrorMaxTracksErroredPerTime = "TrackErrorMaxTracksErroredPerTime",
-    TrackStuckMaxTracksErroredPerTime = "TrackStuckMaxTracksErroredPerTime",
-    PlayerDestroyingSomewhereElse = "PlayerDestroyingSomewhereElse",
-    PlayerCreateNodeNotFound = "PlayerCreateNodeNotFound",
-    PlayerPlayQueueEmptyTimeoutClear = "PlayerPlayQueueEmptyTimeoutClear",
-    PlayerPlayWithTrackReplace = "PlayerPlayWithTrackReplace",
-    PlayerPlayUnresolvedTrack = "PlayerPlayUnresolvedTrack",
-    PlayerPlayUnresolvedTrackFailed = "PlayerPlayUnresolvedTrackFailed",
-    PlayerVolumeAsFilter = "PlayerVolumeAsFilter",
-    BandcampSearchLokalEngine = "BandcampSearchLokalEngine",
-    PlayerChangeNode = "PlayerChangeNode",
-    BuildTrackError = "BuildTrackError",
-    TransformRequesterFunctionFailed = "TransformRequesterFunctionFailed",
-    GetClosestTrackFailed = "GetClosestTrackFailed",
-    PlayerDeleteInsteadOfDestroy = "PlayerDeleteInsteadOfDestroy",
-    FailedToConnectToNodes = "FailedToConnectToNodes",
-    NoAudioDebug = "NoAudioDebug",
-    PlayerAutoReconnect = "PlayerAutoReconnect",
-    PlayerDestroyFail = "PlayerDestroyFail",
-    PlayerChangeNodeFailNoEligibleNode = "PlayerChangeNodeFailNoEligibleNode",
-    PlayerChangeNodeFail = "PlayerChangeNodeFail"
+interface PluginObject {
+    /** The name of the plugin */
+    name: string;
+    /** The version of the plugin */
+    version: string;
+}
+interface LyricsResult {
+    /**The name of the source */
+    sourceName: string;
+    /**The name of the provider */
+    provider: string;
+    /**The result text */
+    text: string | null;
+    /**The lyrics lines */
+    lines: LyricsLine[];
+    /**Information about the plugin */
+    plugin: PluginInfo;
+}
+interface LyricsLine {
+    /**The millisecond timestamp */
+    timestamp: number;
+    /**The line duration in milliseconds */
+    duration: number | null;
+    /**The line text */
+    line: string;
+    /**Information about the plugin */
+    plugin: PluginInfo;
+}
+type LavalinkNodeIdentifier = string;
+interface NodeManagerEvents {
+    /**
+     * Emitted when a Node is created.
+     * @event Manager.nodeManager#create
+     */
+    "create": (node: LavalinkNode) => void;
+    /**
+     * Emitted when a Node is destroyed.
+     * @event Manager.nodeManager#destroy
+     */
+    "destroy": (node: LavalinkNode, destroyReason?: DestroyReasonsType) => void;
+    /**
+     * Emitted when a Node is connected.
+     * @event Manager.nodeManager#connect
+     */
+    "connect": (node: LavalinkNode) => void;
+    /**
+     * Emitted when a Node is reconnecting.
+     * @event Manager.nodeManager#reconnecting
+    */
+    "reconnecting": (node: LavalinkNode) => void;
+    /**
+     * Emitted When a node starts to reconnect (if you have a reconnection delay, the reconnecting event will be emitted after the retryDelay.)
+     * Useful to check wether the internal node reconnect system works or not
+     * @event Manager.nodeManager#reconnectinprogress
+     */
+    "reconnectinprogress": (node: LavalinkNode) => void;
+    /**
+     * Emitted when a Node is disconnects.
+     * @event Manager.nodeManager#disconnect
+    */
+    "disconnect": (node: LavalinkNode, reason: {
+        code?: number;
+        reason?: string;
+    }) => void;
+    /**
+     * Emitted when a Node failed to reconnect after all retry attempts.
+     * @event Manager.nodeManager#reconnectFailed
+    */
+    "reconnectFailed": (node: LavalinkNode, errorMessage: string, attempts: number) => void;
+    /**
+     * Emitted when a Node is error.
+     * @event Manager.nodeManager#error
+    */
+    "error": (node: LavalinkNode, error: Error, payload?: unknown) => void;
+    /**
+     * Emits every single Node event.
+     * @event Manager.nodeManager#raw
+    */
+    "raw": (node: LavalinkNode, payload: unknown) => void;
+    /**
+     * Emits when the node connects resumed. You then need to create all players within this event for your usecase.
+     * Aka for that you need to be able to save player data like vc channel + text channel in a db and then sync it again
+     * @event Manager.nodeManager#nodeResumed
+     */
+    "resumed": (node: LavalinkNode, payload: {
+        resumed: true;
+        sessionId: string;
+        op: "ready";
+    }, players: LavalinkPlayer[] | InvalidLavalinkRestRequest) => void;
 }
-/**
- * Reasons why a player got destroyed
- */
-declare enum DestroyReasons {
-    QueueEmpty = "QueueEmpty",
-    NodeDestroy = "NodeDestroy",
-    NodeDeleted = "NodeDeleted",
-    LavalinkNoVoice = "LavalinkNoVoice",
-    NodeReconnectFail = "NodeReconnectFail",
-    Disconnected = "Disconnected",
-    PlayerReconnectFail = "PlayerReconnectFail",
-    PlayerChangeNodeFail = "PlayerChangeNodeFail",
-    PlayerChangeNodeFailNoEligibleNode = "PlayerChangeNodeFailNoEligibleNode",
-    ChannelDeleted = "ChannelDeleted",
-    DisconnectAllNodes = "DisconnectAllNodes",
-    ReconnectAllNodes = "ReconnectAllNodes",
-    TrackErrorMaxTracksErroredPerTime = "TrackErrorMaxTracksErroredPerTime",
-    TrackStuckMaxTracksErroredPerTime = "TrackStuckMaxTracksErroredPerTime"
+declare enum ReconnectionState {
+    IDLE = "IDLE",
+    RECONNECTING = "RECONNECTING",
+    PENDING = "PENDING",
+    DESTROYING = "DESTROYING"
 }
+
+declare const TrackSymbol: unique symbol;
+declare const UnresolvedTrackSymbol: unique symbol;
+declare const QueueSymbol: unique symbol;
+declare const NodeSymbol: unique symbol;
 /**
- *  Reasons why a player got disconnected
+ * Parses Node Connection Url: "lavalink://<nodeId>:<nodeAuthorization(Password)>@<NodeHost>:<NodePort>"
+ * @param connectionUrl
+ * @returns
  */
-declare enum DisconnectReasons {
-    Disconnected = "Disconnected",
-    DisconnectAllNodes = "DisconnectAllNodes"
-}
-/** The valid SponsorBlock categories */
-declare const validSponsorBlocks: string[];
-/**  The audio Outputs Data map declaration */
-declare const audioOutputsData: Record<AudioOutputs, ChannelMixFilter>;
-/**  Equalizer Presets */
-declare const EQList: {
-    /** A Bassboost Equalizer, so high it distorts the audio */
-    BassboostEarrape: EQBand[];
-    /** A High and decent Bassboost Equalizer */
-    BassboostHigh: EQBand[];
-    /** A decent Bassboost Equalizer */
-    BassboostMedium: EQBand[];
-    /** A slight Bassboost Equalizer */
-    BassboostLow: EQBand[];
-    /** Makes the Music slightly "better" */
-    BetterMusic: EQBand[];
-    /** Makes the Music sound like rock music / sound rock music better */
-    Rock: EQBand[];
-    /** Makes the Music sound like Classic music / sound Classic music better */
-    Classic: EQBand[];
-    /** Makes the Music sound like Pop music / sound Pop music better */
-    Pop: EQBand[];
-    /** Makes the Music sound like Electronic music / sound Electronic music better */
-    Electronic: EQBand[];
-    /** Boosts all Bands slightly for louder and fuller sound */
-    FullSound: EQBand[];
-    /** Boosts basses + lower highs for a pro gaming sound */
-    Gaming: EQBand[];
-};
-
-type DestroyReasonsType = keyof typeof DestroyReasons | string;
-type DisconnectReasonsType = keyof typeof DisconnectReasons | string;
-interface PlayerJson {
-    /** Guild Id where the player was playing in */
-    guildId: string;
-    /** Options provided to the player */
-    options: PlayerOptions;
-    /** Voice Channel Id the player was playing in */
-    voiceChannelId: string;
-    /** Text Channel Id the player was synced to */
-    textChannelId?: string;
-    /** Position the player was at */
-    position: number;
-    /** Lavalink's position the player was at */
-    lastPosition: number;
-    /** Last time the position was sent from lavalink */
-    lastPositionChange: number | null;
-    /** Volume in % from the player (without volumeDecrementer) */
-    volume: number;
-    /** Real Volume used in lavalink (with the volumeDecrementer) */
-    lavalinkVolume: number;
-    /** The repeatmode from the player */
-    repeatMode: RepeatMode;
-    /** Pause state */
-    paused: boolean;
-    /** Wether the player was playing or not */
-    playing: boolean;
-    /** When the player was created */
-    createdTimeStamp?: number;
-    /** All current used fitlers Data */
-    filters: FilterData;
-    /** The player's ping object */
-    ping: {
-        /** Ping to the voice websocket server */
-        ws: number;
-        /** Avg. calc. Ping to the lavalink server */
-        lavalink: number;
-    };
-    /** Equalizer Bands used in lavalink */
-    equalizer: EQBand[];
-    /** The Id of the last used node */
-    nodeId?: string;
-    /** The SessionId of the node */
-    nodeSessionId?: string;
-    /** The stored queue */
-    queue?: StoredQueue;
-}
-type RepeatMode = "queue" | "track" | "off";
-interface PlayerOptions {
-    /** Guild id of the player */
-    guildId: string;
-    /** The Voice Channel Id */
-    voiceChannelId: string;
-    /** The Text Channel Id of the Player */
-    textChannelId?: string;
-    /** instantly change volume with the one play request */
-    volume?: number;
-    /** VC Region for node selections */
-    vcRegion?: string;
-    /** if it should join deafened */
-    selfDeaf?: boolean;
-    /** If it should join muted */
-    selfMute?: boolean;
-    /** If it should use a specific lavalink node */
-    node?: LavalinkNode | string;
-    /** If when applying filters, it should use the insta apply filters fix  */
-    instaUpdateFiltersFix?: boolean;
-    /** If a volume should be applied via filters instead of lavalink-volume */
-    applyVolumeAsFilter?: boolean;
-    /** Custom Data for the player get/set datastorage */
-    customData?: anyObject;
-}
-type anyObject = {
-    [key: string | number]: string | number | null | anyObject;
+declare function parseLavalinkConnUrl(connectionUrl: string): {
+    authorization: string;
+    id: string;
+    host: string;
+    port: number;
 };
-interface BasePlayOptions {
-    /** The position to start the track. */
-    position?: number;
-    /** The position to end the track. */
-    endTime?: number;
-    /** If to start "paused" */
-    paused?: boolean;
-    /** The Volume to start with */
-    volume?: number;
-    /** The Lavalink Filters to use | only with the new REST API */
-    filters?: Partial<LavalinkFilterData>;
-    /** Voice Update for Lavalink */
-    voice?: LavalinkPlayerVoiceOptions;
-}
-interface LavalinkPlayOptions extends BasePlayOptions {
-    /** Which Track to play | don't provide, if it should pick from the Queue */
-    track?: {
-        /** The track encoded base64 string to use instead of the one from the queue system */
-        encoded?: Base64 | null;
-        /** The identifier of the track to use */
-        identifier?: string;
-        /** Custom User Data for the track to provide, will then be on the userData object from the track */
-        userData?: anyObject;
-        /** The Track requester for when u provide encodedTrack / identifer */
-        requester?: unknown;
+declare class ManagerUtils {
+    LavalinkManager: LavalinkManager | undefined;
+    constructor(LavalinkManager?: LavalinkManager);
+    buildPluginInfo(data: any, clientData?: any): any;
+    buildTrack(data: LavalinkTrack | Track, requester: unknown): Track;
+    /**
+     * Builds a UnresolvedTrack to be resolved before being played  .
+     * @param query
+     * @param requester
+     */
+    buildUnresolvedTrack(query: UnresolvedQuery | UnresolvedTrack, requester: unknown): UnresolvedTrack;
+    /**
+     * Validate if a data is equal to a node
+     * @param data
+     */
+    isNode(data: LavalinkNode): boolean;
+    getTransformedRequester(requester: unknown): unknown;
+    /**
+     * Validate if a data is equal to node options
+     * @param data
+     */
+    isNodeOptions(data: LavalinkNodeOptions): boolean;
+    /**
+     * Validate tracks based on duration wether they are playble or broken tracks.
+     * most tracks should be longer than 30s, so you can put a minDuration of 29e3 (cause preview tracks are exactly 30s) or put 0.
+     * This check is not done automatically, you need to check it yourself by doing:
+     * @example
+     * ```ts
+     * const res = await player.search("Adele");
+     *
+     * // short hand:
+     * const validTracks = res.tracks.filter(client.lavalink.utils.isNotBrokenTrack)
+     * // or with options:
+     * const validTracks = res.tracks.filter(t => client.lavalink.utils.isNotBrokenTrack(t, 29e3));
+     *
+     * // then you can add it to the queue.
+     * await player.queue.add(validTracks);
+     * ```
+     */
+    isNotBrokenTrack(data: Track | UnresolvedTrack, minDuration?: number): data is Track;
+    /**
+     * Validate if a data is equal to a track
+     * @param data the Track to validate
+     * @returns
+     */
+    isTrack(data: Track | UnresolvedTrack): data is Track;
+    /**
+     * Checks if the provided argument is a valid UnresolvedTrack.
+     * @param track
+     */
+    isUnresolvedTrack(data: UnresolvedTrack | Track): data is UnresolvedTrack;
+    /**
+     * Checks if the provided argument is a valid UnresolvedTrack.
+     * @param track
+     */
+    isUnresolvedTrackQuery(data: UnresolvedQuery): boolean;
+    getClosestTrack(data: UnresolvedTrack, player: Player): Promise<Track | undefined>;
+    validateQueryString(node: LavalinkNode, queryString: string, sourceString?: LavalinkSearchPlatform): void;
+    transformQuery(query: SearchQuery): {
+        query: string;
+        extraQueryUrlParams: URLSearchParams;
+        source: any;
     };
+    transformLavaSearchQuery(query: LavaSearchQuery): {
+        query: string;
+        types: string[];
+        source: any;
+    };
+    validateSourceString(node: LavalinkNode, sourceString: SearchPlatform): void;
 }
-interface PlayOptions extends LavalinkPlayOptions {
-    /** Whether to not replace the track if a play payload is sent. */
-    noReplace?: boolean;
-    /** Adds track on queue and skips to it */
-    clientTrack?: Track | UnresolvedTrack;
+/**
+ * Separate interface for the constructor so that emitted js does not have a constructor that overwrites itself
+ *
+ * @internal
+ */
+interface MiniMap<K, V> extends Map<K, V> {
+    constructor: MiniMapConstructor;
 }
-
-type NodeLinkEventTypes = "PlayerCreatedEvent" | "PlayerDestroyedEvent" | "PlayerConnectedEvent" | "PlayerReconnectingEvent" | "VolumeChangedEvent" | "FiltersChangedEvent" | "SeekEvent" | "PauseEvent" | "ConnectionStatusEvent" | "MixStartedEvent" | "MixEndedEvent";
-interface NodeLinkBaseEvent {
-    op: "event";
-    type: NodeLinkEventTypes;
-    guildId: string;
+declare class MiniMap<K, V> extends Map<K, V> {
+    constructor(data?: [K, V][]);
+    /**
+     * Identical to
+     * [Array.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
+     * but returns a MiniMap instead of an Array.
+     *
+     * @param fn The function to test with (should return boolean)
+     * @param thisArg Value to use as `this` when executing function
+     *
+     * @example
+     * miniMap.filter(user => user.username === 'Bob');
+     */
+    filter<K2 extends K>(fn: (value: V, key: K, miniMap: this) => key is K2): MiniMap<K2, V>;
+    filter<V2 extends V>(fn: (value: V, key: K, miniMap: this) => value is V2): MiniMap<K, V2>;
+    filter(fn: (value: V, key: K, miniMap: this) => boolean): MiniMap<K, V>;
+    filter<This, K2 extends K>(fn: (this: This, value: V, key: K, miniMap: this) => key is K2, thisArg: This): MiniMap<K2, V>;
+    filter<This, V2 extends V>(fn: (this: This, value: V, key: K, miniMap: this) => value is V2, thisArg: This): MiniMap<K, V2>;
+    filter<This>(fn: (this: This, value: V, key: K, miniMap: this) => boolean, thisArg: This): MiniMap<K, V>;
+    toJSON(): [K, V][];
+    /**
+     * Maps each item to another value into an array. Identical in behavior to
+     * [Array.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).
+     *
+     * @param fn Function that produces an element of the new array, taking three arguments
+     * @param thisArg Value to use as `this` when executing function
+     *
+     * @example
+     * miniMap.map(user => user.tag);
+     */
+    map<T>(fn: (value: V, key: K, miniMap: this) => T): T[];
+    map<This, T>(fn: (this: This, value: V, key: K, miniMap: this) => T, thisArg: This): T[];
 }
-interface PlayerCreatedEvent extends NodeLinkBaseEvent {
-    type: "PlayerCreatedEvent";
+declare function queueTrackEnd(player: Player, dontShiftQueue?: boolean): Promise<Track>;
+declare function safeStringify(obj: any, padding?: number): string;
+
+/** Helper for generating Opaque types. */
+type Opaque<T, K> = T & {
+    __opaque__: K;
+};
+/** Opqaue tyep for integernumber */
+type IntegerNumber = Opaque<number, 'Int'>;
+/** Opqaue tyep for floatnumber */
+type FloatNumber = Opaque<number, 'Float'>;
+type LavaSrcSearchPlatformBase = "spsearch" | "sprec" | "amsearch" | "dzsearch" | "dzisrc" | "dzrec" | "ymsearch" | "ymrec" | "vksearch" | "vkrec" | "tdsearch" | "tdrec" | "qbsearch" | "qbisrc" | "qbrec" | "pdsearch" | "pdisrc" | "pdrec";
+type LavaSrcSearchPlatform = LavaSrcSearchPlatformBase | "ftts";
+type JioSaavnSearchPlatform = "jssearch" | "jsrec";
+type DuncteSearchPlatform = "speak" | "phsearch" | "pornhub" | "porn" | "tts";
+type LavalinkClientSearchPlatform = "bcsearch";
+type LavalinkClientSearchPlatformResolve = "bandcamp" | "bc";
+type LavalinkSearchPlatform = "ytsearch" | "ytmsearch" | "scsearch" | "bcsearch" | LavaSrcSearchPlatform | DuncteSearchPlatform | JioSaavnSearchPlatform | LavalinkClientSearchPlatform;
+type ClientCustomSearchPlatformUtils = "local" | "http" | "https" | "link" | "uri";
+type ClientSearchPlatform = ClientCustomSearchPlatformUtils | // for file/link requests
+"youtube" | "yt" | "youtube music" | "youtubemusic" | "ytm" | "musicyoutube" | "music youtube" | "soundcloud" | "sc" | "am" | "apple music" | "applemusic" | "apple" | "musicapple" | "music apple" | "sp" | "spsuggestion" | "spotify" | "spotify.com" | "spotifycom" | "dz" | "deezer" | "yandex" | "yandex music" | "yandexmusic" | "vk" | "vk music" | "vkmusic" | "tidal" | "tidal music" | "qobuz" | "pandora" | "pd" | "pandora music" | "pandoramusic" | "flowerytts" | "flowery" | "flowery.tts" | LavalinkClientSearchPlatformResolve | LavalinkClientSearchPlatform | "js" | "jiosaavn" | "td" | "tidal" | "tdrec";
+type SearchPlatform = LavalinkSearchPlatform | ClientSearchPlatform;
+type SourcesRegex = "YoutubeRegex" | "YoutubeMusicRegex" | "SoundCloudRegex" | "SoundCloudMobileRegex" | "DeezerTrackRegex" | "DeezerArtistRegex" | "DeezerEpisodeRegex" | "DeezerMixesRegex" | "DeezerPageLinkRegex" | "DeezerPlaylistRegex" | "DeezerAlbumRegex" | "AllDeezerRegex" | "AllDeezerRegexWithoutPageLink" | "SpotifySongRegex" | "SpotifyPlaylistRegex" | "SpotifyArtistRegex" | "SpotifyEpisodeRegex" | "SpotifyShowRegex" | "SpotifyAlbumRegex" | "AllSpotifyRegex" | "mp3Url" | "m3uUrl" | "m3u8Url" | "mp4Url" | "m4aUrl" | "wavUrl" | "aacpUrl" | "tiktok" | "mixcloud" | "musicYandex" | "radiohost" | "bandcamp" | "jiosaavn" | "appleMusic" | "tidal" | "PandoraTrackRegex" | "PandoraAlbumRegex" | "PandoraArtistRegex" | "PandoraPlaylistRegex" | "AllPandoraRegex" | "TwitchTv" | "vimeo";
+interface PlaylistInfo {
+    /** The playlist name */
+    name: string;
+    /** The playlist title (same as name) */
+    title: string;
+    /** The playlist Author */
+    author?: string;
+    /** The playlist Thumbnail */
+    thumbnail?: string;
+    /** A Uri to the playlist */
+    uri?: string;
+    /** The playlist selected track. */
+    selectedTrack: Track | null;
+    /** The duration of the entire playlist. (calcualted) */
+    duration: number;
 }
-interface PlayerDestroyedEvent extends NodeLinkBaseEvent {
-    type: "PlayerDestroyedEvent";
+interface SearchResult {
+    loadType: LoadTypes;
+    exception: Exception | null;
+    pluginInfo: PluginInfo;
+    playlist: PlaylistInfo | null;
+    tracks: Track[];
 }
-interface PlayerConnectedEvent extends NodeLinkBaseEvent {
-    type: "PlayerConnectedEvent";
+interface UnresolvedSearchResult {
+    loadType: LoadTypes;
+    exception: Exception | null;
+    pluginInfo: PluginInfo;
+    playlist: PlaylistInfo | null;
+    tracks: UnresolvedTrack[];
 }
-interface PlayerReconnectingEvent extends NodeLinkBaseEvent {
-    type: "PlayerReconnectingEvent";
+/**
+ * @internal
+ */
+interface MiniMapConstructor {
+    new (): MiniMap<unknown, unknown>;
+    new <K, V>(entries?: ReadonlyArray<readonly [K, V]> | null): MiniMap<K, V>;
+    new <K, V>(iterable: Iterable<readonly [K, V]>): MiniMap<K, V>;
+    readonly prototype: MiniMap<unknown, unknown>;
+    readonly [Symbol.species]: MiniMapConstructor;
 }
-interface VolumeChangedEvent extends NodeLinkBaseEvent {
-    type: "VolumeChangedEvent";
-    /** New volume level (0-1000) */
-    volume: number;
+type PlayerEvents = TrackStartEvent | TrackEndEvent | TrackStuckEvent | TrackExceptionEvent | WebSocketClosedEvent | SponsorBlockSegmentEvents | LyricsEvent;
+type Severity = "COMMON" | "SUSPICIOUS" | "FAULT";
+interface Exception {
+    /** Severity of the error */
+    severity: Severity;
+    /** Nodejs Error */
+    error?: Error;
+    /** Message by lavalink */
+    message: string;
+    /** Cause by lavalink */
+    cause: string;
+    /** causeStackTrace by lavalink */
+    causeStackTrace: string;
 }
-interface FiltersChangedEvent extends NodeLinkBaseEvent {
-    type: "FiltersChangedEvent";
-    filters: LavalinkFilterData;
+interface PlayerEvent {
+    op: "event";
+    type: PlayerEventType;
+    guildId: string;
 }
-interface SeekEvent extends NodeLinkBaseEvent {
-    type: "SeekEvent";
-    /** New position in milliseconds */
-    position: number;
+interface TrackStartEvent extends PlayerEvent {
+    type: "TrackStartEvent";
+    track: LavalinkTrack;
 }
-interface PauseEvent extends NodeLinkBaseEvent {
-    type: "PauseEvent";
-    /** Whether playback is now paused (true) or resumed (false) */
-    paused: boolean;
+interface TrackEndEvent extends PlayerEvent {
+    type: "TrackEndEvent";
+    track: LavalinkTrack;
+    reason: TrackEndReason;
 }
-interface ConnectionStatusEvent extends NodeLinkBaseEvent {
-    type: "ConnectionStatusEvent";
-    /** Current connection status */
-    connected: boolean;
+interface TrackExceptionEvent extends PlayerEvent {
+    type: "TrackExceptionEvent";
+    exception?: Exception;
+    track: LavalinkTrack;
+    error: string;
 }
-interface MixStartedEvent extends NodeLinkBaseEvent {
-    type: "MixStartedEvent";
-    /** Unique identifier for the mix layer */
-    mixId: string;
-    /** Full track information of the mixed layer */
+interface TrackStuckEvent extends PlayerEvent {
+    type: "TrackStuckEvent";
+    thresholdMs: number;
     track: LavalinkTrack;
-    /** Volume of the mixed layer (0.0 to 1.0) */
-    volume: number;
 }
-interface MixEndedEvent extends NodeLinkBaseEvent {
-    type: "MixEndedEvent";
-    /** Unique identifier for the mix layer */
-    mixId: string;
-    /** Reason the mix layer ended (FINISHED, REMOVED, ERROR, MAIN_ENDED) */
-    reason: "FINISHED" | "REMOVED" | "ERROR" | "MAIN_ENDED" | string;
+interface WebSocketClosedEvent extends PlayerEvent {
+    type: "WebSocketClosedEvent";
+    code: number;
+    byRemote: boolean;
+    reason: string;
 }
-type NodeLinkEventPayload<T extends NodeLinkEventTypes> = T extends "PlayerCreatedEvent" ? PlayerCreatedEvent : T extends "PlayerDestroyedEvent" ? PlayerDestroyedEvent : T extends "PlayerConnectedEvent" ? PlayerConnectedEvent : T extends "PlayerReconnectingEvent" ? PlayerReconnectingEvent : T extends "VolumeChangedEvent" ? VolumeChangedEvent : T extends "FiltersChangedEvent" ? FiltersChangedEvent : T extends "SeekEvent" ? SeekEvent : T extends "PauseEvent" ? PauseEvent : T extends "ConnectionStatusEvent" ? ConnectionStatusEvent : T extends "MixStartedEvent" ? MixStartedEvent : T extends "MixEndedEvent" ? MixEndedEvent : never;
-
-/** Ability to manipulate fetch requests */
-type ModifyRequest = (options: RequestInit & {
-    path: string;
-    extraQueryUrlParams?: URLSearchParams;
-}) => void;
-type SponsorBlockSegment = "sponsor" | "selfpromo" | "interaction" | "intro" | "outro" | "preview" | "music_offtopic" | "filler";
 /**
- * Node Options for creating a lavalink node
+ * Types & Events for Sponsorblock-plugin from Lavalink: https://github.com/topi314/Sponsorblock-Plugin#segmentsloaded
  */
-interface LavalinkNodeOptions {
-    /** The Lavalink Server-Ip / Domain-URL */
-    host: string;
-    /** The Lavalink Connection Port */
-    port: number;
-    /** The Lavalink Password / Authorization-Key */
-    authorization: string;
-    /** Does the Server use ssl (https) */
-    secure?: boolean;
-    /** RESUME THE PLAYER? by providing a sessionid on the node-creation */
-    sessionId?: string;
-    /** Add a Custom ID to the node, for later use */
-    id?: string;
-    /** Voice Regions of this Node */
-    regions?: string[];
-    /** The max amount of retries for this node. */
-    retryAmount?: number;
-    /** The delay of how often to retry a reconnection. */
-    retryDelay?: number;
-    /** How long a retry is a valid retry, it should be at least retryAmount*retryDelay. if <= 0 (default) then this won't be accounted. */
-    retryTimespan?: number;
-    /** signal for cancelling requests - default: AbortSignal.timeout(options.requestSignalTimeoutMS || 10000) - put <= 0 to disable */
-    requestSignalTimeoutMS?: number;
-    /** Close on error */
-    closeOnError?: boolean;
-    /** Heartbeat interval , set to <= 0 to disable heartbeat system */
-    heartBeatInterval?: number;
-    /** Recommended, to check wether the client is still connected or not on the stats endpoint */
-    enablePingOnStatsCheck?: boolean;
+type SponsorBlockSegmentEvents = SponsorBlockSegmentSkipped | SponsorBlockSegmentsLoaded | SponsorBlockChapterStarted | SponsorBlockChaptersLoaded;
+type SponsorBlockSegmentEventType = "SegmentSkipped" | "SegmentsLoaded" | "ChaptersLoaded" | "ChapterStarted";
+interface SponsorBlockSegmentsLoaded extends PlayerEvent {
+    type: "SegmentsLoaded";
+    segments: {
+        category: string;
+        start: number;
+        end: number;
+    }[];
 }
-/**
- * Memory Stats object from lavalink
- */
-interface MemoryStats {
-    /** The free memory of the allocated amount. */
-    free: number;
-    /** The used memory of the allocated amount. */
-    used: number;
-    /** The total allocated memory. */
-    allocated: number;
-    /** The reservable memory. */
-    reservable: number;
+interface SponsorBlockSegmentSkipped extends PlayerEvent {
+    type: "SegmentSkipped";
+    segment: {
+        category: string;
+        start: number;
+        end: number;
+    };
+}
+interface SponsorBlockChapterStarted extends PlayerEvent {
+    type: "ChapterStarted";
+    /** The Chapter which started */
+    chapter: {
+        /** The Name of the Chapter */
+        name: string;
+        start: number;
+        end: number;
+        duration: number;
+    };
+}
+interface SponsorBlockChaptersLoaded extends PlayerEvent {
+    type: "ChaptersLoaded";
+    /** All Chapters loaded */
+    chapters: {
+        /** The Name of the Chapter */
+        name: string;
+        start: number;
+        end: number;
+        duration: number;
+    }[];
 }
 /**
- * CPU Stats object from lavalink
+ * Types & Events for Lyrics plugin from Lavalink: https://github.com/topi314/LavaLyrics
  */
-interface CPUStats {
-    /** The core amount the host machine has. */
-    cores: number;
-    /** The system load. */
-    systemLoad: number;
-    /** The lavalink load. */
-    lavalinkLoad: number;
+type LyricsEvent = LyricsFoundEvent | LyricsNotFoundEvent | LyricsLineEvent;
+type LyricsEventType = "LyricsFoundEvent" | "LyricsNotFoundEvent" | "LyricsLineEvent";
+interface LyricsFoundEvent extends PlayerEvent {
+    /** The lyricsfound event */
+    type: "LyricsFoundEvent";
+    /** The guildId */
+    guildId: string;
+    /** The lyrics */
+    lyrics: LyricsResult;
 }
-/**
- * FrameStats Object from lavalink
- */
-interface FrameStats {
-    /** The amount of sent frames. */
-    sent?: number;
-    /** The amount of nulled frames. */
-    nulled?: number;
-    /** The amount of deficit frames. */
-    deficit?: number;
+interface LyricsNotFoundEvent extends PlayerEvent {
+    /**The lyricsnotfound event*/
+    type: "LyricsNotFoundEvent";
+    /**The guildId*/
+    guildId: string;
 }
-/**
- * BaseNodeStats object from Lavalink
- */
-interface BaseNodeStats {
-    /** The amount of players on the node. */
-    players: number;
-    /** The amount of playing players on the node. */
-    playingPlayers: number;
-    /** The uptime for the node. */
-    uptime: number;
-    /** The memory stats for the node. */
-    memory: MemoryStats;
-    /** The cpu stats for the node. */
-    cpu: CPUStats;
-    /** The frame stats for the node. */
-    frameStats: FrameStats;
+interface LyricsLineEvent extends PlayerEvent {
+    /**The lyricsline event*/
+    type: "LyricsLineEvent";
+    /** The guildId */
+    guildId: string;
+    /** The line number */
+    lineIndex: number;
+    /** The line */
+    line: LyricsLine;
+    /**skipped is true if the line was skipped */
+    skipped: boolean;
+}
+type LoadTypes = "track" | "playlist" | "search" | "error" | "empty";
+type State = "CONNECTED" | "CONNECTING" | "DISCONNECTED" | "DISCONNECTING" | "DESTROYING";
+type PlayerEventType = "TrackStartEvent" | "TrackEndEvent" | "TrackExceptionEvent" | "TrackStuckEvent" | "WebSocketClosedEvent" | SponsorBlockSegmentEventType | LyricsEventType;
+type TrackEndReason = "finished" | "loadFailed" | "stopped" | "replaced" | "cleanup";
+interface InvalidLavalinkRestRequest {
+    /** Rest Request Data for when it was made */
+    timestamp: number;
+    /** Status of the request */
+    status: number;
+    /** Specific Errro which was sent */
+    error: string;
+    /** Specific Message which was created */
+    message?: string;
+    /** The specific error trace from the request */
+    trace?: unknown;
+    /** Path of where it's from */
+    path: string;
+}
+interface LavalinkPlayerVoice {
+    /** The Voice Token */
+    token: string;
+    /** The Voice Server Endpoint  */
+    endpoint: string;
+    /** The Voice SessionId */
+    sessionId: string;
+    /** Wether or not the player is connected */
+    connected?: boolean;
+    /** The Ping to the voice server */
+    ping?: number;
+}
+type LavalinkPlayerVoiceOptions = Omit<LavalinkPlayerVoice, 'connected' | 'ping'>;
+interface FailingAddress {
+    /** The failing address */
+    failingAddress: string;
+    /** The timestamp when the address failed */
+    failingTimestamp: number;
+    /** The timestamp when the address failed as a pretty string */
+    failingTime: string;
 }
-interface NodeLinkConnectionMetrics {
-    status: string;
-    metrics: {
-        speed: {
-            bps: number;
-            kbps: number;
-            mbps: number;
+type RoutePlannerTypes = "RotatingIpRoutePlanner" | "NanoIpRoutePlanner" | "RotatingNanoIpRoutePlanner" | "BalancingIpRoutePlanner";
+interface RoutePlanner {
+    class?: RoutePlannerTypes;
+    details?: {
+        /** The ip block being used */
+        ipBlock: {
+            /** The type of the ip block */
+            type: "Inet4Address" | "Inet6Address";
+            /** 	The size of the ip block */
+            size: string;
         };
-        downloadedBytes: number;
-        durationSeconds: number;
-        timestamp: number;
+        /** The failing addresses */
+        failingAddresses: FailingAddress[];
+        /** The number of rotations */
+        rotateIndex?: string;
+        /** The current offset in the block	 */
+        ipIndex?: string;
+        /** The current address being used	 */
+        currentAddress?: string;
+        /** The current offset in the ip block */
+        currentAddressIndex?: string;
+        /** The information in which /64 block ips are chosen. This number increases on each ban. */
+        blockIndex?: string;
     };
 }
-/**
- * Interface for nodeStats from lavalink
- */
-interface NodeStats extends BaseNodeStats {
-    /** The frame stats for the node. */
-    frameStats: FrameStats;
-    /** something from nodeLink https://nodelink.js.org/docs/differences#detailed-statistics */
-    detailedStats?: {
-        api: {
-            /** e.g. { "/v4/loadtracks": 150, "/v4/info": 5 }  */
-            requests: Record<string, number>;
-            errors: unknown;
-        };
-        /** e.g. { "youtube": 150, "soundcloud": 5 } */
-        sources: Record<string, number>;
-        playback: {
-            /** e.g. { "TrackStartEvent": 150, "TrackEndEvent": 5 } */
-            events: Record<string, number>;
-        };
-        /** and potential others */
-        [key: string]: unknown;
+interface Session {
+    /** Wether or not session is resuming or not */
+    resuming: boolean;
+    /** For how long a session is lasting while not connected */
+    timeout: number;
+}
+interface GuildShardPayload {
+    /** The OP code */
+    op: number;
+    /** Data to send  */
+    d: {
+        /** Guild id to apply voice settings */
+        guild_id: string;
+        /** channel to move/connect to, or null to leave it */
+        channel_id: string | null;
+        /** wether or not mute yourself */
+        self_mute: boolean;
+        /** wether or not deafen yourself */
+        self_deaf: boolean;
     };
 }
-/**
- * Entire lavalink information object from lavalink
- */
-interface LavalinkInfo {
-    /** The version of this Lavalink server */
-    version: VersionObject;
-    /** The millisecond unix timestamp when this Lavalink jar was built */
-    buildTime: number;
-    /** The git information of this Lavalink server */
-    git: GitObject;
-    /** The JVM version this Lavalink server runs on */
-    jvm: string;
-    /** The Lavaplayer version being used by this server */
-    lavaplayer: string;
-    /** The enabled source managers for this server */
-    sourceManagers: string[];
-    /** The enabled filters for this server */
-    filters: string[];
-    /** The enabled plugins for this server */
-    plugins: PluginObject[];
-    /** Something from NodeLink: https://nodelink.js.org/docs/differences#server-info */
-    isNodelink?: boolean;
+interface PlayerUpdateInfo {
+    /** guild id of the player */
+    guildId: string;
+    /** Player options to provide to lavalink */
+    playerOptions: LavalinkPlayOptions;
+    /** Whether or not replace the current track with the new one (true is recommended) */
+    noReplace?: boolean;
 }
-/**
- * Lavalink's version object from lavalink
- */
-interface VersionObject {
-    /** The full version string of this Lavalink server */
-    semver: string;
-    /** The major version of this Lavalink server */
-    major: number;
-    /** The minor version of this Lavalink server */
-    minor: number;
-    /** The patch version of this Lavalink server */
-    patch: number;
-    /** The pre-release version according to semver as a . separated list of identifiers */
-    preRelease?: string;
-    /** The build metadata according to semver as a . separated list of identifiers */
-    build?: string;
+interface LavalinkPlayer {
+    /** Guild Id of the player */
+    guildId: string;
+    /** IF playing a track, all of the track information */
+    track?: LavalinkTrack;
+    /** Lavalink volume (mind volumedecrementer) */
+    volume: number;
+    /** Wether it's paused or not */
+    paused: boolean;
+    /** Voice Endpoint data */
+    voice: LavalinkPlayerVoice;
+    /** All Audio Filters */
+    filters: Partial<LavalinkFilterData>;
+    /** Lavalink-Voice-State Variables */
+    state: {
+        /** Time since connection established */
+        time: number;
+        /** Position of the track */
+        position: number;
+        /** COnnected or not */
+        connected: boolean;
+        /** Ping to voice server */
+        ping: number;
+    };
 }
-/**
- * Git information object from lavalink
- */
-interface GitObject {
-    /** The branch this Lavalink server was built on */
-    branch: string;
-    /** The commit this Lavalink server was built on */
-    commit: string;
-    /** The millisecond unix timestamp for when the commit was created */
-    commitTime: string;
+interface ChannelDeletePacket {
+    /** Packet key for channel delete */
+    t: "CHANNEL_DELETE";
+    /** data which is sent and relevant */
+    d: {
+        /** guild id */
+        guild_id: string;
+        /** Channel id */
+        id: string;
+    };
+}
+interface VoiceState {
+    /** OP key from lavalink */
+    op: "voiceUpdate";
+    /** GuildId provided by lavalink */
+    guildId: string;
+    /** Event data */
+    event: VoiceServer;
+    /** Session Id of the voice connection */
+    sessionId?: string;
+    /** guild id of the voice channel */
+    guild_id: string;
+    /** user id from the voice connection */
+    user_id: string;
+    /** Session Id of the voice connection */
+    session_id: string;
+    /** Voice Channel Id */
+    channel_id: string;
+    /** Server Mute status */
+    mute: boolean;
+    /** Server Deaf status */
+    deaf: boolean;
+    /** Self Deaf status */
+    self_deaf: boolean;
+    /** Self Mute status */
+    self_mute: boolean;
+    /** Self Video (Camera) status */
+    self_video: boolean;
+    /** Self Stream status */
+    self_stream: boolean;
+    /** Wether the user requests to speak (stage channel) */
+    request_to_speak_timestamp: boolean;
+    /** Self suppressed status (stage channel) */
+    suppress: boolean;
 }
-/**
- * Lavalink's plugins object from lavalink's plugin
- */
-interface PluginObject {
-    /** The name of the plugin */
-    name: string;
-    /** The version of the plugin */
-    version: string;
+/** The Base64 decodes tring by lavalink */
+type Base64 = string;
+interface VoiceServer {
+    /** Voice Token */
+    token: string;
+    /** Guild Id of the voice server connection */
+    guild_id: string;
+    /** Server Endpoint */
+    endpoint: string;
 }
-interface LyricsResult {
-    /**The name of the source */
-    sourceName: string;
-    /**The name of the provider */
-    provider: string;
-    /**The result text */
-    text: string | null;
-    /**The lyrics lines */
-    lines: LyricsLine[];
-    /**Information about the plugin */
-    plugin: PluginInfo;
+interface VoicePacket {
+    /** Voice Packet Keys to send */
+    t?: "VOICE_SERVER_UPDATE" | "VOICE_STATE_UPDATE";
+    /** Voice Packets to send */
+    d: VoiceState | VoiceServer;
 }
-interface LyricsLine {
-    /**The millisecond timestamp */
-    timestamp: number;
-    /**The line duration in milliseconds */
-    duration: number | null;
-    /**The line text */
-    line: string;
-    /**Information about the plugin */
-    plugin: PluginInfo;
+interface NodeMessage extends NodeStats {
+    /** The type of the event */
+    type: PlayerEventType;
+    /** what ops are applying to that event */
+    op: "stats" | "playerUpdate" | "event";
+    /** The specific guild id for that message */
+    guildId: string;
 }
-type LavalinkNodeIdentifier = string;
-interface NodeManagerEvents {
-    /**
-     * Emitted when a Node is created.
-     * @event Manager.nodeManager#create
-     */
-    "create": (node: LavalinkNode) => void;
-    /**
-     * Emitted when a Node is destroyed.
-     * @event Manager.nodeManager#destroy
-     */
-    "destroy": (node: LavalinkNode, destroyReason?: DestroyReasonsType) => void;
-    /**
-     * Emitted when a Node is connected.
-     * @event Manager.nodeManager#connect
-     */
-    "connect": (node: LavalinkNode) => void;
-    /**
-     * Emitted when a Node is reconnecting.
-     * @event Manager.nodeManager#reconnecting
-    */
-    "reconnecting": (node: LavalinkNode) => void;
-    /**
-     * Emitted When a node starts to reconnect (if you have a reconnection delay, the reconnecting event will be emitted after the retryDelay.)
-     * Useful to check wether the internal node reconnect system works or not
-     * @event Manager.nodeManager#reconnectinprogress
-     */
-    "reconnectinprogress": (node: LavalinkNode) => void;
-    /**
-     * Emitted when a Node is disconnects.
-     * @event Manager.nodeManager#disconnect
-    */
-    "disconnect": (node: LavalinkNode, reason: {
-        code?: number;
-        reason?: string;
-    }) => void;
-    /**
-     * Emitted when a Node is error.
-     * @event Manager.nodeManager#error
-    */
-    "error": (node: LavalinkNode, error: Error, payload?: unknown) => void;
-    /**
-     * Emits every single Node event.
-     * @event Manager.nodeManager#raw
-    */
-    "raw": (node: LavalinkNode, payload: unknown) => void;
-    /**
-     * Emits when the node connects resumed. You then need to create all players within this event for your usecase.
-     * Aka for that you need to be able to save player data like vc channel + text channel in a db and then sync it again
-     * @event Manager.nodeManager#nodeResumed
-     */
-    "resumed": (node: LavalinkNode, payload: {
-        resumed: true;
-        sessionId: string;
-        op: "ready";
-    }, players: LavalinkPlayer[] | InvalidLavalinkRestRequest) => void;
-    /**
-     * Event Handler for Nodelink specific events https://nodelink.js.org/docs/api/websocket Fully typed and generic based on the eventName.
-     * @event Manager.nodeManager#nodeLinkEvent
-     * @example
-     *
-     * ```ts
-     * this.nodeManager.on("nodeLinkEvent", (node, event, player, track, payload) => {
-     *   if (event === "SeekEvent") {
-     *       console.log("new position:", payload.position);
-     *   }
-     *   if (event === "FiltersChangedEvent") {
-     *       console.log("new filters state", payload.filters);
-     *   }
-     * });
-     * ```
-     */
-    "nodeLinkEvent": (...args: {
-        [K in NodeLinkEventTypes]: [node: LavalinkNode, event: K, player: Player, track: Track | null, payload: NodeLinkEventPayload<K>];
-    }[NodeLinkEventTypes]) => void;
+/** Specific types to filter for lavasearch, will be filtered to correct types */
+type LavaSearchType = "track" | "album" | "artist" | "playlist" | "text" | "tracks" | "albums" | "artists" | "playlists" | "texts";
+interface LavaSearchFilteredResponse {
+    /** The Information of a playlist provided by lavasearch */
+    info: PlaylistInfo;
+    /** additional plugin information */
+    pluginInfo: PluginInfo;
+    /** List of tracks  */
+    tracks: Track[];
 }
-declare enum ReconnectionState {
-    IDLE = "IDLE",
-    RECONNECTING = "RECONNECTING",
-    PENDING = "PENDING",
-    DESTROYING = "DESTROYING"
+interface LavaSearchResponse {
+    /** An array of tracks, only present if track is in types */
+    tracks: Track[];
+    /** An array of albums, only present if album is in types */
+    albums: LavaSearchFilteredResponse[];
+    /** 	An array of artists, only present if artist is in types */
+    artists: LavaSearchFilteredResponse[];
+    /** 	An array of playlists, only present if playlist is in types */
+    playlists: LavaSearchFilteredResponse[];
+    /** An array of text results, only present if text is in types */
+    texts: {
+        text: string;
+        pluginInfo: PluginInfo;
+    }[];
+    /** Addition result data provided by plugins */
+    pluginInfo: PluginInfo;
 }
+/** SearchQuery Object for raw lavalink requests */
+type SearchQuery = {
+    /** lavalink search Query / identifier string */
+    query: string;
+    /** Extra url query params to use, e.g. for flowertts */
+    extraQueryUrlParams?: URLSearchParams;
+    /** Source to append to the search query string */
+    source?: SearchPlatform;
+} | /** Our just the search query / identifier string */ string;
+/** SearchQuery Object for Lavalink LavaSearch Plugin requests */
+type LavaSearchQuery = {
+    /** lavalink search Query / identifier string */
+    query: string;
+    /** Source to append to the search query string */
+    source: LavaSrcSearchPlatformBase;
+    /** The Types to filter the search to */
+    types?: LavaSearchType[];
+};
+type Awaitable<T> = Promise<T> | T;
 
 /**
  * Lavalink Node creator class
@@ -2317,6 +2191,7 @@ declare enum ReconnectionState {
 declare class LavalinkNode {
     private heartBeatPingTimestamp;
     private heartBeatPongTimestamp;
+    get heartBeatPing(): number;
     private heartBeatInterval?;
     private pingTimeout?;
     isAlive: boolean;
@@ -2335,64 +2210,18 @@ declare class LavalinkNode {
     };
     /** Actual Lavalink Information of the Node */
     info: LavalinkInfo | null;
-    /** current state of the Reconnections */
-    reconnectionState: ReconnectionState;
     /** The Node Manager of this Node */
     private NodeManager;
     /** The Reconnection Timeout */
     private reconnectTimeout?;
-    /** The Reconnection Attempt counter (array of datetimes when it tried it.) */
+    /** The Reconnection Attempt counter */
     private reconnectAttempts;
+    /** Reconnection current state */
+    private reconnectionState;
     /** The Socket of the Lavalink */
     private socket;
     /** Version of what the Lavalink Server should be */
     private version;
-    /**
-     * Returns the LavalinkManager of the Node
-     */
-    private get _LManager();
-    /**
-     * Returns the Heartbeat Ping of the Node
-     */
-    get heartBeatPing(): number;
-    /**
-     * Returns wether the plugin validations are enabled or not
-     */
-    private get _checkForPlugins();
-    /**
-     * Returns wether the source validations are enabled or not
-     */
-    private get _checkForSources();
-    /**
-     * Emits a debug event to the LavalinkManager
-     * @param name name of the event
-     * @param eventData event data
-     */
-    private _emitDebugEvent;
-    /**
-     * Returns if connected to the Node.
-     *
-     * @example
-     * ```ts
-     * const isConnected = player.node.connected;
-     * console.log("node is connected: ", isConnected ? "yes" : "no")
-     * ```
-     */
-    get connected(): boolean;
-    /**
-     * Returns the current ConnectionStatus
-     *
-     * @example
-     * ```ts
-     * try {
-     *     const statusOfConnection = player.node.connectionStatus;
-     *     console.log("node's connection status is:", statusOfConnection)
-     * } catch (error) {
-     *     console.error("no socket available?", error)
-     * }
-     * ```
-     */
-    get connectionStatus(): string;
     /**
      * Create a new Node
      * @param options Lavalink Node Options
@@ -2538,10 +2367,34 @@ declare class LavalinkNode {
      *
      * @example
      * ```ts
-     * player.node.disconnect("Forcefully disconnect the connection to the node.");
+     * player.node.destroy("custom Player Destroy Reason", true);
      * ```
      */
     disconnect(disconnectReason?: DisconnectReasonsType): void;
+    /**
+     * Returns if connected to the Node.
+     *
+     * @example
+     * ```ts
+     * const isConnected = player.node.connected;
+     * console.log("node is connected: ", isConnected ? "yes" : "no")
+     * ```
+     */
+    get connected(): boolean;
+    /**
+     * Returns the current ConnectionStatus
+     *
+     * @example
+     * ```ts
+     * try {
+     *     const statusOfConnection = player.node.connectionStatus;
+     *     console.log("node's connection status is:", statusOfConnection)
+     * } catch (error) {
+     *     console.error("no socket available?", error)
+     * }
+     * ```
+     */
+    get connectionStatus(): string;
     /**
      * Gets all Players of a Node
      * @returns array of players inside of lavalink
@@ -2675,16 +2528,6 @@ declare class LavalinkNode {
      * ```
      */
     fetchStats(): Promise<BaseNodeStats>;
-    /**
-     * Request NodeLink connection metrics. https://nodelink.js.org/docs/differences#connection-metrics
-     * @returns the connection metrics of the node
-     *
-     * @example
-     * ```ts
-     * const connectionMetrics = await player.node.fetchConnectionMetrics();
-     * ```
-     */
-    fetchConnectionMetrics(): Promise<NodeLinkConnectionMetrics>;
     /**
      * Request Lavalink version.
      * @returns the current used lavalink version
@@ -2758,26 +2601,17 @@ declare class LavalinkNode {
      * Get the rest Adress for making requests
      */
     private get restAddress();
-    /**
-     * If already trying to reconnect or pending, return
-     */
-    get isNodeReconnecting(): boolean;
     /**
      * Reconnect to the lavalink node
-     * @param force @default false Wether to instantly try to reconnect (force it)
+     * @param instaReconnect @default false wether to instantly try to reconnect
      * @returns void
      *
      * @example
      * ```ts
-     * await player.node.reconnect(true); //true forcefully trys the reconnect
+     * await player.node.reconnect();
      * ```
      */
     private reconnect;
-    get reconnectionAttemptCount(): number;
-    /**
-     * Private Utility function to execute the reconnection
-    */
-    private executeReconnect;
     /**
      * Private function to reset the reconnection attempts
      * @returns
@@ -2800,14 +2634,6 @@ declare class LavalinkNode {
     private message;
     /** @private middleware util function for handling all kind of events from websocket */
     private handleEvent;
-    /**
-     * nodeLink specific events handling https://nodelink.js.org/docs/api/websocket#incoming-events-server--client
-     * @param eventName
-     * @param player
-     * @param track
-     * @param payload
-     */
-    private nodeLinkEventHandler;
     private getTrackOfPayload;
     /** @private util function for handling trackStart event */
     private trackStart;
@@ -3238,13 +3064,6 @@ interface ManagerOptions<CustomPlayerT extends Player = Player> {
     linksBlacklist?: (RegExp | string)[];
     /** If links should be allowed or not. If set to false, it will throw an error if a link was provided. */
     linksAllowed?: boolean;
-    /** If the library should automatically check something, on default everything is enabled */
-    autoChecks?: {
-        /** Wether or not the client should check if the requested source's plugin is available on the node. */
-        pluginValidations?: boolean;
-        /** Wether or not the client should check if the requested source is available on the node */
-        sourcesValidations?: boolean;
-    };
     /** Advanced Options for the Library, which may or may not be "library breaking" */
     advancedOptions?: {
         /** Max duration for that the filter fix duration works (in ms) - default is 8mins */
@@ -3325,12 +3144,6 @@ declare class LavalinkManager<CustomPlayerT extends Player = Player> extends Eve
      * @param options
      */
     private validateOptions;
-    /**
-     * Emits a debug event to the LavalinkManager
-     * @param name name of the event
-     * @param eventData event data
-     */
-    private _emitDebugEvent;
     /**
      * Create the Lavalink Manager
      * @param options
@@ -3515,4 +3328,4 @@ declare const LavalinkPlugins: {
 /** Lavalink Sources regexes for url validations */
 declare const SourceLinksRegexes: Record<SourcesRegex, RegExp>;
 
-export { type AudioOutputs, type Awaitable, type Base64, type BaseNodeStats, type BasePlayOptions, type BotClientOptions, type CPUStats, type ChannelDeletePacket, type ChannelMixFilter, type ClientCustomSearchPlatformUtils, type ClientSearchPlatform, DebugEvents, type DeepRequired, DefaultQueueStore, DefaultSources, DestroyReasons, type DestroyReasonsType, DisconnectReasons, type DisconnectReasonsType, type DistortionFilter, type DuncteSearchPlatform, type EQBand, EQList, type Exception, type FailingAddress, type FilterData, FilterManager, type FloatNumber, type FrameStats, type GitObject, type GuildShardPayload, type IntegerNumber, type InvalidLavalinkRestRequest, type JioSaavnSearchPlatform, type KaraokeFilter, type LavaSearchFilteredResponse, type LavaSearchQuery, type LavaSearchResponse, type LavaSearchType, type LavaSrcSearchPlatform, type LavaSrcSearchPlatformBase, type LavalinkClientSearchPlatform, type LavalinkClientSearchPlatformResolve, type LavalinkFilterData, type LavalinkInfo, LavalinkManager, type LavalinkManagerEvents, LavalinkNode, type LavalinkNodeIdentifier, type LavalinkNodeOptions, type LavalinkPlayOptions, type LavalinkPlayer, type LavalinkPlayerVoice, type LavalinkPlayerVoiceOptions, type LavalinkPlugin_JioSaavn_SourceNames, type LavalinkPlugin_LavaSrc_SourceNames, LavalinkPlugins, type LavalinkSearchPlatform, type LavalinkSourceNames, type LavalinkTrack, type LavalinkTrackInfo, type LoadTypes, type LowPassFilter, type LyricsEvent, type LyricsEventType, type LyricsFoundEvent, type LyricsLine, type LyricsLineEvent, type LyricsNotFoundEvent, type LyricsResult, type ManagerOptions, type ManagerPlayerOptions, type ManagerQueueOptions, ManagerUtils, type MemoryStats, MiniMap, type MiniMapConstructor, type ModifyRequest, type NodeLinkConnectionMetrics, NodeManager, type NodeManagerEvents, type NodeMessage, type NodeStats, NodeSymbol, type Opaque, type PlayOptions, Player, type PlayerEvent, type PlayerEventType, type PlayerEvents, type PlayerFilters, type PlayerJson, type PlayerOptions, type PlayerUpdateInfo, type PlaylistInfo, type PluginInfo, type PluginObject, Queue, type QueueChangesWatcher, QueueSaver, type QueueStoreManager, QueueSymbol, ReconnectionState, type RepeatMode, type RequiredManagerOptions, type RotationFilter, type RoutePlanner, type RoutePlannerTypes, type SearchPlatform, type SearchQuery, type SearchResult, type Session, type Severity, SourceLinksRegexes, type SourceNames, type SourcesRegex, type SponsorBlockChapterStarted, type SponsorBlockChaptersLoaded, type SponsorBlockSegment, type SponsorBlockSegmentEventType, type SponsorBlockSegmentEvents, type SponsorBlockSegmentSkipped, type SponsorBlockSegmentsLoaded, type State, type StoredQueue, type TimescaleFilter, type Track, type TrackEndEvent, type TrackEndReason, type TrackExceptionEvent, type TrackInfo, type TrackStartEvent, type TrackStuckEvent, TrackSymbol, type TremoloFilter, type UnresolvedQuery, type UnresolvedSearchResult, type UnresolvedTrack, type UnresolvedTrackInfo, UnresolvedTrackSymbol, type VersionObject, type VibratoFilter, type VoicePacket, type VoiceServer, type VoiceState, type WebSocketClosedEvent, type anyObject, audioOutputsData, parseLavalinkConnUrl, queueTrackEnd, safeStringify, validSponsorBlocks };
+export { type AudioOutputs, type Awaitable, type Base64, type BaseNodeStats, type BasePlayOptions, type BotClientOptions, type CPUStats, type ChannelDeletePacket, type ChannelMixFilter, type ClientCustomSearchPlatformUtils, type ClientSearchPlatform, DebugEvents, type DeepRequired, DefaultQueueStore, DefaultSources, DestroyReasons, type DestroyReasonsType, DisconnectReasons, type DisconnectReasonsType, type DistortionFilter, type DuncteSearchPlatform, type EQBand, EQList, type Exception, type FailingAddress, type FilterData, FilterManager, type FloatNumber, type FrameStats, type GitObject, type GuildShardPayload, type IntegerNumber, type InvalidLavalinkRestRequest, type JioSaavnSearchPlatform, type KaraokeFilter, type LavaSearchFilteredResponse, type LavaSearchQuery, type LavaSearchResponse, type LavaSearchType, type LavaSrcSearchPlatform, type LavaSrcSearchPlatformBase, type LavalinkClientSearchPlatform, type LavalinkClientSearchPlatformResolve, type LavalinkFilterData, type LavalinkInfo, LavalinkManager, type LavalinkManagerEvents, LavalinkNode, type LavalinkNodeIdentifier, type LavalinkNodeOptions, type LavalinkPlayOptions, type LavalinkPlayer, type LavalinkPlayerVoice, type LavalinkPlayerVoiceOptions, type LavalinkPlugin_JioSaavn_SourceNames, type LavalinkPlugin_LavaSrc_SourceNames, LavalinkPlugins, type LavalinkSearchPlatform, type LavalinkSourceNames, type LavalinkTrack, type LavalinkTrackInfo, type LoadTypes, type LowPassFilter, type LyricsEvent, type LyricsEventType, type LyricsFoundEvent, type LyricsLine, type LyricsLineEvent, type LyricsNotFoundEvent, type LyricsResult, type ManagerOptions, type ManagerPlayerOptions, type ManagerQueueOptions, ManagerUtils, type MemoryStats, MiniMap, type MiniMapConstructor, type ModifyRequest, NodeManager, type NodeManagerEvents, type NodeMessage, type NodeStats, NodeSymbol, type Opaque, type PlayOptions, Player, type PlayerEvent, type PlayerEventType, type PlayerEvents, type PlayerFilters, type PlayerJson, type PlayerOptions, type PlayerUpdateInfo, type PlaylistInfo, type PluginInfo, type PluginObject, Queue, type QueueChangesWatcher, QueueSaver, type QueueStoreManager, QueueSymbol, ReconnectionState, type RepeatMode, type RequiredManagerOptions, type RotationFilter, type RoutePlanner, type RoutePlannerTypes, type SearchPlatform, type SearchQuery, type SearchResult, type Session, type Severity, SourceLinksRegexes, type SourceNames, type SourcesRegex, type SponsorBlockChapterStarted, type SponsorBlockChaptersLoaded, type SponsorBlockSegment, type SponsorBlockSegmentEventType, type SponsorBlockSegmentEvents, type SponsorBlockSegmentSkipped, type SponsorBlockSegmentsLoaded, type State, type StoredQueue, type TimescaleFilter, type Track, type TrackEndEvent, type TrackEndReason, type TrackExceptionEvent, type TrackInfo, type TrackStartEvent, type TrackStuckEvent, TrackSymbol, type TremoloFilter, type UnresolvedQuery, type UnresolvedSearchResult, type UnresolvedTrack, type UnresolvedTrackInfo, UnresolvedTrackSymbol, type VersionObject, type VibratoFilter, type VoicePacket, type VoiceServer, type VoiceState, type WebSocketClosedEvent, type anyObject, audioOutputsData, parseLavalinkConnUrl, queueTrackEnd, safeStringify, validSponsorBlocks };
diff --git a/node_modules/lavalink-client/dist/index.js b/node_modules/lavalink-client/dist/index.js
index 0866345..0b7473e 100644
--- a/node_modules/lavalink-client/dist/index.js
+++ b/node_modules/lavalink-client/dist/index.js
@@ -105,9 +105,6 @@ var DebugEvents = /* @__PURE__ */ ((DebugEvents2) => {
   DebugEvents2["FailedToConnectToNodes"] = "FailedToConnectToNodes";
   DebugEvents2["NoAudioDebug"] = "NoAudioDebug";
   DebugEvents2["PlayerAutoReconnect"] = "PlayerAutoReconnect";
-  DebugEvents2["PlayerDestroyFail"] = "PlayerDestroyFail";
-  DebugEvents2["PlayerChangeNodeFailNoEligibleNode"] = "PlayerChangeNodeFailNoEligibleNode";
-  DebugEvents2["PlayerChangeNodeFail"] = "PlayerChangeNodeFail";
   return DebugEvents2;
 })(DebugEvents || {});
 var DestroyReasons = /* @__PURE__ */ ((DestroyReasons2) => {
@@ -371,15 +368,6 @@ var import_events = require("events");
 var import_path = require("path");
 var import_ws = __toESM(require("ws"));
 
-// src/structures/Types/Node.ts
-var ReconnectionState = /* @__PURE__ */ ((ReconnectionState2) => {
-  ReconnectionState2["IDLE"] = "IDLE";
-  ReconnectionState2["RECONNECTING"] = "RECONNECTING";
-  ReconnectionState2["PENDING"] = "PENDING";
-  ReconnectionState2["DESTROYING"] = "DESTROYING";
-  return ReconnectionState2;
-})(ReconnectionState || {});
-
 // src/structures/Utils.ts
 var import_node_url = require("url");
 var import_types = require("util/types");
@@ -544,10 +532,10 @@ var SourceLinksRegexes = {
 };
 
 // src/structures/Utils.ts
-var TrackSymbol = Symbol("LC-Track");
-var UnresolvedTrackSymbol = Symbol("LC-Track-Unresolved");
-var QueueSymbol = Symbol("LC-Queue");
-var NodeSymbol = Symbol("LC-Node");
+var TrackSymbol = /* @__PURE__ */ Symbol("LC-Track");
+var UnresolvedTrackSymbol = /* @__PURE__ */ Symbol("LC-Track-Unresolved");
+var QueueSymbol = /* @__PURE__ */ Symbol("LC-Queue");
+var NodeSymbol = /* @__PURE__ */ Symbol("LC-Node");
 var escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
 function parseLavalinkConnUrl(connectionUrl) {
   if (!connectionUrl.startsWith("lavalink://")) throw new Error(`ConnectionUrl (${connectionUrl}) must start with 'lavalink://'`);
@@ -751,7 +739,7 @@ var ManagerUtils = class {
   }
   validateQueryString(node, queryString, sourceString) {
     if (!node.info) throw new Error("No Lavalink Node was provided");
-    if (this.LavalinkManager.options?.autoChecks?.sourcesValidations && !node.info.sourceManagers?.length) throw new Error("Lavalink Node, has no sourceManagers enabled");
+    if (!node.info.sourceManagers?.length) throw new Error("Lavalink Node, has no sourceManagers enabled");
     if (!queryString.trim().length) throw new Error(`Query string is empty, please provide a valid query string.`);
     if (sourceString === "speak" && queryString.length > 100) throw new Error(`Query is speak, which is limited to 100 characters.`);
     if (this.LavalinkManager.options?.linksBlacklist?.length > 0) {
@@ -780,7 +768,6 @@ var ManagerUtils = class {
         throw new Error(`Query string contains a link / word which isn't whitelisted.`);
       }
     }
-    if (!this.LavalinkManager.options?.autoChecks?.sourcesValidations) return;
     if ((SourceLinksRegexes.YoutubeMusicRegex.test(queryString) || SourceLinksRegexes.YoutubeRegex.test(queryString)) && !node.info?.sourceManagers?.includes("youtube")) {
       throw new Error("Query / Link Provided for this Source but Lavalink Node has not 'youtube' enabled");
     }
@@ -864,7 +851,6 @@ var ManagerUtils = class {
     const source = DefaultSources[sourceString.toLowerCase().trim()];
     if (!source) throw new Error(`Lavalink Node SearchQuerySource: '${sourceString}' is not available`);
     if (!node.info) throw new Error("Lavalink Node does not have any info cached yet, not ready yet!");
-    if (!this.LavalinkManager.options?.autoChecks?.sourcesValidations) return;
     if (source === "amsearch" && !node.info?.sourceManagers?.includes("applemusic")) {
       throw new Error("Lavalink Node has not 'applemusic' enabled, which is required to have 'amsearch' work");
     }
@@ -886,7 +872,7 @@ var ManagerUtils = class {
     if (source === "scsearch" && !node.info?.sourceManagers?.includes("soundcloud")) {
       throw new Error("Lavalink Node has not 'soundcloud' enabled, which is required to have 'scsearch' work");
     }
-    if (source === "speak" && this.LavalinkManager.options?.autoChecks?.pluginValidations && !node.info?.plugins?.find((c) => c.name.toLowerCase().includes(LavalinkPlugins.DuncteBot_Plugin.toLowerCase()))) {
+    if (source === "speak" && !node.info?.plugins?.find((c) => c.name.toLowerCase().includes(LavalinkPlugins.DuncteBot_Plugin.toLowerCase()))) {
       throw new Error("Lavalink Node has not 'speak' enabled, which is required to have 'speak' work");
     }
     if (source === "tdsearch" && !node.info?.sourceManagers?.includes("tidal")) {
@@ -895,7 +881,7 @@ var ManagerUtils = class {
     if (source === "tdrec" && !node.info?.sourceManagers?.includes("tidal")) {
       throw new Error("Lavalink Node has not 'tidal' enabled, which is required to have 'tdrec' work");
     }
-    if (source === "tts" && this.LavalinkManager.options?.autoChecks?.pluginValidations && !node.info?.plugins?.find((c) => c.name.toLowerCase().includes(LavalinkPlugins.GoogleCloudTTS.toLowerCase()))) {
+    if (source === "tts" && !node.info?.plugins?.find((c) => c.name.toLowerCase().includes(LavalinkPlugins.GoogleCloudTTS.toLowerCase()))) {
       throw new Error("Lavalink Node has not 'tts' enabled, which is required to have 'tts' work");
     }
     if (source === "ftts" && !(node.info?.sourceManagers?.includes("ftts") || node.info?.sourceManagers?.includes("flowery-tts") || node.info?.sourceManagers?.includes("flowerytts"))) {
@@ -904,7 +890,7 @@ var ManagerUtils = class {
     if (source === "ymsearch" && !node.info?.sourceManagers?.includes("yandexmusic")) {
       throw new Error("Lavalink Node has not 'yandexmusic' enabled, which is required to have 'ymsearch' work");
     }
-    if (source === "ytmsearch" && !node.info?.sourceManagers?.includes("youtube")) {
+    if (source === "ytmsearch" && !node.info.sourceManagers?.includes("youtube")) {
       throw new Error("Lavalink Node has not 'youtube' enabled, which is required to have 'ytmsearch' work");
     }
     if (source === "ytsearch" && !node.info?.sourceManagers?.includes("youtube")) {
@@ -1043,10 +1029,22 @@ function safeStringify(obj, padding = 0) {
   }, padding);
 }
 
+// src/structures/Types/Node.ts
+var ReconnectionState = /* @__PURE__ */ ((ReconnectionState2) => {
+  ReconnectionState2["IDLE"] = "IDLE";
+  ReconnectionState2["RECONNECTING"] = "RECONNECTING";
+  ReconnectionState2["PENDING"] = "PENDING";
+  ReconnectionState2["DESTROYING"] = "DESTROYING";
+  return ReconnectionState2;
+})(ReconnectionState || {});
+
 // src/structures/Node.ts
 var LavalinkNode = class {
   heartBeatPingTimestamp = 0;
   heartBeatPongTimestamp = 0;
+  get heartBeatPing() {
+    return this.heartBeatPongTimestamp - this.heartBeatPingTimestamp;
+  }
   heartBeatInterval;
   pingTimeout;
   isAlive = false;
@@ -1070,17 +1068,6 @@ var LavalinkNode = class {
       used: 0
     },
     uptime: 0,
-    /** something from nodeLink https://nodelink.js.org/docs/differences#detailed-statistics */
-    detailedStats: {
-      api: {
-        requests: {},
-        errors: {}
-      },
-      sources: {},
-      playback: {
-        events: {}
-      }
-    },
     frameStats: {
       deficit: 0,
       nulled: 0,
@@ -1093,80 +1080,18 @@ var LavalinkNode = class {
   resuming = { enabled: true, timeout: null };
   /** Actual Lavalink Information of the Node */
   info = null;
-  /** current state of the Reconnections */
-  reconnectionState = "IDLE" /* IDLE */;
   /** The Node Manager of this Node */
   NodeManager = null;
   /** The Reconnection Timeout */
   reconnectTimeout = void 0;
-  /** The Reconnection Attempt counter (array of datetimes when it tried it.) */
-  reconnectAttempts = [];
+  /** The Reconnection Attempt counter */
+  reconnectAttempts = 1;
+  /** Reconnection current state */
+  reconnectionState = "IDLE" /* IDLE */;
   /** The Socket of the Lavalink */
   socket = null;
   /** Version of what the Lavalink Server should be */
   version = "v4";
-  /**
-   * Returns the LavalinkManager of the Node
-   */
-  get _LManager() {
-    return this.NodeManager.LavalinkManager;
-  }
-  /**
-   * Returns the Heartbeat Ping of the Node
-   */
-  get heartBeatPing() {
-    return this.heartBeatPongTimestamp - this.heartBeatPingTimestamp;
-  }
-  /**
-   * Returns wether the plugin validations are enabled or not
-   */
-  get _checkForPlugins() {
-    return !!this._LManager.options?.autoChecks?.pluginValidations;
-  }
-  /**
-   * Returns wether the source validations are enabled or not
-   */
-  get _checkForSources() {
-    return !!this._LManager.options?.autoChecks?.sourcesValidations;
-  }
-  /**
-   * Emits a debug event to the LavalinkManager
-   * @param name name of the event
-   * @param eventData event data
-   */
-  _emitDebugEvent(name, eventData) {
-    if (!this._LManager.options?.advancedOptions?.enableDebugEvents) return;
-    this._LManager.emit("debug", name, eventData);
-  }
-  /**
-   * Returns if connected to the Node.
-   *
-   * @example
-   * ```ts
-   * const isConnected = player.node.connected;
-   * console.log("node is connected: ", isConnected ? "yes" : "no")
-   * ```
-   */
-  get connected() {
-    return this.socket && this.socket.readyState === import_ws.default.OPEN;
-  }
-  /**
-   * Returns the current ConnectionStatus
-   *
-   * @example
-   * ```ts
-   * try {
-   *     const statusOfConnection = player.node.connectionStatus;
-   *     console.log("node's connection status is:", statusOfConnection)
-   * } catch (error) {
-   *     console.error("no socket available?", error)
-   * }
-   * ```
-   */
-  get connectionStatus() {
-    if (!this.socket) throw new Error("no websocket was initialized yet");
-    return ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][this.socket.readyState] || "UNKNOWN";
-  }
   /**
    * Create a new Node
    * @param options Lavalink Node Options
@@ -1185,7 +1110,6 @@ var LavalinkNode = class {
       secure: false,
       retryAmount: 5,
       retryDelay: 1e4,
-      retryTimespan: -1,
       requestSignalTimeoutMS: 1e4,
       heartBeatInterval: 3e4,
       closeOnError: true,
@@ -1256,10 +1180,10 @@ var LavalinkNode = class {
    * ```
    */
   async search(query, requestUser, throwOnEmpty = false) {
-    const Query = this._LManager.utils.transformQuery(query);
-    this._LManager.utils.validateQueryString(this, Query.query, Query.source);
-    if (Query.source) this._LManager.utils.validateSourceString(this, Query.source);
-    if (["bcsearch", "bandcamp"].includes(Query.source) && this._LManager.options?.autoChecks?.sourcesValidations && !this.info.sourceManagers.includes("bandcamp")) {
+    const Query = this.NodeManager.LavalinkManager.utils.transformQuery(query);
+    this.NodeManager.LavalinkManager.utils.validateQueryString(this, Query.query, Query.source);
+    if (Query.source) this.NodeManager.LavalinkManager.utils.validateSourceString(this, Query.source);
+    if (["bcsearch", "bandcamp"].includes(Query.source) && !this.info.sourceManagers.includes("bandcamp")) {
       throw new Error("Bandcamp Search only works on the player (lavaplayer version < 2.2.0!");
     }
     const requestUrl = new URL(`${this.restAddress}/loadtracks`);
@@ -1278,11 +1202,13 @@ var LavalinkNode = class {
     });
     const resTracks = res.loadType === "playlist" ? res.data?.tracks : res.loadType === "track" ? [res.data] : res.loadType === "search" ? Array.isArray(res.data) ? res.data : [res.data] : [];
     if (throwOnEmpty === true && (res.loadType === "empty" || !resTracks.length)) {
-      this._emitDebugEvent("SearchNothingFound" /* SearchNothingFound */, {
-        state: "warn",
-        message: `Search found nothing for Request: "${Query.source ? `${Query.source}:` : ""}${Query.query}"`,
-        functionLayer: "(LavalinkNode > node | player) > search()"
-      });
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "SearchNothingFound" /* SearchNothingFound */, {
+          state: "warn",
+          message: `Search found nothing for Request: "${Query.source ? `${Query.source}:` : ""}${Query.query}"`,
+          functionLayer: "(LavalinkNode > node | player) > search()"
+        });
+      }
       throw new Error("Nothing found");
     }
     return {
@@ -1295,10 +1221,10 @@ var LavalinkNode = class {
         author: res.data.info?.author || res.data.pluginInfo?.author || null,
         thumbnail: res.data.info?.artworkUrl || res.data.pluginInfo?.artworkUrl || (typeof res.data?.info?.selectedTrack !== "number" || res.data?.info?.selectedTrack === -1 ? null : resTracks[res.data?.info?.selectedTrack] ? resTracks[res.data?.info?.selectedTrack]?.info?.artworkUrl || resTracks[res.data?.info?.selectedTrack]?.info?.pluginInfo?.artworkUrl : null) || null,
         uri: res.data.info?.url || res.data.info?.uri || res.data.info?.link || res.data.pluginInfo?.url || res.data.pluginInfo?.uri || res.data.pluginInfo?.link || null,
-        selectedTrack: typeof res.data?.info?.selectedTrack !== "number" || res.data?.info?.selectedTrack === -1 ? null : resTracks[res.data?.info?.selectedTrack] ? this._LManager.utils.buildTrack(resTracks[res.data?.info?.selectedTrack], requestUser) : null,
+        selectedTrack: typeof res.data?.info?.selectedTrack !== "number" || res.data?.info?.selectedTrack === -1 ? null : resTracks[res.data?.info?.selectedTrack] ? this.NodeManager.LavalinkManager.utils.buildTrack(resTracks[res.data?.info?.selectedTrack], requestUser) : null,
         duration: resTracks.length ? resTracks.reduce((acc, cur) => acc + (cur?.info?.duration || cur?.info?.length || 0), 0) : 0
       } : null,
-      tracks: resTracks.length ? resTracks.map((t) => this._LManager.utils.buildTrack(t, requestUser)) : []
+      tracks: resTracks.length ? resTracks.map((t) => this.NodeManager.LavalinkManager.utils.buildTrack(t, requestUser)) : []
     };
   }
   /**
@@ -1315,27 +1241,29 @@ var LavalinkNode = class {
    * ```
    */
   async lavaSearch(query, requestUser, throwOnEmpty = false) {
-    const Query = this._LManager.utils.transformLavaSearchQuery(query);
-    if (Query.source) this._LManager.utils.validateSourceString(this, Query.source);
+    const Query = this.NodeManager.LavalinkManager.utils.transformLavaSearchQuery(query);
+    if (Query.source) this.NodeManager.LavalinkManager.utils.validateSourceString(this, Query.source);
     if (/^https?:\/\//.test(Query.query)) return this.search({ query: Query.query, source: Query.source }, requestUser);
     if (!["spsearch", "sprec", "amsearch", "dzsearch", "dzisrc", "ytmsearch", "ytsearch"].includes(Query.source)) throw new SyntaxError(`Query.source must be a source from LavaSrc: "spsearch" | "sprec" | "amsearch" | "dzsearch" | "dzisrc" | "ytmsearch" | "ytsearch"`);
-    if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavasearch-plugin")) throw new RangeError(`there is no lavasearch-plugin available in the lavalink node: ${this.id}`);
-    if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavasrc-plugin")) throw new RangeError(`there is no lavasrc-plugin available in the lavalink node: ${this.id}`);
+    if (!this.info.plugins.find((v) => v.name === "lavasearch-plugin")) throw new RangeError(`there is no lavasearch-plugin available in the lavalink node: ${this.id}`);
+    if (!this.info.plugins.find((v) => v.name === "lavasrc-plugin")) throw new RangeError(`there is no lavasrc-plugin available in the lavalink node: ${this.id}`);
     const { response } = await this.rawRequest(`/loadsearch?query=${Query.source ? `${Query.source}:` : ""}${encodeURIComponent(Query.query)}${Query.types?.length ? `&types=${Query.types.join(",")}` : ""}`);
     const res = response.status === 204 ? {} : await response.json();
     if (throwOnEmpty === true && !Object.entries(res).flat().filter(Boolean).length) {
-      this._emitDebugEvent("LavaSearchNothingFound" /* LavaSearchNothingFound */, {
-        state: "warn",
-        message: `LavaSearch found nothing for Request: "${Query.source ? `${Query.source}:` : ""}${Query.query}"`,
-        functionLayer: "(LavalinkNode > node | player) > lavaSearch()"
-      });
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "LavaSearchNothingFound" /* LavaSearchNothingFound */, {
+          state: "warn",
+          message: `LavaSearch found nothing for Request: "${Query.source ? `${Query.source}:` : ""}${Query.query}"`,
+          functionLayer: "(LavalinkNode > node | player) > lavaSearch()"
+        });
+      }
       throw new Error("Nothing found");
     }
     return {
-      tracks: res.tracks?.map((v) => this._LManager.utils.buildTrack(v, requestUser)) || [],
-      albums: res.albums?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this._LManager.utils.buildTrack(v2, requestUser)) })) || [],
-      artists: res.artists?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this._LManager.utils.buildTrack(v2, requestUser)) })) || [],
-      playlists: res.playlists?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this._LManager.utils.buildTrack(v2, requestUser)) })) || [],
+      tracks: res.tracks?.map((v) => this.NodeManager.LavalinkManager.utils.buildTrack(v, requestUser)) || [],
+      albums: res.albums?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this.NodeManager.LavalinkManager.utils.buildTrack(v2, requestUser)) })) || [],
+      artists: res.artists?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this.NodeManager.LavalinkManager.utils.buildTrack(v2, requestUser)) })) || [],
+      playlists: res.playlists?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this.NodeManager.LavalinkManager.utils.buildTrack(v2, requestUser)) })) || [],
       texts: res.texts?.map((v) => ({ text: v.text, pluginInfo: v?.plugin || v.pluginInfo })) || [],
       pluginInfo: res.pluginInfo || res?.plugin
     };
@@ -1364,11 +1292,13 @@ var LavalinkNode = class {
         r.path = url.pathname + url.search;
       }
     });
-    this._emitDebugEvent("PlayerUpdateSuccess" /* PlayerUpdateSuccess */, {
-      state: "log",
-      message: `Player get's updated with following payload :: ${safeStringify(data.playerOptions, 3)}`,
-      functionLayer: "LavalinkNode > node > updatePlayer()"
-    });
+    if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.NodeManager.LavalinkManager.emit("debug", "PlayerUpdateSuccess" /* PlayerUpdateSuccess */, {
+        state: "log",
+        message: `Player get's updated with following payload :: ${safeStringify(data.playerOptions, 3)}`,
+        functionLayer: "LavalinkNode > node > updatePlayer()"
+      });
+    }
     this.syncPlayerData({}, res);
     return res;
   }
@@ -1404,17 +1334,19 @@ var LavalinkNode = class {
    */
   connect(sessionId) {
     if (this.connected) {
-      this._emitDebugEvent("TryingConnectWhileConnected" /* TryingConnectWhileConnected */, {
-        state: "warn",
-        message: `Tryed to connect to node, but it's already connected!`,
-        functionLayer: "LavalinkNode > node > connect()"
-      });
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "TryingConnectWhileConnected" /* TryingConnectWhileConnected */, {
+          state: "warn",
+          message: `Tryed to connect to node, but it's already connected!`,
+          functionLayer: "LavalinkNode > node > connect()"
+        });
+      }
       return;
     }
     const headers = {
       Authorization: this.options.authorization,
-      "User-Id": this._LManager.options.client.id,
-      "Client-Name": this._LManager.options.client.username || "Lavalink-Client"
+      "User-Id": this.NodeManager.LavalinkManager.options.client.id,
+      "Client-Name": this.NodeManager.LavalinkManager.options.client.username || "Lavalink-Client"
     };
     if (typeof this.options.sessionId === "string" || typeof sessionId === "string") {
       headers["Session-Id"] = this.options.sessionId || sessionId;
@@ -1427,27 +1359,33 @@ var LavalinkNode = class {
     this.socket.on("error", this.error.bind(this));
   }
   heartBeat() {
-    this._emitDebugEvent("HeartBeatTriggered" /* HeartBeatTriggered */, {
-      state: "log",
-      message: `Node Socket Heartbeat triggered, resetting old Timeout to 65000ms (should happen every 60s due to /stats event)`,
-      functionLayer: "LavalinkNode > nodeEvent > stats > heartBeat()"
-    });
+    if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.NodeManager.LavalinkManager.emit("debug", "HeartBeatTriggered" /* HeartBeatTriggered */, {
+        state: "log",
+        message: `Node Socket Heartbeat triggered, resetting old Timeout to 65000ms (should happen every 60s due to /stats event)`,
+        functionLayer: "LavalinkNode > nodeEvent > stats > heartBeat()"
+      });
+    }
     this.resetAckTimeouts(false, true);
-    if (this.pingTimeout) clearTimeout(this.pingTimeout);
     this.pingTimeout = setTimeout(() => {
       this.pingTimeout = null;
       if (!this.socket) {
-        return this._emitDebugEvent("NoSocketOnDestroy" /* NoSocketOnDestroy */, {
-          state: "error",
-          message: `Heartbeat registered a disconnect, but socket didn't exist therefore can't terminate`,
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "NoSocketOnDestroy" /* NoSocketOnDestroy */, {
+            state: "error",
+            message: `Heartbeat registered a disconnect, but socket didn't exist therefore can't terminate`,
+            functionLayer: "LavalinkNode > nodeEvent > stats > heartBeat() > timeoutHit"
+          });
+        }
+        return;
+      }
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "SocketTerminateHeartBeatTimeout" /* SocketTerminateHeartBeatTimeout */, {
+          state: "warn",
+          message: `Heartbeat registered a disconnect, because timeout wasn't resetted in time. Terminating Web-Socket`,
           functionLayer: "LavalinkNode > nodeEvent > stats > heartBeat() > timeoutHit"
         });
       }
-      this._emitDebugEvent("SocketTerminateHeartBeatTimeout" /* SocketTerminateHeartBeatTimeout */, {
-        state: "warn",
-        message: `Heartbeat registered a disconnect, because timeout wasn't resetted in time. Terminating Web-Socket`,
-        functionLayer: "LavalinkNode > nodeEvent > stats > heartBeat() > timeoutHit"
-      });
       this.isAlive = false;
       this.socket.terminate();
     }, 65e3);
@@ -1483,75 +1421,71 @@ var LavalinkNode = class {
    */
   destroy(destroyReason, deleteNode = true, movePlayers = false) {
     this.reconnectionState = "IDLE" /* IDLE */;
-    const players = this._LManager.players.filter((p) => p.node.id === this.id);
-    if (!players?.size) {
+    const players = this.NodeManager.LavalinkManager.players.filter((p) => p.node.id === this.id);
+    if (players.size) {
+      const enableDebugEvents = this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents;
+      const handlePlayerOperations = () => {
+        if (movePlayers) {
+          const nodeToMove = Array.from(this.NodeManager.leastUsedNodes("playingPlayers")).find((n) => n.connected && n.options.id !== this.id);
+          if (nodeToMove) {
+            return Promise.allSettled(Array.from(players.values()).map(
+              (player) => player.changeNode(nodeToMove.options.id).catch((error) => {
+                if (enableDebugEvents) {
+                  console.error(`Node > destroy() Failed to move player ${player.guildId}: ${error.message}`);
+                }
+                return player.destroy(error.message ?? "PlayerChangeNodeFail" /* PlayerChangeNodeFail */).catch((destroyError) => {
+                  if (enableDebugEvents) {
+                    console.error(`Node > destroy() Failed to destroy player ${player.guildId} after move failure: ${destroyError.message}`);
+                  }
+                });
+              })
+            ));
+          } else {
+            return Promise.allSettled(Array.from(players.values()).map(
+              (player) => player.destroy("PlayerChangeNodeFailNoEligibleNode" /* PlayerChangeNodeFailNoEligibleNode */).catch((error) => {
+                if (enableDebugEvents) {
+                  console.error(`Node > destroy() Failed to destroy player ${player.guildId}: ${error.message}`);
+                }
+              })
+            ));
+          }
+        } else {
+          return Promise.allSettled(Array.from(players.values()).map(
+            (player) => player.destroy(destroyReason || "NodeDestroy" /* NodeDestroy */).catch((error) => {
+              if (enableDebugEvents) {
+                console.error(`Node > destroy() Failed to destroy player ${player.guildId}: ${error.message}`);
+              }
+            })
+          ));
+        }
+      };
+      handlePlayerOperations().finally(() => {
+        this.socket?.close(1e3, "Node-Destroy");
+        this.socket?.removeAllListeners();
+        this.socket = null;
+        this.resetReconnectionAttempts();
+        if (deleteNode) {
+          this.NodeManager.emit("destroy", this, destroyReason);
+          this.NodeManager.nodes.delete(this.id);
+          this.resetAckTimeouts(true, true);
+        } else {
+          this.NodeManager.emit("disconnect", this, { code: 1e3, reason: destroyReason });
+        }
+      });
+    } else {
       this.socket?.close(1e3, "Node-Destroy");
       this.socket?.removeAllListeners();
       this.socket = null;
       this.resetReconnectionAttempts();
-      if (!deleteNode) return void this.NodeManager.emit("disconnect", this, { code: 1e3, reason: destroyReason });
-      ;
-      this.NodeManager.emit("destroy", this, destroyReason);
-      this.NodeManager.nodes.delete(this.id);
-      this.resetAckTimeouts(true, true);
-      return;
-    }
-    const handlePlayerOperations = () => {
-      if (!movePlayers) {
-        return Promise.allSettled(Array.from(players.values()).map(
-          (player) => player.destroy(destroyReason || "NodeDestroy" /* NodeDestroy */).catch((error) => {
-            this._emitDebugEvent("PlayerDestroyFail" /* PlayerDestroyFail */, {
-              state: "error",
-              message: `Failed to destroy player ${player.guildId}: ${error.message}`,
-              error,
-              functionLayer: "Node > destroy() > movePlayers"
-            });
-          })
-        ));
-      }
-      const nodeToMove = Array.from(this.NodeManager.leastUsedNodes("playingPlayers")).find((n) => n.connected && n.options.id !== this.id);
-      if (!nodeToMove) {
-        return Promise.allSettled(Array.from(players.values()).map(
-          (player) => player.destroy("PlayerChangeNodeFailNoEligibleNode" /* PlayerChangeNodeFailNoEligibleNode */).catch((error) => {
-            this._emitDebugEvent("PlayerChangeNodeFailNoEligibleNode" /* PlayerChangeNodeFailNoEligibleNode */, {
-              state: "error",
-              message: `Failed to destroy player ${player.guildId}: ${error.message}`,
-              error,
-              functionLayer: "Node > destroy() > movePlayers"
-            });
-          })
-        ));
+      if (deleteNode) {
+        this.NodeManager.emit("destroy", this, destroyReason);
+        this.NodeManager.nodes.delete(this.id);
+        this.resetAckTimeouts(true, true);
+      } else {
+        this.NodeManager.emit("disconnect", this, { code: 1e3, reason: destroyReason });
       }
-      return Promise.allSettled(Array.from(players.values()).map(
-        (player) => player.changeNode(nodeToMove.options.id).catch((error) => {
-          this._emitDebugEvent("PlayerChangeNodeFail" /* PlayerChangeNodeFail */, {
-            state: "error",
-            message: `Failed to move player ${player.guildId}: ${error.message}`,
-            error,
-            functionLayer: "Node > destroy() > movePlayers"
-          });
-          return player.destroy(error.message ?? "PlayerChangeNodeFail" /* PlayerChangeNodeFail */).catch((destroyError) => {
-            this._emitDebugEvent("PlayerDestroyFail" /* PlayerDestroyFail */, {
-              state: "error",
-              message: `Failed to destroy player ${player.guildId} after move failure: ${destroyError.message}`,
-              error: destroyError,
-              functionLayer: "Node > destroy() > movePlayers"
-            });
-          });
-        })
-      ));
-    };
-    return void handlePlayerOperations().finally(() => {
-      this.socket?.close(1e3, "Node-Destroy");
-      this.socket?.removeAllListeners();
-      this.socket = null;
-      this.resetReconnectionAttempts();
-      if (!deleteNode) return void this.NodeManager.emit("disconnect", this, { code: 1e3, reason: destroyReason });
-      this.NodeManager.emit("destroy", this, destroyReason);
-      this.NodeManager.nodes.delete(this.id);
-      this.resetAckTimeouts(true, true);
-      return;
-    });
+    }
+    return;
   }
   /**
    * Disconnects the Node-Connection (Websocket)
@@ -1562,7 +1496,7 @@ var LavalinkNode = class {
    *
    * @example
    * ```ts
-   * player.node.disconnect("Forcefully disconnect the connection to the node.");
+   * player.node.destroy("custom Player Destroy Reason", true);
    * ```
    */
   disconnect(disconnectReason) {
@@ -1574,6 +1508,35 @@ var LavalinkNode = class {
     this.resetReconnectionAttempts();
     this.NodeManager.emit("disconnect", this, { code: 1e3, reason: disconnectReason });
   }
+  /**
+   * Returns if connected to the Node.
+   *
+   * @example
+   * ```ts
+   * const isConnected = player.node.connected;
+   * console.log("node is connected: ", isConnected ? "yes" : "no")
+   * ```
+   */
+  get connected() {
+    return this.socket && this.socket.readyState === import_ws.default.OPEN;
+  }
+  /**
+   * Returns the current ConnectionStatus
+   *
+   * @example
+   * ```ts
+   * try {
+   *     const statusOfConnection = player.node.connectionStatus;
+   *     console.log("node's connection status is:", statusOfConnection)
+   * } catch (error) {
+   *     console.error("no socket available?", error)
+   * }
+   * ```
+   */
+  get connectionStatus() {
+    if (!this.socket) throw new Error("no websocket was initialized yet");
+    return ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][this.socket.readyState] || "UNKNOWN";
+  }
   /**
    * Gets all Players of a Node
    * @returns array of players inside of lavalink
@@ -1647,7 +1610,7 @@ var LavalinkNode = class {
      */
     singleTrack: async (encoded, requester) => {
       if (!encoded) throw new SyntaxError("No encoded (Base64 string) was provided");
-      return this._LManager.utils?.buildTrack(await this.request(`/decodetrack?encodedTrack=${encodeURIComponent(encoded.replace(/\s/g, ""))}`), requester);
+      return this.NodeManager.LavalinkManager.utils?.buildTrack(await this.request(`/decodetrack?encodedTrack=${encodeURIComponent(encoded.replace(/\s/g, ""))}`), requester);
     },
     /**
      * Decodes multiple tracks into their info
@@ -1668,7 +1631,7 @@ var LavalinkNode = class {
         r.method = "POST";
         r.body = safeStringify(encodeds);
         r.headers["Content-Type"] = "application/json";
-      }).then((r) => r.map((track) => this._LManager.utils.buildTrack(track, requester)));
+      }).then((r) => r.map((track) => this.NodeManager.LavalinkManager.utils.buildTrack(track, requester)));
     }
   };
   lyrics = {
@@ -1687,8 +1650,8 @@ var LavalinkNode = class {
      */
     get: async (track, skipTrackSource = false) => {
       if (!this.sessionId) throw new Error("the Lavalink-Node is either not ready, or not up to date!");
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavasrc-plugin") && this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "java-lyrics-plugin")) throw new RangeError(`there is no lyrics source (via lavasrc-plugin / java-lyrics-plugin) available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavasrc-plugin") && !this.info.plugins.find((v) => v.name === "java-lyrics-plugin")) throw new RangeError(`there is no lyrics source (via lavasrc-plugin / java-lyrics-plugin) available in the lavalink node (required for lyrics): ${this.id}`);
       const url = `/lyrics?track=${track.encoded}&skipTrackSource=${skipTrackSource}`;
       return await this.request(url);
     },
@@ -1707,8 +1670,8 @@ var LavalinkNode = class {
      */
     getCurrent: async (guildId, skipTrackSource = false) => {
       if (!this.sessionId) throw new Error("the Lavalink-Node is either not ready, or not up to date!");
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavasrc-plugin") && this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "java-lyrics-plugin")) throw new RangeError(`there is no lyrics source (via lavasrc-plugin / java-lyrics-plugin) available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavasrc-plugin") && !this.info.plugins.find((v) => v.name === "java-lyrics-plugin")) throw new RangeError(`there is no lyrics source (via lavasrc-plugin / java-lyrics-plugin) available in the lavalink node (required for lyrics): ${this.id}`);
       const url = `/sessions/${this.sessionId}/players/${guildId}/track/lyrics?skipTrackSource=${skipTrackSource}`;
       return await this.request(url);
     },
@@ -1726,7 +1689,7 @@ var LavalinkNode = class {
      */
     subscribe: async (guildId) => {
       if (!this.sessionId) throw new Error("the Lavalink-Node is either not ready, or not up to date!");
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
       return await this.request(`/sessions/${this.sessionId}/players/${guildId}/lyrics/subscribe`, (options) => {
         options.method = "POST";
       });
@@ -1745,7 +1708,7 @@ var LavalinkNode = class {
      */
     unsubscribe: async (guildId) => {
       if (!this.sessionId) throw new Error("the Lavalink-Node is either not ready, or not up to date!");
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
       return await this.request(`/sessions/${this.sessionId}/players/${guildId}/lyrics/subscribe`, (options) => {
         options.method = "DELETE";
       });
@@ -1763,19 +1726,6 @@ var LavalinkNode = class {
   async fetchStats() {
     return await this.request(`/stats`);
   }
-  /**
-   * Request NodeLink connection metrics. https://nodelink.js.org/docs/differences#connection-metrics
-   * @returns the connection metrics of the node
-   *
-   * @example
-   * ```ts
-   * const connectionMetrics = await player.node.fetchConnectionMetrics();
-   * ```
-   */
-  async fetchConnectionMetrics() {
-    if (this.info && !this.info.isNodelink) throw new Error("There is no Information about wether you are using NodeLink instead of Lavalink, so this function won't work");
-    return await this.request(`/connection`);
-  }
   /**
    * Request Lavalink version.
    * @returns the current used lavalink version
@@ -1872,7 +1822,7 @@ var LavalinkNode = class {
    */
   syncPlayerData(data, res) {
     if (typeof data === "object" && typeof data?.guildId === "string" && typeof data.playerOptions === "object" && Object.keys(data.playerOptions).length > 0) {
-      const player = this._LManager.getPlayer(data.guildId);
+      const player = this.NodeManager.LavalinkManager.getPlayer(data.guildId);
       if (!player) return;
       if (typeof data.playerOptions.paused !== "undefined") {
         player.paused = data.playerOptions.paused;
@@ -1884,8 +1834,8 @@ var LavalinkNode = class {
       }
       if (typeof data.playerOptions.voice !== "undefined") player.voice = data.playerOptions.voice;
       if (typeof data.playerOptions.volume !== "undefined") {
-        if (this._LManager.options.playerOptions.volumeDecrementer) {
-          player.volume = Math.round(data.playerOptions.volume / this._LManager.options.playerOptions.volumeDecrementer);
+        if (this.NodeManager.LavalinkManager.options.playerOptions.volumeDecrementer) {
+          player.volume = Math.round(data.playerOptions.volume / this.NodeManager.LavalinkManager.options.playerOptions.volumeDecrementer);
           player.lavalinkVolume = Math.round(data.playerOptions.volume);
         } else {
           player.volume = Math.round(data.playerOptions.volume);
@@ -1909,7 +1859,7 @@ var LavalinkNode = class {
       }
     }
     if (res?.guildId === "string" && typeof res?.voice !== "undefined") {
-      const player = this._LManager.getPlayer(data.guildId);
+      const player = this.NodeManager.LavalinkManager.getPlayer(data.guildId);
       if (!player) return;
       if (typeof res?.voice?.connected === "boolean" && res.voice.connected === false) {
         player.destroy("LavalinkNoVoice" /* LavalinkNoVoice */);
@@ -1925,66 +1875,51 @@ var LavalinkNode = class {
   get restAddress() {
     return `http${this.options.secure ? "s" : ""}://${this.options.host}:${this.options.port}`;
   }
-  /**
-   * If already trying to reconnect or pending, return
-   */
-  get isNodeReconnecting() {
-    return this.reconnectionState !== "IDLE" /* IDLE */;
-  }
   /**
    * Reconnect to the lavalink node
-   * @param force @default false Wether to instantly try to reconnect (force it)
+   * @param instaReconnect @default false wether to instantly try to reconnect
    * @returns void
    *
    * @example
    * ```ts
-   * await player.node.reconnect(true); //true forcefully trys the reconnect
+   * await player.node.reconnect();
    * ```
    */
-  reconnect(force = false) {
-    if (this.isNodeReconnecting) {
+  reconnect(instaReconnect = false) {
+    if (this.reconnectionState !== "IDLE" /* IDLE */) {
       return;
     }
     this.reconnectionState = "PENDING" /* PENDING */;
     this.NodeManager.emit("reconnectinprogress", this);
-    if (force) {
-      this.executeReconnect();
+    const executeReconnect = () => {
+      if (this.reconnectAttempts >= this.options.retryAmount) {
+        const error = new Error(`Unable to connect after ${this.options.retryAmount} attempts.`);
+        this.NodeManager.emit("error", this, error);
+        this.reconnectionState = "DESTROYING" /* DESTROYING */;
+        this.destroy("NodeReconnectFail" /* NodeReconnectFail */);
+        this.reconnectionState = "IDLE" /* IDLE */;
+        return;
+      }
+      this.NodeManager.emit("reconnecting", this);
+      this.reconnectionState = "RECONNECTING" /* RECONNECTING */;
+      this.connect();
+      this.reconnectAttempts++;
+    };
+    if (instaReconnect) {
+      executeReconnect();
       return;
     }
-    if (this.reconnectTimeout) clearTimeout(this.reconnectTimeout);
     this.reconnectTimeout = setTimeout(() => {
       this.reconnectTimeout = null;
-      this.executeReconnect();
+      executeReconnect();
     }, this.options.retryDelay || 1e3);
   }
-  get reconnectionAttemptCount() {
-    const maxAllowedTimestan = this.options.retryTimespan || -1;
-    if (maxAllowedTimestan <= 0) return this.reconnectAttempts.length;
-    return this.reconnectAttempts.filter((timestamp) => Date.now() - timestamp <= maxAllowedTimestan).length;
-  }
-  /**
-   * Private Utility function to execute the reconnection
-  */
-  executeReconnect() {
-    if (this.reconnectionAttemptCount >= this.options.retryAmount) {
-      const error = new Error(`Unable to connect after ${this.options.retryAmount} attempts.`);
-      this.reconnectionState = "DESTROYING" /* DESTROYING */;
-      this.NodeManager.emit("error", this, error);
-      this.destroy("NodeReconnectFail" /* NodeReconnectFail */);
-      return;
-    }
-    this.reconnectAttempts.push(Date.now());
-    this.reconnectionState = "RECONNECTING" /* RECONNECTING */;
-    this.NodeManager.emit("reconnecting", this);
-    this.connect();
-  }
   /**
    * Private function to reset the reconnection attempts
    * @returns
    */
   resetReconnectionAttempts() {
-    this.reconnectionState = "IDLE" /* IDLE */;
-    this.reconnectAttempts = [];
+    this.reconnectAttempts = 1;
     clearTimeout(this.reconnectTimeout);
     this.reconnectTimeout = null;
     return;
@@ -2009,6 +1944,7 @@ var LavalinkNode = class {
   /** @private util function for handling opening events from websocket */
   async open() {
     this.isAlive = true;
+    this.reconnectionState = "IDLE" /* IDLE */;
     this.resetReconnectionAttempts();
     if (this.options.enablePingOnStatsCheck) this.heartBeat();
     if (this.heartBeatInterval) clearInterval(this.heartBeatInterval);
@@ -2019,10 +1955,10 @@ var LavalinkNode = class {
       });
       this.heartBeatInterval = setInterval(() => {
         if (!this.socket) return console.error("Node-Heartbeat-Interval - Socket not available - maybe reconnecting?");
-        if (!this.isAlive) return this.close(500, "Node-Heartbeat-Timeout");
+        if (!this.isAlive) this.close(500, "Node-Heartbeat-Timeout");
         this.isAlive = false;
         this.heartBeatPingTimestamp = performance.now();
-        this.socket?.ping?.();
+        this.socket.ping();
       }, this.options.heartBeatInterval || 3e4);
     }
     this.info = await this.fetchInfo().catch((e) => (console.error(e, "ON-OPEN-FETCH"), null));
@@ -2030,7 +1966,6 @@ var LavalinkNode = class {
       const errorString = `Lavalink Node (${this.restAddress}) does not provide any /${this.version}/info`;
       throw new Error(errorString);
     }
-    this.info.isNodelink = !!this.info.isNodelink;
     this.NodeManager.emit("connect", this);
   }
   /** @private util function for handling closing events from websocket */
@@ -2043,7 +1978,7 @@ var LavalinkNode = class {
       }
     } catch (e) {
       if (this.NodeManager?.LavalinkManager?.options?.advancedOptions?.enableDebugEvents) {
-        this._LManager.emit("debug", "SocketCleanupError" /* SocketCleanupError */, {
+        this.NodeManager.LavalinkManager.emit("debug", "SocketCleanupError" /* SocketCleanupError */, {
           state: "warn",
           message: `An error occurred during socket cleanup in close() (likely a race condition): ${e.message}`,
           functionLayer: "LavalinkNode > close()"
@@ -2056,12 +1991,15 @@ var LavalinkNode = class {
     this.NodeManager.emit("disconnect", this, { code, reason });
     if (code !== 1e3 || reason !== "Node-Destroy") {
       if (this.NodeManager.nodes.has(this.id)) {
-        this.reconnect();
+        if (this.reconnectionState === "IDLE" /* IDLE */) {
+          this.NodeManager.emit("reconnectFailed", this, reason || "Connection closed", this.reconnectAttempts);
+          this.reconnect();
+        }
       }
     }
-    this._LManager.players.filter((p) => p?.node?.options?.id === this?.options?.id).forEach((p) => {
-      if (!this._LManager.options.autoMove) return p.playing = false;
-      if (this._LManager.options.autoMove) {
+    this.NodeManager.LavalinkManager.players.filter((p) => p?.node?.options?.id === this?.options?.id).forEach((p) => {
+      if (!this.NodeManager.LavalinkManager.options.autoMove) return p.playing = false;
+      if (this.NodeManager.LavalinkManager.options.autoMove) {
         if (this.NodeManager.nodes.filter((n) => n.connected).size === 0)
           return p.playing = false;
         p.moveNode();
@@ -2102,12 +2040,17 @@ var LavalinkNode = class {
         break;
       case "playerUpdate":
         {
-          const player = this._LManager.getPlayer(payload.guildId);
-          if (!player) return this._emitDebugEvent("PlayerUpdateNoPlayer" /* PlayerUpdateNoPlayer */, {
-            state: "error",
-            message: `PlayerUpdate Event Triggered, but no player found of payload.guildId: ${payload.guildId}`,
-            functionLayer: "LavalinkNode > nodeEvent > playerUpdate"
-          });
+          const player = this.NodeManager.LavalinkManager.getPlayer(payload.guildId);
+          if (!player) {
+            if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+              this.NodeManager.LavalinkManager.emit("debug", "PlayerUpdateNoPlayer" /* PlayerUpdateNoPlayer */, {
+                state: "error",
+                message: `PlayerUpdate Event Triggered, but no player found of payload.guildId: ${payload.guildId}`,
+                functionLayer: "LavalinkNode > nodeEvent > playerUpdate"
+              });
+            }
+            return;
+          }
           const oldPlayer = player?.toJSON();
           player.lastPositionChange = Date.now();
           player.lastPosition = payload.state.position || 0;
@@ -2116,14 +2059,16 @@ var LavalinkNode = class {
           if (!player.createdTimeStamp && payload.state.time) player.createdTimeStamp = payload.state.time;
           if (player.filterManager.filterUpdatedState === true && ((player.queue.current?.info?.duration || 0) <= (player.LavalinkManager.options.advancedOptions.maxFilterFixDuration || 6e5) || player.queue.current?.info?.uri && (0, import_path.isAbsolute)(player.queue.current?.info?.uri))) {
             player.filterManager.filterUpdatedState = false;
-            this._emitDebugEvent("PlayerUpdateFilterFixApply" /* PlayerUpdateFilterFixApply */, {
-              state: "log",
-              message: `Fixing FilterState on "${player.guildId}" because player.options.instaUpdateFiltersFix === true`,
-              functionLayer: "LavalinkNode > nodeEvent > playerUpdate"
-            });
+            if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+              this.NodeManager.LavalinkManager.emit("debug", "PlayerUpdateFilterFixApply" /* PlayerUpdateFilterFixApply */, {
+                state: "log",
+                message: `Fixing FilterState on "${player.guildId}" because player.options.instaUpdateFiltersFix === true`,
+                functionLayer: "LavalinkNode > nodeEvent > playerUpdate"
+              });
+            }
             await player.seek(player.position);
           }
-          this._LManager.emit("playerUpdate", oldPlayer, player);
+          this.NodeManager.LavalinkManager.emit("playerUpdate", oldPlayer, player);
         }
         break;
       case "event":
@@ -2137,12 +2082,14 @@ var LavalinkNode = class {
           try {
             this.NodeManager.emit("resumed", this, payload, await this.fetchAllPlayers());
           } catch (e) {
-            this._emitDebugEvent("ResumingFetchingError" /* ResumingFetchingError */, {
-              state: "error",
-              message: `Failed to fetch players for resumed event, falling back without players array`,
-              error: e,
-              functionLayer: "LavalinkNode > nodeEvent > resumed"
-            });
+            if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+              this.NodeManager.LavalinkManager.emit("debug", "ResumingFetchingError" /* ResumingFetchingError */, {
+                state: "error",
+                message: `Failed to fetch players for resumed event, falling back without players array`,
+                error: e,
+                functionLayer: "LavalinkNode > nodeEvent > resumed"
+              });
+            }
             this.NodeManager.emit("resumed", this, payload, []);
           }
         }
@@ -2155,25 +2102,8 @@ var LavalinkNode = class {
   /** @private middleware util function for handling all kind of events from websocket */
   async handleEvent(payload) {
     if (!payload?.guildId) return;
-    const player = this._LManager.getPlayer(payload.guildId);
+    const player = this.NodeManager.LavalinkManager.getPlayer(payload.guildId);
     if (!player) return;
-    const NodeLinkEventType = payload.type;
-    const NodeLinkExclusiveEvents = [
-      "PlayerCreatedEvent",
-      "PlayerDestroyedEvent",
-      "PlayerConnectedEvent",
-      "PlayerReconnectingEvent",
-      "VolumeChangedEvent",
-      "FiltersChangedEvent",
-      "SeekEvent",
-      "PauseEvent",
-      "ConnectionStatusEvent",
-      "MixStartedEvent",
-      "MixEndedEvent"
-    ];
-    if (NodeLinkExclusiveEvents.includes(NodeLinkEventType) && (!this.info || this.info.isNodelink)) {
-      return this.nodeLinkEventHandler(NodeLinkEventType, player, player.queue.current, payload);
-    }
     switch (payload.type) {
       case "TrackStartEvent":
         this.trackStart(player, player.queue.current, payload);
@@ -2217,18 +2147,8 @@ var LavalinkNode = class {
     }
     return;
   }
-  /**
-   * nodeLink specific events handling https://nodelink.js.org/docs/api/websocket#incoming-events-server--client
-   * @param eventName
-   * @param player
-   * @param track
-   * @param payload
-   */
-  async nodeLinkEventHandler(eventName, player, track, payload) {
-    this.NodeManager.emit("nodeLinkEvent", this, eventName, player, track, payload);
-  }
   getTrackOfPayload(payload) {
-    return "track" in payload ? this._LManager.utils.buildTrack(payload.track, void 0) : null;
+    return "track" in payload ? this.NodeManager.LavalinkManager.utils.buildTrack(payload.track, void 0) : null;
   }
   /** @private util function for handling trackStart event */
   async trackStart(player, track, payload) {
@@ -2236,26 +2156,31 @@ var LavalinkNode = class {
       player.playing = true;
       player.paused = false;
     }
-    if (this._LManager.options?.emitNewSongsOnly === true && player.queue.previous[0]?.info?.identifier === track?.info?.identifier) {
-      return this._emitDebugEvent("TrackStartNewSongsOnly" /* TrackStartNewSongsOnly */, {
-        state: "log",
-        message: `TrackStart not Emitting, because playing the previous song again.`,
-        functionLayer: "LavalinkNode > trackStart()"
-      });
+    if (this.NodeManager.LavalinkManager.options?.emitNewSongsOnly === true && player.queue.previous[0]?.info?.identifier === track?.info?.identifier) {
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "TrackStartNewSongsOnly" /* TrackStartNewSongsOnly */, {
+          state: "log",
+          message: `TrackStart not Emitting, because playing the previous song again.`,
+          functionLayer: "LavalinkNode > trackStart()"
+        });
+      }
+      return;
     }
     if (!player.queue.current) {
       player.queue.current = this.getTrackOfPayload(payload);
       if (player.queue.current) {
         await player.queue.utils.save();
       } else {
-        this._emitDebugEvent("TrackStartNoTrack" /* TrackStartNoTrack */, {
-          state: "warn",
-          message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
-          functionLayer: "LavalinkNode > trackStart()"
-        });
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackStartNoTrack" /* TrackStartNoTrack */, {
+            state: "warn",
+            message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
+            functionLayer: "LavalinkNode > trackStart()"
+          });
+        }
       }
     }
-    this._LManager.emit("trackStart", player, player.queue.current, payload);
+    this.NodeManager.LavalinkManager.emit("trackStart", player, player.queue.current, payload);
     return;
   }
   /** @private util function for handling trackEnd event */
@@ -2263,12 +2188,14 @@ var LavalinkNode = class {
     if (player.get("internal_nodeChanging") === true) return;
     const trackToUse = track || this.getTrackOfPayload(payload);
     if (payload.reason === "replaced") {
-      this._emitDebugEvent("TrackEndReplaced" /* TrackEndReplaced */, {
-        state: "warn",
-        message: `TrackEnd Event does not handle any playback, because the track was replaced.`,
-        functionLayer: "LavalinkNode > trackEnd()"
-      });
-      this._LManager.emit("trackEnd", player, trackToUse, payload);
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "TrackEndReplaced" /* TrackEndReplaced */, {
+          state: "warn",
+          message: `TrackEnd Event does not handle any playback, because the track was replaced.`,
+          functionLayer: "LavalinkNode > trackEnd()"
+        });
+      }
+      this.NodeManager.LavalinkManager.emit("trackEnd", player, trackToUse, payload);
       return;
     }
     if (!player.queue.tracks.length && (player.repeatMode === "off" || player.get("internal_stopPlaying"))) return this.queueEnd(player, track, payload);
@@ -2276,8 +2203,8 @@ var LavalinkNode = class {
       if (player.get("internal_destroystatus") === true) return;
       await queueTrackEnd(player);
       if (!player.queue.current) return this.queueEnd(player, trackToUse, payload);
-      this._LManager.emit("trackEnd", player, trackToUse, payload);
-      if (this._LManager.options.autoSkip && player.queue.current) {
+      this.NodeManager.LavalinkManager.emit("trackEnd", player, trackToUse, payload);
+      if (this.NodeManager.LavalinkManager.options.autoSkip && player.queue.current) {
         player.play({ noReplace: true });
       }
       return;
@@ -2290,28 +2217,30 @@ var LavalinkNode = class {
     }
     if (!player.queue.current) return this.queueEnd(player, trackToUse, payload);
     player.set("internal_skipped", false);
-    this._LManager.emit("trackEnd", player, trackToUse, payload);
-    if (this._LManager.options.autoSkip && player.queue.current) {
+    this.NodeManager.LavalinkManager.emit("trackEnd", player, trackToUse, payload);
+    if (this.NodeManager.LavalinkManager.options.autoSkip && player.queue.current) {
       player.play({ noReplace: true });
     }
     return;
   }
   /** @private util function for handling trackStuck event */
   async trackStuck(player, track, payload) {
-    if (this._LManager.options.playerOptions.maxErrorsPerTime?.threshold > 0 && this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount >= 0) {
-      const oldTimestamps = (player.get("internal_erroredTracksTimestamps") || []).filter((v) => Date.now() - v < this._LManager.options.playerOptions.maxErrorsPerTime?.threshold);
+    if (this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold > 0 && this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount >= 0) {
+      const oldTimestamps = (player.get("internal_erroredTracksTimestamps") || []).filter((v) => Date.now() - v < this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold);
       player.set("internal_erroredTracksTimestamps", [...oldTimestamps, Date.now()]);
-      if (oldTimestamps.length > this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount) {
-        this._emitDebugEvent("TrackStuckMaxTracksErroredPerTime" /* TrackStuckMaxTracksErroredPerTime */, {
-          state: "log",
-          message: `trackStuck Event was triggered too often within a given threshold (LavalinkManager.options.playerOptions.maxErrorsPerTime). Threshold: "${this._LManager.options.playerOptions.maxErrorsPerTime?.threshold}ms", maxAmount: "${this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount}"`,
-          functionLayer: "LavalinkNode > trackStuck()"
-        });
+      if (oldTimestamps.length > this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount) {
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackStuckMaxTracksErroredPerTime" /* TrackStuckMaxTracksErroredPerTime */, {
+            state: "log",
+            message: `trackStuck Event was triggered too often within a given threshold (LavalinkManager.options.playerOptions.maxErrorsPerTime). Threshold: "${this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold}ms", maxAmount: "${this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount}"`,
+            functionLayer: "LavalinkNode > trackStuck()"
+          });
+        }
         player.destroy("TrackStuckMaxTracksErroredPerTime" /* TrackStuckMaxTracksErroredPerTime */);
         return;
       }
     }
-    this._LManager.emit("trackStuck", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("trackStuck", player, track || this.getTrackOfPayload(payload), payload);
     if (!player.queue.tracks.length && (player.repeatMode === "off" || player.get("internal_stopPlaying"))) {
       try {
         await player.node.updatePlayer({ guildId: player.guildId, playerOptions: { track: { encoded: null } } });
@@ -2324,52 +2253,54 @@ var LavalinkNode = class {
     if (!player.queue.current) {
       return this.queueEnd(player, track || this.getTrackOfPayload(payload), payload);
     }
-    if (this._LManager.options.autoSkip && player.queue.current) {
+    if (this.NodeManager.LavalinkManager.options.autoSkip && player.queue.current) {
       player.play({ track: player.queue.current, noReplace: false });
     }
     return;
   }
   /** @private util function for handling trackError event */
   async trackError(player, track, payload) {
-    if (this._LManager.options.playerOptions.maxErrorsPerTime?.threshold > 0 && this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount >= 0) {
-      const oldTimestamps = (player.get("internal_erroredTracksTimestamps") || []).filter((v) => Date.now() - v < this._LManager.options.playerOptions.maxErrorsPerTime?.threshold);
+    if (this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold > 0 && this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount >= 0) {
+      const oldTimestamps = (player.get("internal_erroredTracksTimestamps") || []).filter((v) => Date.now() - v < this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold);
       player.set("internal_erroredTracksTimestamps", [...oldTimestamps, Date.now()]);
-      if (oldTimestamps.length > this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount) {
-        this._emitDebugEvent("TrackErrorMaxTracksErroredPerTime" /* TrackErrorMaxTracksErroredPerTime */, {
-          state: "log",
-          message: `TrackError Event was triggered too often within a given threshold (LavalinkManager.options.playerOptions.maxErrorsPerTime). Threshold: "${this._LManager.options.playerOptions.maxErrorsPerTime?.threshold}ms", maxAmount: "${this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount}"`,
-          functionLayer: "LavalinkNode > trackError()"
-        });
+      if (oldTimestamps.length > this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount) {
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackErrorMaxTracksErroredPerTime" /* TrackErrorMaxTracksErroredPerTime */, {
+            state: "log",
+            message: `TrackError Event was triggered too often within a given threshold (LavalinkManager.options.playerOptions.maxErrorsPerTime). Threshold: "${this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold}ms", maxAmount: "${this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount}"`,
+            functionLayer: "LavalinkNode > trackError()"
+          });
+        }
         player.destroy("TrackErrorMaxTracksErroredPerTime" /* TrackErrorMaxTracksErroredPerTime */);
         return;
       }
     }
-    this._LManager.emit("trackError", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("trackError", player, track || this.getTrackOfPayload(payload), payload);
     return;
   }
   /** @private util function for handling socketClosed event */
   socketClosed(player, payload) {
-    this._LManager.emit("playerSocketClosed", player, payload);
+    this.NodeManager.LavalinkManager.emit("playerSocketClosed", player, payload);
     return;
   }
   /** @private util function for handling SponsorBlock Segmentloaded event */
   SponsorBlockSegmentLoaded(player, track, payload) {
-    this._LManager.emit("SegmentsLoaded", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("SegmentsLoaded", player, track || this.getTrackOfPayload(payload), payload);
     return;
   }
   /** @private util function for handling SponsorBlock SegmentSkipped event */
   SponsorBlockSegmentSkipped(player, track, payload) {
-    this._LManager.emit("SegmentSkipped", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("SegmentSkipped", player, track || this.getTrackOfPayload(payload), payload);
     return;
   }
   /** @private util function for handling SponsorBlock Chaptersloaded event */
   SponsorBlockChaptersLoaded(player, track, payload) {
-    this._LManager.emit("ChaptersLoaded", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("ChaptersLoaded", player, track || this.getTrackOfPayload(payload), payload);
     return;
   }
   /** @private util function for handling SponsorBlock Chaptersstarted event */
   SponsorBlockChapterStarted(player, track, payload) {
-    this._LManager.emit("ChapterStarted", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("ChapterStarted", player, track || this.getTrackOfPayload(payload), payload);
     return;
   }
   /**
@@ -2384,7 +2315,7 @@ var LavalinkNode = class {
    * ```
    */
   async getSponsorBlock(player) {
-    if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
+    if (!this.info.plugins.find((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
     return await this.request(`/sessions/${this.sessionId}/players/${player.guildId}/sponsorblock/categories`);
   }
   /**
@@ -2399,7 +2330,7 @@ var LavalinkNode = class {
    * ```
    */
   async setSponsorBlock(player, segments = ["sponsor", "selfpromo"]) {
-    if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
+    if (!this.info.plugins.find((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
     if (!segments.length) throw new RangeError("No Segments provided. Did you ment to use 'deleteSponsorBlock'?");
     if (segments.some((v) => !validSponsorBlocks.includes(v.toLowerCase()))) throw new SyntaxError(`You provided a sponsorblock which isn't valid, valid ones are: ${validSponsorBlocks.map((v) => `'${v}'`).join(", ")}`);
     await this.request(`/sessions/${this.sessionId}/players/${player.guildId}/sponsorblock/categories`, (r) => {
@@ -2408,11 +2339,13 @@ var LavalinkNode = class {
       r.body = safeStringify(segments.map((v) => v.toLowerCase()));
     });
     player.set("internal_sponsorBlockCategories", segments.map((v) => v.toLowerCase()));
-    this._emitDebugEvent("SetSponsorBlock" /* SetSponsorBlock */, {
-      state: "log",
-      message: `SponsorBlock was set for Player: ${player.guildId} to: ${segments.map((v) => `'${v.toLowerCase()}'`).join(", ")}`,
-      functionLayer: "LavalinkNode > setSponsorBlock()"
-    });
+    if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.NodeManager.LavalinkManager.emit("debug", "SetSponsorBlock" /* SetSponsorBlock */, {
+        state: "log",
+        message: `SponsorBlock was set for Player: ${player.guildId} to: ${segments.map((v) => `'${v.toLowerCase()}'`).join(", ")}`,
+        functionLayer: "LavalinkNode > setSponsorBlock()"
+      });
+    }
     return;
   }
   /**
@@ -2427,16 +2360,18 @@ var LavalinkNode = class {
    * ```
    */
   async deleteSponsorBlock(player) {
-    if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
+    if (!this.info.plugins.find((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
     await this.request(`/sessions/${this.sessionId}/players/${player.guildId}/sponsorblock/categories`, (r) => {
       r.method = "DELETE";
     });
     player.set("internal_sponsorBlockCategories", []);
-    this._emitDebugEvent("DeleteSponsorBlock" /* DeleteSponsorBlock */, {
-      state: "log",
-      message: `SponsorBlock was deleted for Player: ${player.guildId}`,
-      functionLayer: "LavalinkNode > deleteSponsorBlock()"
-    });
+    if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.NodeManager.LavalinkManager.emit("debug", "DeleteSponsorBlock" /* DeleteSponsorBlock */, {
+        state: "log",
+        message: `SponsorBlock was deleted for Player: ${player.guildId}`,
+        functionLayer: "LavalinkNode > deleteSponsorBlock()"
+      });
+    }
     return;
   }
   /** private util function for handling the queue end event */
@@ -2445,38 +2380,46 @@ var LavalinkNode = class {
     player.queue.current = null;
     player.playing = false;
     player.set("internal_stopPlaying", void 0);
-    this._emitDebugEvent("QueueEnded" /* QueueEnded */, {
-      state: "log",
-      message: `Queue Ended because no more Tracks were in the Queue, due to EventName: "${payload.type}"`,
-      functionLayer: "LavalinkNode > queueEnd()"
-    });
-    if (typeof this._LManager.options?.playerOptions?.onEmptyQueue?.autoPlayFunction === "function" && typeof player.get("internal_autoplayStopPlaying") === "undefined") {
-      this._emitDebugEvent("AutoplayExecution" /* AutoplayExecution */, {
+    if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.NodeManager.LavalinkManager.emit("debug", "QueueEnded" /* QueueEnded */, {
         state: "log",
-        message: `Now Triggering Autoplay.`,
-        functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
+        message: `Queue Ended because no more Tracks were in the Queue, due to EventName: "${payload.type}"`,
+        functionLayer: "LavalinkNode > queueEnd()"
       });
+    }
+    if (typeof this.NodeManager.LavalinkManager.options?.playerOptions?.onEmptyQueue?.autoPlayFunction === "function" && typeof player.get("internal_autoplayStopPlaying") === "undefined") {
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "AutoplayExecution" /* AutoplayExecution */, {
+          state: "log",
+          message: `Now Triggering Autoplay.`,
+          functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
+        });
+      }
       const previousAutoplayTime = player.get("internal_previousautoplay");
       const duration = previousAutoplayTime ? Date.now() - previousAutoplayTime : 0;
-      if (!duration || duration > this._LManager.options.playerOptions.minAutoPlayMs || !!player.get("internal_skipped")) {
-        await this._LManager.options?.playerOptions?.onEmptyQueue?.autoPlayFunction(player, track);
+      if (!duration || duration > this.NodeManager.LavalinkManager.options.playerOptions.minAutoPlayMs || !!player.get("internal_skipped")) {
+        await this.NodeManager.LavalinkManager.options?.playerOptions?.onEmptyQueue?.autoPlayFunction(player, track);
         player.set("internal_previousautoplay", Date.now());
         if (player.queue.tracks.length > 0) await queueTrackEnd(player);
-        else this._emitDebugEvent("AutoplayNoSongsAdded" /* AutoplayNoSongsAdded */, {
-          state: "warn",
-          message: `Autoplay was triggered but no songs were added to the queue.`,
-          functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
-        });
-      }
-      if (player.queue.current) {
-        if (payload.type === "TrackEndEvent") this._LManager.emit("trackEnd", player, track, payload);
-        if (this._LManager.options.autoSkip) return player.play({ noReplace: true, paused: false });
+        else if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "AutoplayNoSongsAdded" /* AutoplayNoSongsAdded */, {
+            state: "warn",
+            message: `Autoplay was triggered but no songs were added to the queue.`,
+            functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
+          });
+        }
+        if (player.queue.current) {
+          if (payload.type === "TrackEndEvent") this.NodeManager.LavalinkManager.emit("trackEnd", player, track, payload);
+          if (this.NodeManager.LavalinkManager.options.autoSkip) return player.play({ noReplace: true, paused: false });
+        }
       } else {
-        this._emitDebugEvent("AutoplayThresholdSpamLimiter" /* AutoplayThresholdSpamLimiter */, {
-          state: "warn",
-          message: `Autoplay was triggered after the previousautoplay too early. Threshold is: ${this._LManager.options.playerOptions.minAutoPlayMs}ms and the Duration was ${duration}ms`,
-          functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
-        });
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "AutoplayThresholdSpamLimiter" /* AutoplayThresholdSpamLimiter */, {
+            state: "warn",
+            message: `Autoplay was triggered after the previousautoplay too early. Threshold is: ${this.NodeManager.LavalinkManager.options.playerOptions.minAutoPlayMs}ms and the Duration was ${duration}ms`,
+            functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
+          });
+        }
       }
     }
     player.set("internal_skipped", false);
@@ -2489,29 +2432,34 @@ var LavalinkNode = class {
     if (payload?.reason !== "stopped") {
       await player.queue.utils.save();
     }
-    if (typeof this._LManager.options.playerOptions?.onEmptyQueue?.destroyAfterMs === "number" && !isNaN(this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs) && this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs >= 0) {
-      if (this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs === 0) {
+    if (typeof this.NodeManager.LavalinkManager.options.playerOptions?.onEmptyQueue?.destroyAfterMs === "number" && !isNaN(this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs) && this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs >= 0) {
+      if (this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs === 0) {
         player.destroy("QueueEmpty" /* QueueEmpty */);
         return;
       } else {
-        this._emitDebugEvent("TriggerQueueEmptyInterval" /* TriggerQueueEmptyInterval */, {
-          state: "log",
-          message: `Trigger Queue Empty Interval was Triggered because playerOptions.onEmptyQueue.destroyAfterMs is set to ${this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs}ms`,
-          functionLayer: "LavalinkNode > queueEnd() > destroyAfterMs"
-        });
-        this._LManager.emit("playerQueueEmptyStart", player, this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs);
-        if (player.get("internal_queueempty")) clearTimeout(player.get("internal_queueempty"));
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TriggerQueueEmptyInterval" /* TriggerQueueEmptyInterval */, {
+            state: "log",
+            message: `Trigger Queue Empty Interval was Triggered because playerOptions.onEmptyQueue.destroyAfterMs is set to ${this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs}ms`,
+            functionLayer: "LavalinkNode > queueEnd() > destroyAfterMs"
+          });
+        }
+        this.NodeManager.LavalinkManager.emit("playerQueueEmptyStart", player, this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs);
+        if (player.get("internal_queueempty")) {
+          clearTimeout(player.get("internal_queueempty"));
+          player.set("internal_queueempty", void 0);
+        }
         player.set("internal_queueempty", setTimeout(() => {
           player.set("internal_queueempty", void 0);
           if (player.queue.current) {
-            return this._LManager.emit("playerQueueEmptyCancel", player);
+            return this.NodeManager.LavalinkManager.emit("playerQueueEmptyCancel", player);
           }
-          this._LManager.emit("playerQueueEmptyEnd", player);
+          this.NodeManager.LavalinkManager.emit("playerQueueEmptyEnd", player);
           player.destroy("QueueEmpty" /* QueueEmpty */);
-        }, this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs));
+        }, this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs));
       }
     }
-    this._LManager.emit("queueEnd", player, track, payload);
+    this.NodeManager.LavalinkManager.emit("queueEnd", player, track, payload);
     return;
   }
   /**
@@ -2527,14 +2475,16 @@ var LavalinkNode = class {
       if (player.queue.current) {
         await player.queue.utils.save();
       } else {
-        this._emitDebugEvent("TrackStartNoTrack" /* TrackStartNoTrack */, {
-          state: "warn",
-          message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
-          functionLayer: "LavalinkNode > trackStart()"
-        });
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackStartNoTrack" /* TrackStartNoTrack */, {
+            state: "warn",
+            message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
+            functionLayer: "LavalinkNode > trackStart()"
+          });
+        }
       }
     }
-    this._LManager.emit("LyricsLine", player, track, payload);
+    this.NodeManager.LavalinkManager.emit("LyricsLine", player, track, payload);
     return;
   }
   /**
@@ -2550,14 +2500,16 @@ var LavalinkNode = class {
       if (player.queue.current) {
         await player.queue.utils.save();
       } else {
-        this._emitDebugEvent("TrackStartNoTrack" /* TrackStartNoTrack */, {
-          state: "warn",
-          message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
-          functionLayer: "LavalinkNode > trackStart()"
-        });
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackStartNoTrack" /* TrackStartNoTrack */, {
+            state: "warn",
+            message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
+            functionLayer: "LavalinkNode > trackStart()"
+          });
+        }
       }
     }
-    this._LManager.emit("LyricsFound", player, track, payload);
+    this.NodeManager.LavalinkManager.emit("LyricsFound", player, track, payload);
     return;
   }
   /**
@@ -2573,14 +2525,16 @@ var LavalinkNode = class {
       if (player.queue.current) {
         await player.queue.utils.save();
       } else {
-        this._emitDebugEvent("TrackStartNoTrack" /* TrackStartNoTrack */, {
-          state: "warn",
-          message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
-          functionLayer: "LavalinkNode > trackStart()"
-        });
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackStartNoTrack" /* TrackStartNoTrack */, {
+            state: "warn",
+            message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
+            functionLayer: "LavalinkNode > trackStart()"
+          });
+        }
       }
     }
-    this._LManager.emit("LyricsNotFound", player, track, payload);
+    this.NodeManager.LavalinkManager.emit("LyricsNotFound", player, track, payload);
     return;
   }
 };
@@ -2942,21 +2896,6 @@ var FilterManager = class {
   data = structuredClone(DEFAULT_FILTER_DATAS);
   /** The Player assigned to this Filter Manager */
   player;
-  get _LManager() {
-    return this.player.LavalinkManager;
-  }
-  /**
-   * Returns wether the plugin validations are enabled or not
-   */
-  get _checkForPlugins() {
-    return !!this._LManager.options?.autoChecks?.pluginValidations;
-  }
-  /**
-   * Returns wether the source validations are enabled or not
-   */
-  get _checkForSources() {
-    return !!this._LManager.options?.autoChecks?.sourcesValidations;
-  }
   /** The Constructor for the FilterManager */
   constructor(player) {
     this.player = player;
@@ -2993,13 +2932,13 @@ var FilterManager = class {
     if (!this.filters.karaoke) delete sendData.karaoke;
     if (!this.filters.rotation) delete sendData.rotation;
     if (this.filters.audioOutput === "stereo") delete sendData.channelMix;
-    if (Object.values(this.data.timescale ?? {}).every((v) => v === 1)) delete sendData.timescale;
+    if (Object.values(this.data.timescale).every((v) => v === 1)) delete sendData.timescale;
     if (!this.player.node.sessionId) throw new Error("The Lavalink-Node is either not ready or not up to date");
     sendData.equalizer = [...this.equalizerBands];
     if (sendData.equalizer.length === 0) delete sendData.equalizer;
     for (const key of Object.keys(sendData)) {
       if (key === "pluginFilters") {
-      } else if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.(key)) delete sendData[key];
+      } else if (this.player.node.info && !this.player.node.info?.filters?.includes?.(key)) delete sendData[key];
     }
     const now = performance.now();
     if (this.player.options.instaUpdateFiltersFix === true) this.filterUpdatedState = true;
@@ -3015,19 +2954,6 @@ var FilterManager = class {
   privateNot0(value) {
     return typeof value === "number" && value !== 0;
   }
-  getLavalinkFilterData() {
-    return this.data.pluginFilters?.["lavalink-filter-plugin"] || {
-      echo: {
-        decay: this.data.pluginFilters?.echo?.decay && !this.data.pluginFilters?.echo?.echoLength ? this.data.pluginFilters?.echo?.decay : 0,
-        delay: this.data.pluginFilters?.echo?.delay || 0
-      },
-      reverb: {
-        gains: [],
-        delays: [],
-        ...this.data.pluginFilters?.reverb
-      }
-    };
-  }
   /**
    * Checks if the filters are correctly stated (active / not-active) - mostly used internally.
    * @param oldFilterTimescale
@@ -3046,17 +2972,13 @@ var FilterManager = class {
     this.filters.rotation = this.privateNot0(this.data.rotation?.rotationHz);
     this.filters.vibrato = this.privateNot0(this.data.vibrato?.frequency) || this.privateNot0(this.data.vibrato?.depth);
     this.filters.tremolo = this.privateNot0(this.data.tremolo?.frequency) || this.privateNot0(this.data.tremolo?.depth);
-    const lavalinkFilterData = this.getLavalinkFilterData();
-    this.filters.lavalinkFilterPlugin = {
-      echo: this.privateNot0(lavalinkFilterData?.echo?.decay) || this.privateNot0(lavalinkFilterData?.echo?.delay),
-      reverb: this.privateNot0(lavalinkFilterData?.reverb?.delays?.length) || this.privateNot0(lavalinkFilterData?.reverb?.gains?.length)
-    };
-    this.filters.lavalinkLavaDspxPlugin = {
-      lowPass: Object.values(this.data.pluginFilters?.["low-pass"] || {})?.length > 0,
-      highPass: Object.values(this.data.pluginFilters?.["high-pass"] || {})?.length > 0,
-      normalization: Object.values(this.data.pluginFilters?.normalization || {})?.length > 0,
-      echo: Object.values(this.data.pluginFilters?.echo || {})?.length > 0 && typeof this.data.pluginFilters?.echo?.delay === "undefined"
-    };
+    const lavalinkFilterData = this.data.pluginFilters?.["lavalink-filter-plugin"] || { echo: { decay: this.data.pluginFilters?.echo?.decay && !this.data.pluginFilters?.echo?.echoLength ? this.data.pluginFilters.echo.decay : 0, delay: this.data.pluginFilters?.echo?.delay || 0 }, reverb: { gains: [], delays: [], ...this.data.pluginFilters.reverb } };
+    this.filters.lavalinkFilterPlugin.echo = lavalinkFilterData.echo.decay !== 0 || lavalinkFilterData.echo.delay !== 0;
+    this.filters.lavalinkFilterPlugin.reverb = lavalinkFilterData.reverb?.delays?.length !== 0 || lavalinkFilterData.reverb?.gains?.length !== 0;
+    this.filters.lavalinkLavaDspxPlugin.highPass = Object.values(this.data.pluginFilters?.["high-pass"] || {}).length > 0;
+    this.filters.lavalinkLavaDspxPlugin.lowPass = Object.values(this.data.pluginFilters?.["low-pass"] || {}).length > 0;
+    this.filters.lavalinkLavaDspxPlugin.normalization = Object.values(this.data.pluginFilters?.normalization || {}).length > 0;
+    this.filters.lavalinkLavaDspxPlugin.echo = Object.values(this.data.pluginFilters?.echo || {}).length > 0 && typeof this.data.pluginFilters?.echo?.delay === "undefined";
     this.filters.lowPass = this.privateNot0(this.data.lowPass?.smoothing);
     this.filters.karaoke = Object.values(this.data.karaoke ?? {}).some((v) => v !== 0);
     if ((this.filters.nightcore || this.filters.vaporwave) && oldFilterTimescale) {
@@ -3139,7 +3061,7 @@ var FilterManager = class {
    * ```
    */
   async setAudioOutput(type) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("channelMix")) throw new Error("Node#Info#filters does not include the 'channelMix' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("channelMix")) throw new Error("Node#Info#filters does not include the 'channelMix' Filter (Node has it not enable)");
     if (!type || !audioOutputsData[type]) throw "Invalid audio type added, must be 'mono' / 'stereo' / 'left' / 'right'";
     this.data = this.data ?? {};
     this.data.channelMix = audioOutputsData[type];
@@ -3159,7 +3081,7 @@ var FilterManager = class {
    * ```
    */
   async setSpeed(speed = 1) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.filters.nightcore = false;
     this.filters.vaporwave = false;
@@ -3180,7 +3102,7 @@ var FilterManager = class {
    * ```
    */
   async setPitch(pitch = 1) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.filters.nightcore = false;
     this.filters.vaporwave = false;
@@ -3201,7 +3123,7 @@ var FilterManager = class {
    * ```
    */
   async setRate(rate = 1) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.filters.nightcore = false;
     this.filters.vaporwave = false;
@@ -3225,7 +3147,7 @@ var FilterManager = class {
    * ```
    */
   async toggleRotation(rotationHz = 0.2) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("rotation")) throw new Error("Node#Info#filters does not include the 'rotation' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("rotation")) throw new Error("Node#Info#filters does not include the 'rotation' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.rotation = this.filters.rotation ? DEFAULT_FILTER_DATAS.rotation : { rotationHz };
     this.filters.rotation = !this.filters.rotation;
@@ -3248,7 +3170,7 @@ var FilterManager = class {
    * ```
    */
   async toggleVibrato(frequency = 10, depth = 1) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("vibrato")) throw new Error("Node#Info#filters does not include the 'vibrato' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("vibrato")) throw new Error("Node#Info#filters does not include the 'vibrato' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.vibrato = this.filters.vibrato ? DEFAULT_FILTER_DATAS.vibrato : { depth, frequency };
     this.filters.vibrato = !this.filters.vibrato;
@@ -3271,7 +3193,7 @@ var FilterManager = class {
    * ```
    */
   async toggleTremolo(frequency = 4, depth = 0.8) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("tremolo")) throw new Error("Node#Info#filters does not include the 'tremolo' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("tremolo")) throw new Error("Node#Info#filters does not include the 'tremolo' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.tremolo = this.filters.tremolo ? DEFAULT_FILTER_DATAS.tremolo : { depth, frequency };
     this.filters.tremolo = !this.filters.tremolo;
@@ -3293,7 +3215,7 @@ var FilterManager = class {
    * ```
    */
   async toggleLowPass(smoothing = 20) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("lowPass")) throw new Error("Node#Info#filters does not include the 'lowPass' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("lowPass")) throw new Error("Node#Info#filters does not include the 'lowPass' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.lowPass = this.filters.lowPass ? DEFAULT_FILTER_DATAS.lowPass : { smoothing };
     this.filters.lowPass = !this.filters.lowPass;
@@ -3320,8 +3242,8 @@ var FilterManager = class {
      * ```
      */
     toggleLowPass: async (boostFactor = 1, cutoffFrequency = 80) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("low-pass")) throw new Error("Node#Info#filters does not include the 'low-pass' Filter (Node has it not enable)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("low-pass")) throw new Error("Node#Info#filters does not include the 'low-pass' Filter (Node has it not enable)");
       this.data = this.data ?? {};
       this.data.pluginFilters = this.data.pluginFilters ?? {};
       if (this.filters.lavalinkLavaDspxPlugin.lowPass) delete this.data.pluginFilters["low-pass"];
@@ -3346,8 +3268,8 @@ var FilterManager = class {
      * ```
      */
     toggleHighPass: async (boostFactor = 1, cutoffFrequency = 80) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("high-pass")) throw new Error("Node#Info#filters does not include the 'high-pass' Filter (Node has it not enable)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("high-pass")) throw new Error("Node#Info#filters does not include the 'high-pass' Filter (Node has it not enable)");
       this.data = this.data ?? {};
       this.data.pluginFilters = this.data.pluginFilters ?? {};
       if (this.filters.lavalinkLavaDspxPlugin.highPass) delete this.data.pluginFilters["high-pass"];
@@ -3372,8 +3294,8 @@ var FilterManager = class {
      * ```
      */
     toggleNormalization: async (maxAmplitude = 0.75, adaptive = true) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("normalization")) throw new Error("Node#Info#filters does not include the 'normalization' Filter (Node has it not enable)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("normalization")) throw new Error("Node#Info#filters does not include the 'normalization' Filter (Node has it not enable)");
       this.data = this.data ?? {};
       this.data.pluginFilters = this.data.pluginFilters ?? {};
       if (this.filters.lavalinkLavaDspxPlugin.normalization) delete this.data.pluginFilters.normalization;
@@ -3398,8 +3320,8 @@ var FilterManager = class {
      * ```
      */
     toggleEcho: async (decay = 0.5, echoLength = 0.5) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("echo")) throw new Error("Node#Info#filters does not include the 'echo' Filter (Node has it not enable)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("echo")) throw new Error("Node#Info#filters does not include the 'echo' Filter (Node has it not enable)");
       this.data = this.data ?? {};
       this.data.pluginFilters = this.data.pluginFilters ?? {};
       if (this.filters.lavalinkLavaDspxPlugin.echo) delete this.data.pluginFilters.echo;
@@ -3429,8 +3351,8 @@ var FilterManager = class {
      * ```
      */
     toggleEcho: async (delay = 4, decay = 0.8) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavalink-filter-plugin")) throw new Error("Node#Info#plugins does not include the lavalink-filter-plugin plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("echo")) throw new Error("Node#Info#filters does not include the 'echo' Filter (Node has it not enable aka not installed!)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavalink-filter-plugin")) throw new Error("Node#Info#plugins does not include the lavalink-filter-plugin plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("echo")) throw new Error("Node#Info#filters does not include the 'echo' Filter (Node has it not enable aka not installed!)");
       this.data = this.data ?? {};
       const { echo, reverb } = DEFAULT_FILTER_DATAS.pluginFilters["lavalink-filter-plugin"];
       this.data.pluginFilters = {
@@ -3460,8 +3382,8 @@ var FilterManager = class {
      * ```
      */
     toggleReverb: async (delays = [0.037, 0.042, 0.048, 0.053], gains = [0.84, 0.83, 0.82, 0.81]) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavalink-filter-plugin")) throw new Error("Node#Info#plugins does not include the lavalink-filter-plugin plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("reverb")) throw new Error("Node#Info#filters does not include the 'reverb' Filter (Node has it not enable aka not installed!)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavalink-filter-plugin")) throw new Error("Node#Info#plugins does not include the lavalink-filter-plugin plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("reverb")) throw new Error("Node#Info#filters does not include the 'reverb' Filter (Node has it not enable aka not installed!)");
       this.data = this.data ?? {};
       const { echo, reverb } = DEFAULT_FILTER_DATAS.pluginFilters["lavalink-filter-plugin"];
       this.data.pluginFilters = {
@@ -3493,7 +3415,7 @@ var FilterManager = class {
    * ```
    */
   async toggleNightcore(speed = 1.289999523162842, pitch = 1.289999523162842, rate = 0.9365999523162842) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.timescale = this.filters.nightcore ? DEFAULT_FILTER_DATAS.timescale : { speed, pitch, rate };
     this.filters.nightcore = !this.filters.nightcore;
@@ -3519,7 +3441,7 @@ var FilterManager = class {
    * ```
    */
   async toggleVaporwave(speed = 0.8500000238418579, pitch = 0.800000011920929, rate = 1) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.timescale = this.filters.vaporwave ? DEFAULT_FILTER_DATAS.timescale : { speed, pitch, rate };
     this.filters.vaporwave = !this.filters.vaporwave;
@@ -3546,7 +3468,7 @@ var FilterManager = class {
    * ```
    */
   async toggleKaraoke(level = 1, monoLevel = 1, filterBand = 220, filterWidth = 100) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("karaoke")) throw new Error("Node#Info#filters does not include the 'karaoke' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("karaoke")) throw new Error("Node#Info#filters does not include the 'karaoke' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.karaoke = this.filters.karaoke ? DEFAULT_FILTER_DATAS.karaoke : { level, monoLevel, filterBand, filterWidth };
     this.filters.karaoke = !this.filters.karaoke;
@@ -4063,15 +3985,6 @@ var Player = class {
   };
   /** Custom data for the player */
   data = {};
-  /**
-   * Emits a debug event to the LavalinkManager
-   * @param name name of the event
-   * @param eventData event data
-   */
-  _emitDebugEvent(name, eventData) {
-    if (!this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) return;
-    this.LavalinkManager.emit("debug", name, eventData);
-  }
   /**
    * Create a new Player
    * @param options
@@ -4087,8 +4000,8 @@ var Player = class {
     this.textChannelId = this.options.textChannelId || null;
     this.node = typeof this.options.node === "string" ? this.LavalinkManager.nodeManager.nodes.get(this.options.node) : this.options.node;
     if (!this.node || typeof this.node.request !== "function") {
-      if (typeof this.options.node === "string") {
-        this._emitDebugEvent("PlayerCreateNodeNotFound" /* PlayerCreateNodeNotFound */, {
+      if (typeof this.options.node === "string" && this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerCreateNodeNotFound" /* PlayerCreateNodeNotFound */, {
           state: "warn",
           message: `Player was created with provided node Id: ${this.options.node}, but no node with that Id was found.`,
           functionLayer: "Player > constructor()"
@@ -4145,11 +4058,13 @@ var Player = class {
    */
   async play(options = {}) {
     if (this.get("internal_queueempty")) {
-      this._emitDebugEvent("PlayerPlayQueueEmptyTimeoutClear" /* PlayerPlayQueueEmptyTimeoutClear */, {
-        state: "log",
-        message: `Player was called to play something, while there was a queueEmpty Timeout set, clearing the timeout.`,
-        functionLayer: "Player > play()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerPlayQueueEmptyTimeoutClear" /* PlayerPlayQueueEmptyTimeoutClear */, {
+          state: "log",
+          message: `Player was called to play something, while there was a queueEmpty Timeout set, clearing the timeout.`,
+          functionLayer: "Player > play()"
+        });
+      }
       this.LavalinkManager.emit("playerQueueEmptyCancel", this);
       clearTimeout(this.get("internal_queueempty"));
       this.set("internal_queueempty", void 0);
@@ -4159,12 +4074,14 @@ var Player = class {
         try {
           await options.clientTrack.resolve(this);
         } catch (error) {
-          this._emitDebugEvent("PlayerPlayUnresolvedTrackFailed" /* PlayerPlayUnresolvedTrackFailed */, {
-            state: "error",
-            error,
-            message: `Player Play was called with clientTrack, Song is unresolved, but couldn't resolve it`,
-            functionLayer: "Player > play() > resolve currentTrack"
-          });
+          if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+            this.LavalinkManager.emit("debug", "PlayerPlayUnresolvedTrackFailed" /* PlayerPlayUnresolvedTrackFailed */, {
+              state: "error",
+              error,
+              message: `Player Play was called with clientTrack, Song is unresolved, but couldn't resolve it`,
+              functionLayer: "Player > play() > resolve currentTrack"
+            });
+          }
           this.LavalinkManager.emit("trackError", this, this.queue.current, error);
           if (options && "clientTrack" in options) delete options.clientTrack;
           if (options && "track" in options) delete options.track;
@@ -4201,11 +4118,13 @@ var Player = class {
           ...options.track.userData
         }
       }).filter((v) => typeof v[1] !== "undefined"));
-      this._emitDebugEvent("PlayerPlayWithTrackReplace" /* PlayerPlayWithTrackReplace */, {
-        state: "log",
-        message: `Player was called to play something, with a specific track provided. Replacing the current Track and resolving the track on trackStart Event.`,
-        functionLayer: "Player > play()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerPlayWithTrackReplace" /* PlayerPlayWithTrackReplace */, {
+          state: "log",
+          message: `Player was called to play something, with a specific track provided. Replacing the current Track and resolving the track on trackStart Event.`,
+          functionLayer: "Player > play()"
+        });
+      }
       return this.node.updatePlayer({
         guildId: this.guildId,
         noReplace: false,
@@ -4222,11 +4141,13 @@ var Player = class {
     }
     if (!this.queue.current && this.queue.tracks.length) await queueTrackEnd(this);
     if (this.queue.current && this.LavalinkManager.utils.isUnresolvedTrack(this.queue.current)) {
-      this._emitDebugEvent("PlayerPlayUnresolvedTrack" /* PlayerPlayUnresolvedTrack */, {
-        state: "log",
-        message: `Player Play was called, current Queue Song is unresolved, resolving the track.`,
-        functionLayer: "Player > play()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerPlayUnresolvedTrack" /* PlayerPlayUnresolvedTrack */, {
+          state: "log",
+          message: `Player Play was called, current Queue Song is unresolved, resolving the track.`,
+          functionLayer: "Player > play()"
+        });
+      }
       try {
         await this.queue.current.resolve(this);
         if (typeof options.track?.userData === "object" && this.queue.current) this.queue.current.userData = {
@@ -4235,12 +4156,14 @@ var Player = class {
           ...options.track?.userData
         };
       } catch (error) {
-        this._emitDebugEvent("PlayerPlayUnresolvedTrackFailed" /* PlayerPlayUnresolvedTrackFailed */, {
-          state: "error",
-          error,
-          message: `Player Play was called, current Queue Song is unresolved, but couldn't resolve it`,
-          functionLayer: "Player > play() > resolve currentTrack"
-        });
+        if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.LavalinkManager.emit("debug", "PlayerPlayUnresolvedTrackFailed" /* PlayerPlayUnresolvedTrackFailed */, {
+            state: "error",
+            error,
+            message: `Player Play was called, current Queue Song is unresolved, but couldn't resolve it`,
+            functionLayer: "Player > play() > resolve currentTrack"
+          });
+        }
         this.LavalinkManager.emit("trackError", this, this.queue.current, error);
         if (options && "clientTrack" in options) delete options.clientTrack;
         if (options && "track" in options) delete options.track;
@@ -4301,11 +4224,13 @@ var Player = class {
     ), 1e3), 0));
     const now = performance.now();
     if (this.LavalinkManager.options.playerOptions.applyVolumeAsFilter) {
-      this._emitDebugEvent("PlayerVolumeAsFilter" /* PlayerVolumeAsFilter */, {
-        state: "log",
-        message: `Player Volume was set as a Filter, because LavalinkManager option "playerOptions.applyVolumeAsFilter" is true`,
-        functionLayer: "Player > setVolume()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerVolumeAsFilter" /* PlayerVolumeAsFilter */, {
+          state: "log",
+          message: `Player Volume was set as a Filter, because LavalinkManager option "playerOptions.applyVolumeAsFilter" is true`,
+          functionLayer: "Player > setVolume()"
+        });
+      }
       await this.node.updatePlayer({ guildId: this.guildId, playerOptions: { filters: { volume: this.lavalinkVolume / 100 } } });
     } else {
       await this.node.updatePlayer({ guildId: this.guildId, playerOptions: { volume: this.lavalinkVolume } });
@@ -4350,11 +4275,13 @@ var Player = class {
   async search(query, requestUser, throwOnEmpty = false) {
     const Query = this.LavalinkManager.utils.transformQuery(query);
     if (["bcsearch", "bandcamp"].includes(Query.source) && !this.node.info?.sourceManagers.includes("bandcamp")) {
-      this._emitDebugEvent("BandcampSearchLokalEngine" /* BandcampSearchLokalEngine */, {
-        state: "log",
-        message: `Player.search was called with a Bandcamp Query, but no bandcamp search was enabled on lavalink, searching with the custom Search Engine.`,
-        functionLayer: "Player > search()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "BandcampSearchLokalEngine" /* BandcampSearchLokalEngine */, {
+          state: "log",
+          message: `Player.search was called with a Bandcamp Query, but no bandcamp search was enabled on lavalink, searching with the custom Search Engine.`,
+          functionLayer: "Player > search()"
+        });
+      }
       return await bandCampSearch(this, Query.query, requestUser);
     }
     return this.node.search(Query, requestUser, throwOnEmpty);
@@ -4506,11 +4433,13 @@ var Player = class {
       this.set("internal_queueempty", void 0);
     }
     if (this.get("internal_destroystatus") === true) {
-      this._emitDebugEvent("PlayerDestroyingSomewhereElse" /* PlayerDestroyingSomewhereElse */, {
-        state: "warn",
-        message: `Player is already destroying somewhere else..`,
-        functionLayer: "Player > destroy()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerDestroyingSomewhereElse" /* PlayerDestroyingSomewhereElse */, {
+          state: "warn",
+          message: `Player is already destroying somewhere else..`,
+          functionLayer: "Player > destroy()"
+        });
+      }
       if (this.LavalinkManager.options.advancedOptions?.debugOptions.playerDestroy.debugLog) console.log(`Lavalink-Client-Debug | PlayerDestroy [::] destroy Function, [guildId ${this.guildId}] - Already destroying somewhere else..`);
       return;
     }
@@ -4603,15 +4532,17 @@ var Player = class {
         const missingSources = [...trackSources].filter(
           (source) => !updateNode.info?.sourceManagers.includes(source)
         );
-        if (this.LavalinkManager.options.autoChecks?.sourcesValidations && missingSources.length)
+        if (missingSources.length)
           throw new RangeError(`Sources missing for Node ${updateNode.id}: ${missingSources.join(", ")}`);
       }
     }
-    this._emitDebugEvent("PlayerChangeNode" /* PlayerChangeNode */, {
-      state: "log",
-      message: `Player.changeNode() was executed, trying to change from "${this.node.id}" to "${updateNode.id}"`,
-      functionLayer: "Player > changeNode()"
-    });
+    if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.LavalinkManager.emit("debug", "PlayerChangeNode" /* PlayerChangeNode */, {
+        state: "log",
+        message: `Player.changeNode() was executed, trying to change from "${this.node.id}" to "${updateNode.id}"`,
+        functionLayer: "Player > changeNode()"
+      });
+    }
     const data = this.toJSON();
     const currentTrack = this.queue.current;
     if (!this.voice.endpoint || !this.voice.sessionId || !this.voice.token)
@@ -4622,26 +4553,30 @@ var Player = class {
     const now = performance.now();
     try {
       await this.connect();
-      const hasSponsorBlock = !this.LavalinkManager.options?.autoChecks?.pluginValidations || this.node.info?.plugins?.find((v) => v.name === "sponsorblock-plugin");
+      const hasSponsorBlock = this.node.info?.plugins?.find((v) => v.name === "sponsorblock-plugin");
       if (hasSponsorBlock) {
         const sponsorBlockCategories = this.get("internal_sponsorBlockCategories");
         if (Array.isArray(sponsorBlockCategories) && sponsorBlockCategories.length) {
           await this.setSponsorBlock(sponsorBlockCategories).catch((error) => {
-            this._emitDebugEvent("PlayerChangeNode" /* PlayerChangeNode */, {
-              state: "error",
-              error,
-              message: `Player > changeNode() Unable to set SponsorBlock Segments`,
-              functionLayer: "Player > changeNode()"
-            });
+            if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+              this.LavalinkManager.emit("debug", "PlayerChangeNode" /* PlayerChangeNode */, {
+                state: "error",
+                error,
+                message: `Player > changeNode() Unable to set SponsorBlock Segments`,
+                functionLayer: "Player > changeNode()"
+              });
+            }
           });
         } else {
           await this.setSponsorBlock().catch((error) => {
-            this._emitDebugEvent("PlayerChangeNode" /* PlayerChangeNode */, {
-              state: "error",
-              error,
-              message: `Player > changeNode() Unable to set SponsorBlock Segments`,
-              functionLayer: "Player > changeNode()"
-            });
+            if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+              this.LavalinkManager.emit("debug", "PlayerChangeNode" /* PlayerChangeNode */, {
+                state: "error",
+                error,
+                message: `Player > changeNode() Unable to set SponsorBlock Segments`,
+                functionLayer: "Player > changeNode()"
+              });
+            }
           });
         }
       }
@@ -4666,27 +4601,25 @@ var Player = class {
       this.ping.lavalink = Math.round((performance.now() - now) / 10) / 100;
       return this.node.id;
     } catch (error) {
-      this._emitDebugEvent("PlayerChangeNode" /* PlayerChangeNode */, {
-        state: "error",
-        error,
-        message: `Player.changeNode() execution failed`,
-        functionLayer: "Player > changeNode()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerChangeNode" /* PlayerChangeNode */, {
+          state: "error",
+          error,
+          message: `Player.changeNode() execution failed`,
+          functionLayer: "Player > changeNode()"
+        });
+      }
       throw new Error(`Failed to change the node: ${error}`);
     } finally {
       this.set("internal_nodeChanging", void 0);
     }
   }
   /**
-   * (Wrapper-FN for changeNode) Move the player to a different node. If no node is provided, it will find the least used node that is not the same as the current node.
+   * Move the player to a different node. If no node is provided, it will find the least used node that is not the same as the current node.
    * @param node the id of the node to move to
    * @returns the player
    * @throws RangeError if there is no available nodes.
    * @throws Error if the node to move to is the same as the current node.
-   * @example
-   * ```ts
-   * const newNodeMovedTo = await player.moveNode(); // no need to specify the new node, it will find a least used node automatically, but you can ofc. use a custom node id.
-   * ```
    */
   async moveNode(node) {
     try {
@@ -4722,7 +4655,8 @@ var Player = class {
       nodeId: this.node?.id,
       nodeSessionId: this.node?.sessionId,
       ping: this.ping,
-      queue: this.queue.utils.toJSON()
+      queue: this.queue.utils.toJSON(),
+      data: this.data
     };
   }
 };
@@ -4797,10 +4731,6 @@ var LavalinkManager = class extends import_events2.EventEmitter {
         id: options?.client?.id,
         username: options?.client?.username ?? "lavalink-client"
       },
-      autoChecks: {
-        sourcesValidations: options?.autoChecks?.sourcesValidations ?? true,
-        pluginValidations: options?.autoChecks?.pluginValidations ?? true
-      },
       sendToShard: options?.sendToShard,
       autoMove: options?.autoMove ?? false,
       nodes: options?.nodes,
@@ -4864,8 +4794,6 @@ var LavalinkManager = class extends import_events2.EventEmitter {
     if (options?.autoSkipOnResolveError && typeof options?.autoSkipOnResolveError !== "boolean") throw new SyntaxError("ManagerOption.autoSkipOnResolveError must be either false | true aka boolean");
     if (options?.emitNewSongsOnly && typeof options?.emitNewSongsOnly !== "boolean") throw new SyntaxError("ManagerOption.emitNewSongsOnly must be either false | true aka boolean");
     if (!options?.nodes || !Array.isArray(options?.nodes) || !options?.nodes.every((node) => this.utils.isNodeOptions(node))) throw new SyntaxError("ManagerOption.nodes must be an Array of NodeOptions and is required of at least 1 Node");
-    if (typeof options?.autoChecks?.sourcesValidations !== "boolean") throw new SyntaxError("ManagerOption.autoChecks.sourcesValidations must be either false | true aka boolean");
-    if (typeof options?.autoChecks?.pluginValidations !== "boolean") throw new SyntaxError("ManagerOption.autoChecks.pluginValidations must be either false | true aka boolean");
     if (options?.queueOptions?.queueStore) {
       const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(options?.queueOptions?.queueStore));
       const requiredKeys = ["get", "set", "stringify", "parse", "delete"];
@@ -4878,15 +4806,6 @@ var LavalinkManager = class extends import_events2.EventEmitter {
     }
     if (typeof options?.queueOptions?.maxPreviousTracks !== "number" || options?.queueOptions?.maxPreviousTracks < 0) options.queueOptions.maxPreviousTracks = 25;
   }
-  /**
-   * Emits a debug event to the LavalinkManager
-   * @param name name of the event
-   * @param eventData event data
-   */
-  _emitDebugEvent(name, eventData) {
-    if (!this.options?.advancedOptions?.enableDebugEvents) return;
-    this.emit("debug", name, eventData);
-  }
   /**
    * Create the Lavalink Manager
    * @param options
@@ -5036,11 +4955,13 @@ var LavalinkManager = class extends import_events2.EventEmitter {
     if (!oldPlayer) return;
     if (typeof oldPlayer.voiceChannelId === "string" && oldPlayer.connected && !oldPlayer.get("internal_destroywithoutdisconnect")) {
       if (!this.options?.advancedOptions?.debugOptions?.playerDestroy?.dontThrowError) throw new Error(`Use Player#destroy() not LavalinkManager#deletePlayer() to stop the Player ${safeStringify(oldPlayer.toJSON?.())}`);
-      this._emitDebugEvent("PlayerDeleteInsteadOfDestroy" /* PlayerDeleteInsteadOfDestroy */, {
-        state: "warn",
-        message: "Use Player#destroy() not LavalinkManager#deletePlayer() to stop the Player",
-        functionLayer: "LavalinkManager > deletePlayer()"
-      });
+      else if (this.options?.advancedOptions?.enableDebugEvents) {
+        this.emit("debug", "PlayerDeleteInsteadOfDestroy" /* PlayerDeleteInsteadOfDestroy */, {
+          state: "warn",
+          message: "Use Player#destroy() not LavalinkManager#deletePlayer() to stop the Player",
+          functionLayer: "LavalinkManager > deletePlayer()"
+        });
+      }
     }
     return this.players.delete(guildId);
   }
@@ -5088,11 +5009,13 @@ var LavalinkManager = class extends import_events2.EventEmitter {
       }
     }
     if (success > 0) this.initiated = true;
-    else this._emitDebugEvent("FailedToConnectToNodes" /* FailedToConnectToNodes */, {
-      state: "error",
-      message: "Failed to connect to at least 1 Node",
-      functionLayer: "LavalinkManager > init()"
-    });
+    else if (this.options?.advancedOptions?.enableDebugEvents) {
+      this.emit("debug", "FailedToConnectToNodes" /* FailedToConnectToNodes */, {
+        state: "error",
+        message: "Failed to connect to at least 1 Node",
+        functionLayer: "LavalinkManager > init()"
+      });
+    }
     return this;
   }
   /**
@@ -5112,20 +5035,24 @@ var LavalinkManager = class extends import_events2.EventEmitter {
    */
   async sendRawData(data) {
     if (!this.initiated) {
-      this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-        state: "log",
-        message: "Manager is not initated yet",
-        functionLayer: "LavalinkManager > sendRawData()"
-      });
+      if (this.options?.advancedOptions?.enableDebugEvents) {
+        this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+          state: "log",
+          message: "Manager is not initated yet",
+          functionLayer: "LavalinkManager > sendRawData()"
+        });
+      }
       if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, manager is not initated yet");
       return;
     }
     if (!("t" in data)) {
-      this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-        state: "error",
-        message: "No 't' in payload-data of the raw event:",
-        functionLayer: "LavalinkManager > sendRawData()"
-      });
+      if (this.options?.advancedOptions?.enableDebugEvents) {
+        this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+          state: "error",
+          message: "No 't' in payload-data of the raw event:",
+          functionLayer: "LavalinkManager > sendRawData()"
+        });
+      }
       if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, no 't' in payload-data of the raw event:", data);
       return;
     }
@@ -5138,39 +5065,47 @@ var LavalinkManager = class extends import_events2.EventEmitter {
     if (["VOICE_STATE_UPDATE", "VOICE_SERVER_UPDATE"].includes(data.t)) {
       const update = "d" in data ? data.d : data;
       if (!update) {
-        this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-          state: "warn",
-          message: `No Update data found in payload :: ${safeStringify(data, 2)}`,
-          functionLayer: "LavalinkManager > sendRawData()"
-        });
+        if (this.options?.advancedOptions?.enableDebugEvents) {
+          this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+            state: "warn",
+            message: `No Update data found in payload :: ${safeStringify(data, 2)}`,
+            functionLayer: "LavalinkManager > sendRawData()"
+          });
+        }
         if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, no update data found in payload:", data);
         return;
       }
       if (!("token" in update) && !("session_id" in update)) {
-        this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-          state: "error",
-          message: `No 'token' nor 'session_id' found in payload :: ${safeStringify(data, 2)}`,
-          functionLayer: "LavalinkManager > sendRawData()"
-        });
+        if (this.options?.advancedOptions?.enableDebugEvents) {
+          this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+            state: "error",
+            message: `No 'token' nor 'session_id' found in payload :: ${safeStringify(data, 2)}`,
+            functionLayer: "LavalinkManager > sendRawData()"
+          });
+        }
         if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, no 'token' nor 'session_id' found in payload:", data);
         return;
       }
       const player = this.getPlayer(update.guild_id);
       if (!player) {
-        this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-          state: "warn",
-          message: `No Lavalink Player found via key: 'guild_id' of update-data :: ${safeStringify(update, 2)}`,
-          functionLayer: "LavalinkManager > sendRawData()"
-        });
+        if (this.options?.advancedOptions?.enableDebugEvents) {
+          this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+            state: "warn",
+            message: `No Lavalink Player found via key: 'guild_id' of update-data :: ${safeStringify(update, 2)}`,
+            functionLayer: "LavalinkManager > sendRawData()"
+          });
+        }
         if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, No Lavalink Player found via key: 'guild_id' of update-data:", update);
         return;
       }
       if (player.get("internal_destroystatus") === true) {
-        this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-          state: "warn",
-          message: `Player is in a destroying state. can't signal the voice states`,
-          functionLayer: "LavalinkManager > sendRawData()"
-        });
+        if (this.options?.advancedOptions?.enableDebugEvents) {
+          this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+            state: "warn",
+            message: `Player is in a destroying state. can't signal the voice states`,
+            functionLayer: "LavalinkManager > sendRawData()"
+          });
+        }
         if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, Player is in a destroying state. can't signal the voice states");
         return;
       }
@@ -5195,11 +5130,13 @@ var LavalinkManager = class extends import_events2.EventEmitter {
               }
             }
           });
-          this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-            state: "log",
-            message: `Sent updatePlayer for voice token session :: ${safeStringify({ voice: { token: update.token, endpoint: update.endpoint, sessionId: sessionId2Use }, update, playerVoice: player.voice }, 2)}`,
-            functionLayer: "LavalinkManager > sendRawData()"
-          });
+          if (this.options?.advancedOptions?.enableDebugEvents) {
+            this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+              state: "log",
+              message: `Sent updatePlayer for voice token session :: ${safeStringify({ voice: { token: update.token, endpoint: update.endpoint, sessionId: sessionId2Use }, update, playerVoice: player.voice }, 2)}`,
+              functionLayer: "LavalinkManager > sendRawData()"
+            });
+          }
           if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, Sent updatePlayer for voice token session", { voice: { token: update.token, endpoint: update.endpoint, sessionId: sessionId2Use }, playerVoice: player.voice, update });
         }
         return;
@@ -5208,11 +5145,13 @@ var LavalinkManager = class extends import_events2.EventEmitter {
         if (update.user_id && player.voiceChannelId) {
           this.emit(update.channel_id === player.voiceChannelId ? "playerVoiceJoin" : "playerVoiceLeave", player, update.user_id);
         }
-        this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-          state: "warn",
-          message: `voice update user is not equal to provided client id of the LavalinkManager.options.client.id :: user: "${update.user_id}" manager client id: "${this.options?.client.id}"`,
-          functionLayer: "LavalinkManager > sendRawData()"
-        });
+        if (this.options?.advancedOptions?.enableDebugEvents) {
+          this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+            state: "warn",
+            message: `voice update user is not equal to provided client id of the LavalinkManager.options.client.id :: user: "${update.user_id}" manager client id: "${this.options?.client.id}"`,
+            functionLayer: "LavalinkManager > sendRawData()"
+          });
+        }
         if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, voice update user is not equal to provided client id of the manageroptions#client#id", "user:", update.user_id, "manager client id:", this.options?.client.id);
         return;
       }
@@ -5220,11 +5159,13 @@ var LavalinkManager = class extends import_events2.EventEmitter {
         if (player.voiceChannelId !== update.channel_id) this.emit("playerMove", player, player.voiceChannelId, update.channel_id);
         player.voice.sessionId = update.session_id || player.voice.sessionId;
         if (!player.voice.sessionId) {
-          this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-            state: "warn",
-            message: `Function to assing sessionId provided, but no found in Payload: ${safeStringify({ update, playerVoice: player.voice }, 2)}`,
-            functionLayer: "LavalinkManager > sendRawData()"
-          });
+          if (this.options?.advancedOptions?.enableDebugEvents) {
+            this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+              state: "warn",
+              message: `Function to assing sessionId provided, but no found in Payload: ${safeStringify({ update, playerVoice: player.voice }, 2)}`,
+              functionLayer: "LavalinkManager > sendRawData()"
+            });
+          }
           if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug(`Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, Function to assing sessionId provided, but no found in Payload: ${safeStringify(update, 2)}`);
         }
         player.voiceChannelId = update.channel_id;
@@ -5255,11 +5196,13 @@ var LavalinkManager = class extends import_events2.EventEmitter {
           try {
             const previousPosition = player.position;
             const previousPaused = player.paused;
-            this._emitDebugEvent("PlayerAutoReconnect" /* PlayerAutoReconnect */, {
-              state: "log",
-              message: `Auto reconnecting player because LavalinkManager.options.playerOptions.onDisconnect.autoReconnect is true`,
-              functionLayer: "LavalinkManager > sendRawData()"
-            });
+            if (this.options?.advancedOptions?.enableDebugEvents) {
+              this.emit("debug", "PlayerAutoReconnect" /* PlayerAutoReconnect */, {
+                state: "log",
+                message: `Auto reconnecting player because LavalinkManager.options.playerOptions.onDisconnect.autoReconnect is true`,
+                functionLayer: "LavalinkManager > sendRawData()"
+              });
+            }
             if (!autoReconnectOnlyWithTracks || autoReconnectOnlyWithTracks && (player.queue.current || player.queue.tracks.length)) {
               await player.connect();
             }
@@ -5269,11 +5212,13 @@ var LavalinkManager = class extends import_events2.EventEmitter {
             if (player.queue.tracks.length) {
               return void await player.play({ paused: previousPaused });
             }
-            this._emitDebugEvent("PlayerAutoReconnect" /* PlayerAutoReconnect */, {
-              state: "log",
-              message: `Auto reconnected, but nothing to play`,
-              functionLayer: "LavalinkManager > sendRawData()"
-            });
+            if (this.options?.advancedOptions?.enableDebugEvents) {
+              this.emit("debug", "PlayerAutoReconnect" /* PlayerAutoReconnect */, {
+                state: "log",
+                message: `Auto reconnected, but nothing to play`,
+                functionLayer: "LavalinkManager > sendRawData()"
+              });
+            }
             return;
           } catch (e) {
             console.error(e);
diff --git a/node_modules/lavalink-client/dist/index.mjs b/node_modules/lavalink-client/dist/index.mjs
index f70f953..989a3e8 100644
--- a/node_modules/lavalink-client/dist/index.mjs
+++ b/node_modules/lavalink-client/dist/index.mjs
@@ -44,9 +44,6 @@ var DebugEvents = /* @__PURE__ */ ((DebugEvents2) => {
   DebugEvents2["FailedToConnectToNodes"] = "FailedToConnectToNodes";
   DebugEvents2["NoAudioDebug"] = "NoAudioDebug";
   DebugEvents2["PlayerAutoReconnect"] = "PlayerAutoReconnect";
-  DebugEvents2["PlayerDestroyFail"] = "PlayerDestroyFail";
-  DebugEvents2["PlayerChangeNodeFailNoEligibleNode"] = "PlayerChangeNodeFailNoEligibleNode";
-  DebugEvents2["PlayerChangeNodeFail"] = "PlayerChangeNodeFail";
   return DebugEvents2;
 })(DebugEvents || {});
 var DestroyReasons = /* @__PURE__ */ ((DestroyReasons2) => {
@@ -310,15 +307,6 @@ import { EventEmitter } from "events";
 import { isAbsolute } from "path";
 import WebSocket from "ws";
 
-// src/structures/Types/Node.ts
-var ReconnectionState = /* @__PURE__ */ ((ReconnectionState2) => {
-  ReconnectionState2["IDLE"] = "IDLE";
-  ReconnectionState2["RECONNECTING"] = "RECONNECTING";
-  ReconnectionState2["PENDING"] = "PENDING";
-  ReconnectionState2["DESTROYING"] = "DESTROYING";
-  return ReconnectionState2;
-})(ReconnectionState || {});
-
 // src/structures/Utils.ts
 import { URL as URL2 } from "url";
 import { isRegExp } from "util/types";
@@ -483,10 +471,10 @@ var SourceLinksRegexes = {
 };
 
 // src/structures/Utils.ts
-var TrackSymbol = Symbol("LC-Track");
-var UnresolvedTrackSymbol = Symbol("LC-Track-Unresolved");
-var QueueSymbol = Symbol("LC-Queue");
-var NodeSymbol = Symbol("LC-Node");
+var TrackSymbol = /* @__PURE__ */ Symbol("LC-Track");
+var UnresolvedTrackSymbol = /* @__PURE__ */ Symbol("LC-Track-Unresolved");
+var QueueSymbol = /* @__PURE__ */ Symbol("LC-Queue");
+var NodeSymbol = /* @__PURE__ */ Symbol("LC-Node");
 var escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
 function parseLavalinkConnUrl(connectionUrl) {
   if (!connectionUrl.startsWith("lavalink://")) throw new Error(`ConnectionUrl (${connectionUrl}) must start with 'lavalink://'`);
@@ -690,7 +678,7 @@ var ManagerUtils = class {
   }
   validateQueryString(node, queryString, sourceString) {
     if (!node.info) throw new Error("No Lavalink Node was provided");
-    if (this.LavalinkManager.options?.autoChecks?.sourcesValidations && !node.info.sourceManagers?.length) throw new Error("Lavalink Node, has no sourceManagers enabled");
+    if (!node.info.sourceManagers?.length) throw new Error("Lavalink Node, has no sourceManagers enabled");
     if (!queryString.trim().length) throw new Error(`Query string is empty, please provide a valid query string.`);
     if (sourceString === "speak" && queryString.length > 100) throw new Error(`Query is speak, which is limited to 100 characters.`);
     if (this.LavalinkManager.options?.linksBlacklist?.length > 0) {
@@ -719,7 +707,6 @@ var ManagerUtils = class {
         throw new Error(`Query string contains a link / word which isn't whitelisted.`);
       }
     }
-    if (!this.LavalinkManager.options?.autoChecks?.sourcesValidations) return;
     if ((SourceLinksRegexes.YoutubeMusicRegex.test(queryString) || SourceLinksRegexes.YoutubeRegex.test(queryString)) && !node.info?.sourceManagers?.includes("youtube")) {
       throw new Error("Query / Link Provided for this Source but Lavalink Node has not 'youtube' enabled");
     }
@@ -803,7 +790,6 @@ var ManagerUtils = class {
     const source = DefaultSources[sourceString.toLowerCase().trim()];
     if (!source) throw new Error(`Lavalink Node SearchQuerySource: '${sourceString}' is not available`);
     if (!node.info) throw new Error("Lavalink Node does not have any info cached yet, not ready yet!");
-    if (!this.LavalinkManager.options?.autoChecks?.sourcesValidations) return;
     if (source === "amsearch" && !node.info?.sourceManagers?.includes("applemusic")) {
       throw new Error("Lavalink Node has not 'applemusic' enabled, which is required to have 'amsearch' work");
     }
@@ -825,7 +811,7 @@ var ManagerUtils = class {
     if (source === "scsearch" && !node.info?.sourceManagers?.includes("soundcloud")) {
       throw new Error("Lavalink Node has not 'soundcloud' enabled, which is required to have 'scsearch' work");
     }
-    if (source === "speak" && this.LavalinkManager.options?.autoChecks?.pluginValidations && !node.info?.plugins?.find((c) => c.name.toLowerCase().includes(LavalinkPlugins.DuncteBot_Plugin.toLowerCase()))) {
+    if (source === "speak" && !node.info?.plugins?.find((c) => c.name.toLowerCase().includes(LavalinkPlugins.DuncteBot_Plugin.toLowerCase()))) {
       throw new Error("Lavalink Node has not 'speak' enabled, which is required to have 'speak' work");
     }
     if (source === "tdsearch" && !node.info?.sourceManagers?.includes("tidal")) {
@@ -834,7 +820,7 @@ var ManagerUtils = class {
     if (source === "tdrec" && !node.info?.sourceManagers?.includes("tidal")) {
       throw new Error("Lavalink Node has not 'tidal' enabled, which is required to have 'tdrec' work");
     }
-    if (source === "tts" && this.LavalinkManager.options?.autoChecks?.pluginValidations && !node.info?.plugins?.find((c) => c.name.toLowerCase().includes(LavalinkPlugins.GoogleCloudTTS.toLowerCase()))) {
+    if (source === "tts" && !node.info?.plugins?.find((c) => c.name.toLowerCase().includes(LavalinkPlugins.GoogleCloudTTS.toLowerCase()))) {
       throw new Error("Lavalink Node has not 'tts' enabled, which is required to have 'tts' work");
     }
     if (source === "ftts" && !(node.info?.sourceManagers?.includes("ftts") || node.info?.sourceManagers?.includes("flowery-tts") || node.info?.sourceManagers?.includes("flowerytts"))) {
@@ -843,7 +829,7 @@ var ManagerUtils = class {
     if (source === "ymsearch" && !node.info?.sourceManagers?.includes("yandexmusic")) {
       throw new Error("Lavalink Node has not 'yandexmusic' enabled, which is required to have 'ymsearch' work");
     }
-    if (source === "ytmsearch" && !node.info?.sourceManagers?.includes("youtube")) {
+    if (source === "ytmsearch" && !node.info.sourceManagers?.includes("youtube")) {
       throw new Error("Lavalink Node has not 'youtube' enabled, which is required to have 'ytmsearch' work");
     }
     if (source === "ytsearch" && !node.info?.sourceManagers?.includes("youtube")) {
@@ -982,10 +968,22 @@ function safeStringify(obj, padding = 0) {
   }, padding);
 }
 
+// src/structures/Types/Node.ts
+var ReconnectionState = /* @__PURE__ */ ((ReconnectionState2) => {
+  ReconnectionState2["IDLE"] = "IDLE";
+  ReconnectionState2["RECONNECTING"] = "RECONNECTING";
+  ReconnectionState2["PENDING"] = "PENDING";
+  ReconnectionState2["DESTROYING"] = "DESTROYING";
+  return ReconnectionState2;
+})(ReconnectionState || {});
+
 // src/structures/Node.ts
 var LavalinkNode = class {
   heartBeatPingTimestamp = 0;
   heartBeatPongTimestamp = 0;
+  get heartBeatPing() {
+    return this.heartBeatPongTimestamp - this.heartBeatPingTimestamp;
+  }
   heartBeatInterval;
   pingTimeout;
   isAlive = false;
@@ -1009,17 +1007,6 @@ var LavalinkNode = class {
       used: 0
     },
     uptime: 0,
-    /** something from nodeLink https://nodelink.js.org/docs/differences#detailed-statistics */
-    detailedStats: {
-      api: {
-        requests: {},
-        errors: {}
-      },
-      sources: {},
-      playback: {
-        events: {}
-      }
-    },
     frameStats: {
       deficit: 0,
       nulled: 0,
@@ -1032,80 +1019,18 @@ var LavalinkNode = class {
   resuming = { enabled: true, timeout: null };
   /** Actual Lavalink Information of the Node */
   info = null;
-  /** current state of the Reconnections */
-  reconnectionState = "IDLE" /* IDLE */;
   /** The Node Manager of this Node */
   NodeManager = null;
   /** The Reconnection Timeout */
   reconnectTimeout = void 0;
-  /** The Reconnection Attempt counter (array of datetimes when it tried it.) */
-  reconnectAttempts = [];
+  /** The Reconnection Attempt counter */
+  reconnectAttempts = 1;
+  /** Reconnection current state */
+  reconnectionState = "IDLE" /* IDLE */;
   /** The Socket of the Lavalink */
   socket = null;
   /** Version of what the Lavalink Server should be */
   version = "v4";
-  /**
-   * Returns the LavalinkManager of the Node
-   */
-  get _LManager() {
-    return this.NodeManager.LavalinkManager;
-  }
-  /**
-   * Returns the Heartbeat Ping of the Node
-   */
-  get heartBeatPing() {
-    return this.heartBeatPongTimestamp - this.heartBeatPingTimestamp;
-  }
-  /**
-   * Returns wether the plugin validations are enabled or not
-   */
-  get _checkForPlugins() {
-    return !!this._LManager.options?.autoChecks?.pluginValidations;
-  }
-  /**
-   * Returns wether the source validations are enabled or not
-   */
-  get _checkForSources() {
-    return !!this._LManager.options?.autoChecks?.sourcesValidations;
-  }
-  /**
-   * Emits a debug event to the LavalinkManager
-   * @param name name of the event
-   * @param eventData event data
-   */
-  _emitDebugEvent(name, eventData) {
-    if (!this._LManager.options?.advancedOptions?.enableDebugEvents) return;
-    this._LManager.emit("debug", name, eventData);
-  }
-  /**
-   * Returns if connected to the Node.
-   *
-   * @example
-   * ```ts
-   * const isConnected = player.node.connected;
-   * console.log("node is connected: ", isConnected ? "yes" : "no")
-   * ```
-   */
-  get connected() {
-    return this.socket && this.socket.readyState === WebSocket.OPEN;
-  }
-  /**
-   * Returns the current ConnectionStatus
-   *
-   * @example
-   * ```ts
-   * try {
-   *     const statusOfConnection = player.node.connectionStatus;
-   *     console.log("node's connection status is:", statusOfConnection)
-   * } catch (error) {
-   *     console.error("no socket available?", error)
-   * }
-   * ```
-   */
-  get connectionStatus() {
-    if (!this.socket) throw new Error("no websocket was initialized yet");
-    return ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][this.socket.readyState] || "UNKNOWN";
-  }
   /**
    * Create a new Node
    * @param options Lavalink Node Options
@@ -1124,7 +1049,6 @@ var LavalinkNode = class {
       secure: false,
       retryAmount: 5,
       retryDelay: 1e4,
-      retryTimespan: -1,
       requestSignalTimeoutMS: 1e4,
       heartBeatInterval: 3e4,
       closeOnError: true,
@@ -1195,10 +1119,10 @@ var LavalinkNode = class {
    * ```
    */
   async search(query, requestUser, throwOnEmpty = false) {
-    const Query = this._LManager.utils.transformQuery(query);
-    this._LManager.utils.validateQueryString(this, Query.query, Query.source);
-    if (Query.source) this._LManager.utils.validateSourceString(this, Query.source);
-    if (["bcsearch", "bandcamp"].includes(Query.source) && this._LManager.options?.autoChecks?.sourcesValidations && !this.info.sourceManagers.includes("bandcamp")) {
+    const Query = this.NodeManager.LavalinkManager.utils.transformQuery(query);
+    this.NodeManager.LavalinkManager.utils.validateQueryString(this, Query.query, Query.source);
+    if (Query.source) this.NodeManager.LavalinkManager.utils.validateSourceString(this, Query.source);
+    if (["bcsearch", "bandcamp"].includes(Query.source) && !this.info.sourceManagers.includes("bandcamp")) {
       throw new Error("Bandcamp Search only works on the player (lavaplayer version < 2.2.0!");
     }
     const requestUrl = new URL(`${this.restAddress}/loadtracks`);
@@ -1217,11 +1141,13 @@ var LavalinkNode = class {
     });
     const resTracks = res.loadType === "playlist" ? res.data?.tracks : res.loadType === "track" ? [res.data] : res.loadType === "search" ? Array.isArray(res.data) ? res.data : [res.data] : [];
     if (throwOnEmpty === true && (res.loadType === "empty" || !resTracks.length)) {
-      this._emitDebugEvent("SearchNothingFound" /* SearchNothingFound */, {
-        state: "warn",
-        message: `Search found nothing for Request: "${Query.source ? `${Query.source}:` : ""}${Query.query}"`,
-        functionLayer: "(LavalinkNode > node | player) > search()"
-      });
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "SearchNothingFound" /* SearchNothingFound */, {
+          state: "warn",
+          message: `Search found nothing for Request: "${Query.source ? `${Query.source}:` : ""}${Query.query}"`,
+          functionLayer: "(LavalinkNode > node | player) > search()"
+        });
+      }
       throw new Error("Nothing found");
     }
     return {
@@ -1234,10 +1160,10 @@ var LavalinkNode = class {
         author: res.data.info?.author || res.data.pluginInfo?.author || null,
         thumbnail: res.data.info?.artworkUrl || res.data.pluginInfo?.artworkUrl || (typeof res.data?.info?.selectedTrack !== "number" || res.data?.info?.selectedTrack === -1 ? null : resTracks[res.data?.info?.selectedTrack] ? resTracks[res.data?.info?.selectedTrack]?.info?.artworkUrl || resTracks[res.data?.info?.selectedTrack]?.info?.pluginInfo?.artworkUrl : null) || null,
         uri: res.data.info?.url || res.data.info?.uri || res.data.info?.link || res.data.pluginInfo?.url || res.data.pluginInfo?.uri || res.data.pluginInfo?.link || null,
-        selectedTrack: typeof res.data?.info?.selectedTrack !== "number" || res.data?.info?.selectedTrack === -1 ? null : resTracks[res.data?.info?.selectedTrack] ? this._LManager.utils.buildTrack(resTracks[res.data?.info?.selectedTrack], requestUser) : null,
+        selectedTrack: typeof res.data?.info?.selectedTrack !== "number" || res.data?.info?.selectedTrack === -1 ? null : resTracks[res.data?.info?.selectedTrack] ? this.NodeManager.LavalinkManager.utils.buildTrack(resTracks[res.data?.info?.selectedTrack], requestUser) : null,
         duration: resTracks.length ? resTracks.reduce((acc, cur) => acc + (cur?.info?.duration || cur?.info?.length || 0), 0) : 0
       } : null,
-      tracks: resTracks.length ? resTracks.map((t) => this._LManager.utils.buildTrack(t, requestUser)) : []
+      tracks: resTracks.length ? resTracks.map((t) => this.NodeManager.LavalinkManager.utils.buildTrack(t, requestUser)) : []
     };
   }
   /**
@@ -1254,27 +1180,29 @@ var LavalinkNode = class {
    * ```
    */
   async lavaSearch(query, requestUser, throwOnEmpty = false) {
-    const Query = this._LManager.utils.transformLavaSearchQuery(query);
-    if (Query.source) this._LManager.utils.validateSourceString(this, Query.source);
+    const Query = this.NodeManager.LavalinkManager.utils.transformLavaSearchQuery(query);
+    if (Query.source) this.NodeManager.LavalinkManager.utils.validateSourceString(this, Query.source);
     if (/^https?:\/\//.test(Query.query)) return this.search({ query: Query.query, source: Query.source }, requestUser);
     if (!["spsearch", "sprec", "amsearch", "dzsearch", "dzisrc", "ytmsearch", "ytsearch"].includes(Query.source)) throw new SyntaxError(`Query.source must be a source from LavaSrc: "spsearch" | "sprec" | "amsearch" | "dzsearch" | "dzisrc" | "ytmsearch" | "ytsearch"`);
-    if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavasearch-plugin")) throw new RangeError(`there is no lavasearch-plugin available in the lavalink node: ${this.id}`);
-    if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavasrc-plugin")) throw new RangeError(`there is no lavasrc-plugin available in the lavalink node: ${this.id}`);
+    if (!this.info.plugins.find((v) => v.name === "lavasearch-plugin")) throw new RangeError(`there is no lavasearch-plugin available in the lavalink node: ${this.id}`);
+    if (!this.info.plugins.find((v) => v.name === "lavasrc-plugin")) throw new RangeError(`there is no lavasrc-plugin available in the lavalink node: ${this.id}`);
     const { response } = await this.rawRequest(`/loadsearch?query=${Query.source ? `${Query.source}:` : ""}${encodeURIComponent(Query.query)}${Query.types?.length ? `&types=${Query.types.join(",")}` : ""}`);
     const res = response.status === 204 ? {} : await response.json();
     if (throwOnEmpty === true && !Object.entries(res).flat().filter(Boolean).length) {
-      this._emitDebugEvent("LavaSearchNothingFound" /* LavaSearchNothingFound */, {
-        state: "warn",
-        message: `LavaSearch found nothing for Request: "${Query.source ? `${Query.source}:` : ""}${Query.query}"`,
-        functionLayer: "(LavalinkNode > node | player) > lavaSearch()"
-      });
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "LavaSearchNothingFound" /* LavaSearchNothingFound */, {
+          state: "warn",
+          message: `LavaSearch found nothing for Request: "${Query.source ? `${Query.source}:` : ""}${Query.query}"`,
+          functionLayer: "(LavalinkNode > node | player) > lavaSearch()"
+        });
+      }
       throw new Error("Nothing found");
     }
     return {
-      tracks: res.tracks?.map((v) => this._LManager.utils.buildTrack(v, requestUser)) || [],
-      albums: res.albums?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this._LManager.utils.buildTrack(v2, requestUser)) })) || [],
-      artists: res.artists?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this._LManager.utils.buildTrack(v2, requestUser)) })) || [],
-      playlists: res.playlists?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this._LManager.utils.buildTrack(v2, requestUser)) })) || [],
+      tracks: res.tracks?.map((v) => this.NodeManager.LavalinkManager.utils.buildTrack(v, requestUser)) || [],
+      albums: res.albums?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this.NodeManager.LavalinkManager.utils.buildTrack(v2, requestUser)) })) || [],
+      artists: res.artists?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this.NodeManager.LavalinkManager.utils.buildTrack(v2, requestUser)) })) || [],
+      playlists: res.playlists?.map((v) => ({ info: v.info, pluginInfo: v?.plugin || v.pluginInfo, tracks: v.tracks.map((v2) => this.NodeManager.LavalinkManager.utils.buildTrack(v2, requestUser)) })) || [],
       texts: res.texts?.map((v) => ({ text: v.text, pluginInfo: v?.plugin || v.pluginInfo })) || [],
       pluginInfo: res.pluginInfo || res?.plugin
     };
@@ -1303,11 +1231,13 @@ var LavalinkNode = class {
         r.path = url.pathname + url.search;
       }
     });
-    this._emitDebugEvent("PlayerUpdateSuccess" /* PlayerUpdateSuccess */, {
-      state: "log",
-      message: `Player get's updated with following payload :: ${safeStringify(data.playerOptions, 3)}`,
-      functionLayer: "LavalinkNode > node > updatePlayer()"
-    });
+    if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.NodeManager.LavalinkManager.emit("debug", "PlayerUpdateSuccess" /* PlayerUpdateSuccess */, {
+        state: "log",
+        message: `Player get's updated with following payload :: ${safeStringify(data.playerOptions, 3)}`,
+        functionLayer: "LavalinkNode > node > updatePlayer()"
+      });
+    }
     this.syncPlayerData({}, res);
     return res;
   }
@@ -1343,17 +1273,19 @@ var LavalinkNode = class {
    */
   connect(sessionId) {
     if (this.connected) {
-      this._emitDebugEvent("TryingConnectWhileConnected" /* TryingConnectWhileConnected */, {
-        state: "warn",
-        message: `Tryed to connect to node, but it's already connected!`,
-        functionLayer: "LavalinkNode > node > connect()"
-      });
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "TryingConnectWhileConnected" /* TryingConnectWhileConnected */, {
+          state: "warn",
+          message: `Tryed to connect to node, but it's already connected!`,
+          functionLayer: "LavalinkNode > node > connect()"
+        });
+      }
       return;
     }
     const headers = {
       Authorization: this.options.authorization,
-      "User-Id": this._LManager.options.client.id,
-      "Client-Name": this._LManager.options.client.username || "Lavalink-Client"
+      "User-Id": this.NodeManager.LavalinkManager.options.client.id,
+      "Client-Name": this.NodeManager.LavalinkManager.options.client.username || "Lavalink-Client"
     };
     if (typeof this.options.sessionId === "string" || typeof sessionId === "string") {
       headers["Session-Id"] = this.options.sessionId || sessionId;
@@ -1366,27 +1298,33 @@ var LavalinkNode = class {
     this.socket.on("error", this.error.bind(this));
   }
   heartBeat() {
-    this._emitDebugEvent("HeartBeatTriggered" /* HeartBeatTriggered */, {
-      state: "log",
-      message: `Node Socket Heartbeat triggered, resetting old Timeout to 65000ms (should happen every 60s due to /stats event)`,
-      functionLayer: "LavalinkNode > nodeEvent > stats > heartBeat()"
-    });
+    if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.NodeManager.LavalinkManager.emit("debug", "HeartBeatTriggered" /* HeartBeatTriggered */, {
+        state: "log",
+        message: `Node Socket Heartbeat triggered, resetting old Timeout to 65000ms (should happen every 60s due to /stats event)`,
+        functionLayer: "LavalinkNode > nodeEvent > stats > heartBeat()"
+      });
+    }
     this.resetAckTimeouts(false, true);
-    if (this.pingTimeout) clearTimeout(this.pingTimeout);
     this.pingTimeout = setTimeout(() => {
       this.pingTimeout = null;
       if (!this.socket) {
-        return this._emitDebugEvent("NoSocketOnDestroy" /* NoSocketOnDestroy */, {
-          state: "error",
-          message: `Heartbeat registered a disconnect, but socket didn't exist therefore can't terminate`,
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "NoSocketOnDestroy" /* NoSocketOnDestroy */, {
+            state: "error",
+            message: `Heartbeat registered a disconnect, but socket didn't exist therefore can't terminate`,
+            functionLayer: "LavalinkNode > nodeEvent > stats > heartBeat() > timeoutHit"
+          });
+        }
+        return;
+      }
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "SocketTerminateHeartBeatTimeout" /* SocketTerminateHeartBeatTimeout */, {
+          state: "warn",
+          message: `Heartbeat registered a disconnect, because timeout wasn't resetted in time. Terminating Web-Socket`,
           functionLayer: "LavalinkNode > nodeEvent > stats > heartBeat() > timeoutHit"
         });
       }
-      this._emitDebugEvent("SocketTerminateHeartBeatTimeout" /* SocketTerminateHeartBeatTimeout */, {
-        state: "warn",
-        message: `Heartbeat registered a disconnect, because timeout wasn't resetted in time. Terminating Web-Socket`,
-        functionLayer: "LavalinkNode > nodeEvent > stats > heartBeat() > timeoutHit"
-      });
       this.isAlive = false;
       this.socket.terminate();
     }, 65e3);
@@ -1422,75 +1360,71 @@ var LavalinkNode = class {
    */
   destroy(destroyReason, deleteNode = true, movePlayers = false) {
     this.reconnectionState = "IDLE" /* IDLE */;
-    const players = this._LManager.players.filter((p) => p.node.id === this.id);
-    if (!players?.size) {
+    const players = this.NodeManager.LavalinkManager.players.filter((p) => p.node.id === this.id);
+    if (players.size) {
+      const enableDebugEvents = this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents;
+      const handlePlayerOperations = () => {
+        if (movePlayers) {
+          const nodeToMove = Array.from(this.NodeManager.leastUsedNodes("playingPlayers")).find((n) => n.connected && n.options.id !== this.id);
+          if (nodeToMove) {
+            return Promise.allSettled(Array.from(players.values()).map(
+              (player) => player.changeNode(nodeToMove.options.id).catch((error) => {
+                if (enableDebugEvents) {
+                  console.error(`Node > destroy() Failed to move player ${player.guildId}: ${error.message}`);
+                }
+                return player.destroy(error.message ?? "PlayerChangeNodeFail" /* PlayerChangeNodeFail */).catch((destroyError) => {
+                  if (enableDebugEvents) {
+                    console.error(`Node > destroy() Failed to destroy player ${player.guildId} after move failure: ${destroyError.message}`);
+                  }
+                });
+              })
+            ));
+          } else {
+            return Promise.allSettled(Array.from(players.values()).map(
+              (player) => player.destroy("PlayerChangeNodeFailNoEligibleNode" /* PlayerChangeNodeFailNoEligibleNode */).catch((error) => {
+                if (enableDebugEvents) {
+                  console.error(`Node > destroy() Failed to destroy player ${player.guildId}: ${error.message}`);
+                }
+              })
+            ));
+          }
+        } else {
+          return Promise.allSettled(Array.from(players.values()).map(
+            (player) => player.destroy(destroyReason || "NodeDestroy" /* NodeDestroy */).catch((error) => {
+              if (enableDebugEvents) {
+                console.error(`Node > destroy() Failed to destroy player ${player.guildId}: ${error.message}`);
+              }
+            })
+          ));
+        }
+      };
+      handlePlayerOperations().finally(() => {
+        this.socket?.close(1e3, "Node-Destroy");
+        this.socket?.removeAllListeners();
+        this.socket = null;
+        this.resetReconnectionAttempts();
+        if (deleteNode) {
+          this.NodeManager.emit("destroy", this, destroyReason);
+          this.NodeManager.nodes.delete(this.id);
+          this.resetAckTimeouts(true, true);
+        } else {
+          this.NodeManager.emit("disconnect", this, { code: 1e3, reason: destroyReason });
+        }
+      });
+    } else {
       this.socket?.close(1e3, "Node-Destroy");
       this.socket?.removeAllListeners();
       this.socket = null;
       this.resetReconnectionAttempts();
-      if (!deleteNode) return void this.NodeManager.emit("disconnect", this, { code: 1e3, reason: destroyReason });
-      ;
-      this.NodeManager.emit("destroy", this, destroyReason);
-      this.NodeManager.nodes.delete(this.id);
-      this.resetAckTimeouts(true, true);
-      return;
-    }
-    const handlePlayerOperations = () => {
-      if (!movePlayers) {
-        return Promise.allSettled(Array.from(players.values()).map(
-          (player) => player.destroy(destroyReason || "NodeDestroy" /* NodeDestroy */).catch((error) => {
-            this._emitDebugEvent("PlayerDestroyFail" /* PlayerDestroyFail */, {
-              state: "error",
-              message: `Failed to destroy player ${player.guildId}: ${error.message}`,
-              error,
-              functionLayer: "Node > destroy() > movePlayers"
-            });
-          })
-        ));
-      }
-      const nodeToMove = Array.from(this.NodeManager.leastUsedNodes("playingPlayers")).find((n) => n.connected && n.options.id !== this.id);
-      if (!nodeToMove) {
-        return Promise.allSettled(Array.from(players.values()).map(
-          (player) => player.destroy("PlayerChangeNodeFailNoEligibleNode" /* PlayerChangeNodeFailNoEligibleNode */).catch((error) => {
-            this._emitDebugEvent("PlayerChangeNodeFailNoEligibleNode" /* PlayerChangeNodeFailNoEligibleNode */, {
-              state: "error",
-              message: `Failed to destroy player ${player.guildId}: ${error.message}`,
-              error,
-              functionLayer: "Node > destroy() > movePlayers"
-            });
-          })
-        ));
+      if (deleteNode) {
+        this.NodeManager.emit("destroy", this, destroyReason);
+        this.NodeManager.nodes.delete(this.id);
+        this.resetAckTimeouts(true, true);
+      } else {
+        this.NodeManager.emit("disconnect", this, { code: 1e3, reason: destroyReason });
       }
-      return Promise.allSettled(Array.from(players.values()).map(
-        (player) => player.changeNode(nodeToMove.options.id).catch((error) => {
-          this._emitDebugEvent("PlayerChangeNodeFail" /* PlayerChangeNodeFail */, {
-            state: "error",
-            message: `Failed to move player ${player.guildId}: ${error.message}`,
-            error,
-            functionLayer: "Node > destroy() > movePlayers"
-          });
-          return player.destroy(error.message ?? "PlayerChangeNodeFail" /* PlayerChangeNodeFail */).catch((destroyError) => {
-            this._emitDebugEvent("PlayerDestroyFail" /* PlayerDestroyFail */, {
-              state: "error",
-              message: `Failed to destroy player ${player.guildId} after move failure: ${destroyError.message}`,
-              error: destroyError,
-              functionLayer: "Node > destroy() > movePlayers"
-            });
-          });
-        })
-      ));
-    };
-    return void handlePlayerOperations().finally(() => {
-      this.socket?.close(1e3, "Node-Destroy");
-      this.socket?.removeAllListeners();
-      this.socket = null;
-      this.resetReconnectionAttempts();
-      if (!deleteNode) return void this.NodeManager.emit("disconnect", this, { code: 1e3, reason: destroyReason });
-      this.NodeManager.emit("destroy", this, destroyReason);
-      this.NodeManager.nodes.delete(this.id);
-      this.resetAckTimeouts(true, true);
-      return;
-    });
+    }
+    return;
   }
   /**
    * Disconnects the Node-Connection (Websocket)
@@ -1501,7 +1435,7 @@ var LavalinkNode = class {
    *
    * @example
    * ```ts
-   * player.node.disconnect("Forcefully disconnect the connection to the node.");
+   * player.node.destroy("custom Player Destroy Reason", true);
    * ```
    */
   disconnect(disconnectReason) {
@@ -1513,6 +1447,35 @@ var LavalinkNode = class {
     this.resetReconnectionAttempts();
     this.NodeManager.emit("disconnect", this, { code: 1e3, reason: disconnectReason });
   }
+  /**
+   * Returns if connected to the Node.
+   *
+   * @example
+   * ```ts
+   * const isConnected = player.node.connected;
+   * console.log("node is connected: ", isConnected ? "yes" : "no")
+   * ```
+   */
+  get connected() {
+    return this.socket && this.socket.readyState === WebSocket.OPEN;
+  }
+  /**
+   * Returns the current ConnectionStatus
+   *
+   * @example
+   * ```ts
+   * try {
+   *     const statusOfConnection = player.node.connectionStatus;
+   *     console.log("node's connection status is:", statusOfConnection)
+   * } catch (error) {
+   *     console.error("no socket available?", error)
+   * }
+   * ```
+   */
+  get connectionStatus() {
+    if (!this.socket) throw new Error("no websocket was initialized yet");
+    return ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][this.socket.readyState] || "UNKNOWN";
+  }
   /**
    * Gets all Players of a Node
    * @returns array of players inside of lavalink
@@ -1586,7 +1549,7 @@ var LavalinkNode = class {
      */
     singleTrack: async (encoded, requester) => {
       if (!encoded) throw new SyntaxError("No encoded (Base64 string) was provided");
-      return this._LManager.utils?.buildTrack(await this.request(`/decodetrack?encodedTrack=${encodeURIComponent(encoded.replace(/\s/g, ""))}`), requester);
+      return this.NodeManager.LavalinkManager.utils?.buildTrack(await this.request(`/decodetrack?encodedTrack=${encodeURIComponent(encoded.replace(/\s/g, ""))}`), requester);
     },
     /**
      * Decodes multiple tracks into their info
@@ -1607,7 +1570,7 @@ var LavalinkNode = class {
         r.method = "POST";
         r.body = safeStringify(encodeds);
         r.headers["Content-Type"] = "application/json";
-      }).then((r) => r.map((track) => this._LManager.utils.buildTrack(track, requester)));
+      }).then((r) => r.map((track) => this.NodeManager.LavalinkManager.utils.buildTrack(track, requester)));
     }
   };
   lyrics = {
@@ -1626,8 +1589,8 @@ var LavalinkNode = class {
      */
     get: async (track, skipTrackSource = false) => {
       if (!this.sessionId) throw new Error("the Lavalink-Node is either not ready, or not up to date!");
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavasrc-plugin") && this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "java-lyrics-plugin")) throw new RangeError(`there is no lyrics source (via lavasrc-plugin / java-lyrics-plugin) available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavasrc-plugin") && !this.info.plugins.find((v) => v.name === "java-lyrics-plugin")) throw new RangeError(`there is no lyrics source (via lavasrc-plugin / java-lyrics-plugin) available in the lavalink node (required for lyrics): ${this.id}`);
       const url = `/lyrics?track=${track.encoded}&skipTrackSource=${skipTrackSource}`;
       return await this.request(url);
     },
@@ -1646,8 +1609,8 @@ var LavalinkNode = class {
      */
     getCurrent: async (guildId, skipTrackSource = false) => {
       if (!this.sessionId) throw new Error("the Lavalink-Node is either not ready, or not up to date!");
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavasrc-plugin") && this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "java-lyrics-plugin")) throw new RangeError(`there is no lyrics source (via lavasrc-plugin / java-lyrics-plugin) available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavasrc-plugin") && !this.info.plugins.find((v) => v.name === "java-lyrics-plugin")) throw new RangeError(`there is no lyrics source (via lavasrc-plugin / java-lyrics-plugin) available in the lavalink node (required for lyrics): ${this.id}`);
       const url = `/sessions/${this.sessionId}/players/${guildId}/track/lyrics?skipTrackSource=${skipTrackSource}`;
       return await this.request(url);
     },
@@ -1665,7 +1628,7 @@ var LavalinkNode = class {
      */
     subscribe: async (guildId) => {
       if (!this.sessionId) throw new Error("the Lavalink-Node is either not ready, or not up to date!");
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
       return await this.request(`/sessions/${this.sessionId}/players/${guildId}/lyrics/subscribe`, (options) => {
         options.method = "POST";
       });
@@ -1684,7 +1647,7 @@ var LavalinkNode = class {
      */
     unsubscribe: async (guildId) => {
       if (!this.sessionId) throw new Error("the Lavalink-Node is either not ready, or not up to date!");
-      if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
+      if (!this.info.plugins.find((v) => v.name === "lavalyrics-plugin")) throw new RangeError(`there is no lavalyrics-plugin available in the lavalink node (required for lyrics): ${this.id}`);
       return await this.request(`/sessions/${this.sessionId}/players/${guildId}/lyrics/subscribe`, (options) => {
         options.method = "DELETE";
       });
@@ -1702,19 +1665,6 @@ var LavalinkNode = class {
   async fetchStats() {
     return await this.request(`/stats`);
   }
-  /**
-   * Request NodeLink connection metrics. https://nodelink.js.org/docs/differences#connection-metrics
-   * @returns the connection metrics of the node
-   *
-   * @example
-   * ```ts
-   * const connectionMetrics = await player.node.fetchConnectionMetrics();
-   * ```
-   */
-  async fetchConnectionMetrics() {
-    if (this.info && !this.info.isNodelink) throw new Error("There is no Information about wether you are using NodeLink instead of Lavalink, so this function won't work");
-    return await this.request(`/connection`);
-  }
   /**
    * Request Lavalink version.
    * @returns the current used lavalink version
@@ -1811,7 +1761,7 @@ var LavalinkNode = class {
    */
   syncPlayerData(data, res) {
     if (typeof data === "object" && typeof data?.guildId === "string" && typeof data.playerOptions === "object" && Object.keys(data.playerOptions).length > 0) {
-      const player = this._LManager.getPlayer(data.guildId);
+      const player = this.NodeManager.LavalinkManager.getPlayer(data.guildId);
       if (!player) return;
       if (typeof data.playerOptions.paused !== "undefined") {
         player.paused = data.playerOptions.paused;
@@ -1823,8 +1773,8 @@ var LavalinkNode = class {
       }
       if (typeof data.playerOptions.voice !== "undefined") player.voice = data.playerOptions.voice;
       if (typeof data.playerOptions.volume !== "undefined") {
-        if (this._LManager.options.playerOptions.volumeDecrementer) {
-          player.volume = Math.round(data.playerOptions.volume / this._LManager.options.playerOptions.volumeDecrementer);
+        if (this.NodeManager.LavalinkManager.options.playerOptions.volumeDecrementer) {
+          player.volume = Math.round(data.playerOptions.volume / this.NodeManager.LavalinkManager.options.playerOptions.volumeDecrementer);
           player.lavalinkVolume = Math.round(data.playerOptions.volume);
         } else {
           player.volume = Math.round(data.playerOptions.volume);
@@ -1848,7 +1798,7 @@ var LavalinkNode = class {
       }
     }
     if (res?.guildId === "string" && typeof res?.voice !== "undefined") {
-      const player = this._LManager.getPlayer(data.guildId);
+      const player = this.NodeManager.LavalinkManager.getPlayer(data.guildId);
       if (!player) return;
       if (typeof res?.voice?.connected === "boolean" && res.voice.connected === false) {
         player.destroy("LavalinkNoVoice" /* LavalinkNoVoice */);
@@ -1864,66 +1814,51 @@ var LavalinkNode = class {
   get restAddress() {
     return `http${this.options.secure ? "s" : ""}://${this.options.host}:${this.options.port}`;
   }
-  /**
-   * If already trying to reconnect or pending, return
-   */
-  get isNodeReconnecting() {
-    return this.reconnectionState !== "IDLE" /* IDLE */;
-  }
   /**
    * Reconnect to the lavalink node
-   * @param force @default false Wether to instantly try to reconnect (force it)
+   * @param instaReconnect @default false wether to instantly try to reconnect
    * @returns void
    *
    * @example
    * ```ts
-   * await player.node.reconnect(true); //true forcefully trys the reconnect
+   * await player.node.reconnect();
    * ```
    */
-  reconnect(force = false) {
-    if (this.isNodeReconnecting) {
+  reconnect(instaReconnect = false) {
+    if (this.reconnectionState !== "IDLE" /* IDLE */) {
       return;
     }
     this.reconnectionState = "PENDING" /* PENDING */;
     this.NodeManager.emit("reconnectinprogress", this);
-    if (force) {
-      this.executeReconnect();
+    const executeReconnect = () => {
+      if (this.reconnectAttempts >= this.options.retryAmount) {
+        const error = new Error(`Unable to connect after ${this.options.retryAmount} attempts.`);
+        this.NodeManager.emit("error", this, error);
+        this.reconnectionState = "DESTROYING" /* DESTROYING */;
+        this.destroy("NodeReconnectFail" /* NodeReconnectFail */);
+        this.reconnectionState = "IDLE" /* IDLE */;
+        return;
+      }
+      this.NodeManager.emit("reconnecting", this);
+      this.reconnectionState = "RECONNECTING" /* RECONNECTING */;
+      this.connect();
+      this.reconnectAttempts++;
+    };
+    if (instaReconnect) {
+      executeReconnect();
       return;
     }
-    if (this.reconnectTimeout) clearTimeout(this.reconnectTimeout);
     this.reconnectTimeout = setTimeout(() => {
       this.reconnectTimeout = null;
-      this.executeReconnect();
+      executeReconnect();
     }, this.options.retryDelay || 1e3);
   }
-  get reconnectionAttemptCount() {
-    const maxAllowedTimestan = this.options.retryTimespan || -1;
-    if (maxAllowedTimestan <= 0) return this.reconnectAttempts.length;
-    return this.reconnectAttempts.filter((timestamp) => Date.now() - timestamp <= maxAllowedTimestan).length;
-  }
-  /**
-   * Private Utility function to execute the reconnection
-  */
-  executeReconnect() {
-    if (this.reconnectionAttemptCount >= this.options.retryAmount) {
-      const error = new Error(`Unable to connect after ${this.options.retryAmount} attempts.`);
-      this.reconnectionState = "DESTROYING" /* DESTROYING */;
-      this.NodeManager.emit("error", this, error);
-      this.destroy("NodeReconnectFail" /* NodeReconnectFail */);
-      return;
-    }
-    this.reconnectAttempts.push(Date.now());
-    this.reconnectionState = "RECONNECTING" /* RECONNECTING */;
-    this.NodeManager.emit("reconnecting", this);
-    this.connect();
-  }
   /**
    * Private function to reset the reconnection attempts
    * @returns
    */
   resetReconnectionAttempts() {
-    this.reconnectionState = "IDLE" /* IDLE */;
-    this.reconnectAttempts = [];
+    this.reconnectAttempts = 1;
     clearTimeout(this.reconnectTimeout);
     this.reconnectTimeout = null;
     return;
@@ -1948,6 +1883,7 @@ var LavalinkNode = class {
   /** @private util function for handling opening events from websocket */
   async open() {
     this.isAlive = true;
+    this.reconnectionState = "IDLE" /* IDLE */;
     this.resetReconnectionAttempts();
     if (this.options.enablePingOnStatsCheck) this.heartBeat();
     if (this.heartBeatInterval) clearInterval(this.heartBeatInterval);
@@ -1958,10 +1894,10 @@ var LavalinkNode = class {
       });
       this.heartBeatInterval = setInterval(() => {
         if (!this.socket) return console.error("Node-Heartbeat-Interval - Socket not available - maybe reconnecting?");
-        if (!this.isAlive) return this.close(500, "Node-Heartbeat-Timeout");
+        if (!this.isAlive) this.close(500, "Node-Heartbeat-Timeout");
         this.isAlive = false;
         this.heartBeatPingTimestamp = performance.now();
-        this.socket?.ping?.();
+        this.socket.ping();
       }, this.options.heartBeatInterval || 3e4);
     }
     this.info = await this.fetchInfo().catch((e) => (console.error(e, "ON-OPEN-FETCH"), null));
@@ -1969,7 +1905,6 @@ var LavalinkNode = class {
       const errorString = `Lavalink Node (${this.restAddress}) does not provide any /${this.version}/info`;
       throw new Error(errorString);
     }
-    this.info.isNodelink = !!this.info.isNodelink;
     this.NodeManager.emit("connect", this);
   }
   /** @private util function for handling closing events from websocket */
@@ -1982,7 +1917,7 @@ var LavalinkNode = class {
       }
     } catch (e) {
       if (this.NodeManager?.LavalinkManager?.options?.advancedOptions?.enableDebugEvents) {
-        this._LManager.emit("debug", "SocketCleanupError" /* SocketCleanupError */, {
+        this.NodeManager.LavalinkManager.emit("debug", "SocketCleanupError" /* SocketCleanupError */, {
           state: "warn",
           message: `An error occurred during socket cleanup in close() (likely a race condition): ${e.message}`,
           functionLayer: "LavalinkNode > close()"
@@ -1995,12 +1930,15 @@ var LavalinkNode = class {
     this.NodeManager.emit("disconnect", this, { code, reason });
     if (code !== 1e3 || reason !== "Node-Destroy") {
       if (this.NodeManager.nodes.has(this.id)) {
-        this.reconnect();
+        if (this.reconnectionState === "IDLE" /* IDLE */) {
+          this.NodeManager.emit("reconnectFailed", this, reason || "Connection closed", this.reconnectAttempts);
+          this.reconnect();
+        }
       }
     }
-    this._LManager.players.filter((p) => p?.node?.options?.id === this?.options?.id).forEach((p) => {
-      if (!this._LManager.options.autoMove) return p.playing = false;
-      if (this._LManager.options.autoMove) {
+    this.NodeManager.LavalinkManager.players.filter((p) => p?.node?.options?.id === this?.options?.id).forEach((p) => {
+      if (!this.NodeManager.LavalinkManager.options.autoMove) return p.playing = false;
+      if (this.NodeManager.LavalinkManager.options.autoMove) {
         if (this.NodeManager.nodes.filter((n) => n.connected).size === 0)
           return p.playing = false;
         p.moveNode();
@@ -2041,12 +1979,17 @@ var LavalinkNode = class {
         break;
       case "playerUpdate":
         {
-          const player = this._LManager.getPlayer(payload.guildId);
-          if (!player) return this._emitDebugEvent("PlayerUpdateNoPlayer" /* PlayerUpdateNoPlayer */, {
-            state: "error",
-            message: `PlayerUpdate Event Triggered, but no player found of payload.guildId: ${payload.guildId}`,
-            functionLayer: "LavalinkNode > nodeEvent > playerUpdate"
-          });
+          const player = this.NodeManager.LavalinkManager.getPlayer(payload.guildId);
+          if (!player) {
+            if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+              this.NodeManager.LavalinkManager.emit("debug", "PlayerUpdateNoPlayer" /* PlayerUpdateNoPlayer */, {
+                state: "error",
+                message: `PlayerUpdate Event Triggered, but no player found of payload.guildId: ${payload.guildId}`,
+                functionLayer: "LavalinkNode > nodeEvent > playerUpdate"
+              });
+            }
+            return;
+          }
           const oldPlayer = player?.toJSON();
           player.lastPositionChange = Date.now();
           player.lastPosition = payload.state.position || 0;
@@ -2055,14 +1998,16 @@ var LavalinkNode = class {
           if (!player.createdTimeStamp && payload.state.time) player.createdTimeStamp = payload.state.time;
           if (player.filterManager.filterUpdatedState === true && ((player.queue.current?.info?.duration || 0) <= (player.LavalinkManager.options.advancedOptions.maxFilterFixDuration || 6e5) || player.queue.current?.info?.uri && isAbsolute(player.queue.current?.info?.uri))) {
             player.filterManager.filterUpdatedState = false;
-            this._emitDebugEvent("PlayerUpdateFilterFixApply" /* PlayerUpdateFilterFixApply */, {
-              state: "log",
-              message: `Fixing FilterState on "${player.guildId}" because player.options.instaUpdateFiltersFix === true`,
-              functionLayer: "LavalinkNode > nodeEvent > playerUpdate"
-            });
+            if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+              this.NodeManager.LavalinkManager.emit("debug", "PlayerUpdateFilterFixApply" /* PlayerUpdateFilterFixApply */, {
+                state: "log",
+                message: `Fixing FilterState on "${player.guildId}" because player.options.instaUpdateFiltersFix === true`,
+                functionLayer: "LavalinkNode > nodeEvent > playerUpdate"
+              });
+            }
             await player.seek(player.position);
           }
-          this._LManager.emit("playerUpdate", oldPlayer, player);
+          this.NodeManager.LavalinkManager.emit("playerUpdate", oldPlayer, player);
         }
         break;
       case "event":
@@ -2076,12 +2021,14 @@ var LavalinkNode = class {
           try {
             this.NodeManager.emit("resumed", this, payload, await this.fetchAllPlayers());
           } catch (e) {
-            this._emitDebugEvent("ResumingFetchingError" /* ResumingFetchingError */, {
-              state: "error",
-              message: `Failed to fetch players for resumed event, falling back without players array`,
-              error: e,
-              functionLayer: "LavalinkNode > nodeEvent > resumed"
-            });
+            if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+              this.NodeManager.LavalinkManager.emit("debug", "ResumingFetchingError" /* ResumingFetchingError */, {
+                state: "error",
+                message: `Failed to fetch players for resumed event, falling back without players array`,
+                error: e,
+                functionLayer: "LavalinkNode > nodeEvent > resumed"
+              });
+            }
             this.NodeManager.emit("resumed", this, payload, []);
           }
         }
@@ -2094,25 +2041,8 @@ var LavalinkNode = class {
   /** @private middleware util function for handling all kind of events from websocket */
   async handleEvent(payload) {
     if (!payload?.guildId) return;
-    const player = this._LManager.getPlayer(payload.guildId);
+    const player = this.NodeManager.LavalinkManager.getPlayer(payload.guildId);
     if (!player) return;
-    const NodeLinkEventType = payload.type;
-    const NodeLinkExclusiveEvents = [
-      "PlayerCreatedEvent",
-      "PlayerDestroyedEvent",
-      "PlayerConnectedEvent",
-      "PlayerReconnectingEvent",
-      "VolumeChangedEvent",
-      "FiltersChangedEvent",
-      "SeekEvent",
-      "PauseEvent",
-      "ConnectionStatusEvent",
-      "MixStartedEvent",
-      "MixEndedEvent"
-    ];
-    if (NodeLinkExclusiveEvents.includes(NodeLinkEventType) && (!this.info || this.info.isNodelink)) {
-      return this.nodeLinkEventHandler(NodeLinkEventType, player, player.queue.current, payload);
-    }
     switch (payload.type) {
       case "TrackStartEvent":
         this.trackStart(player, player.queue.current, payload);
@@ -2156,18 +2086,8 @@ var LavalinkNode = class {
     }
     return;
   }
-  /**
-   * nodeLink specific events handling https://nodelink.js.org/docs/api/websocket#incoming-events-server--client
-   * @param eventName
-   * @param player
-   * @param track
-   * @param payload
-   */
-  async nodeLinkEventHandler(eventName, player, track, payload) {
-    this.NodeManager.emit("nodeLinkEvent", this, eventName, player, track, payload);
-  }
   getTrackOfPayload(payload) {
-    return "track" in payload ? this._LManager.utils.buildTrack(payload.track, void 0) : null;
+    return "track" in payload ? this.NodeManager.LavalinkManager.utils.buildTrack(payload.track, void 0) : null;
   }
   /** @private util function for handling trackStart event */
   async trackStart(player, track, payload) {
@@ -2175,26 +2095,31 @@ var LavalinkNode = class {
       player.playing = true;
       player.paused = false;
     }
-    if (this._LManager.options?.emitNewSongsOnly === true && player.queue.previous[0]?.info?.identifier === track?.info?.identifier) {
-      return this._emitDebugEvent("TrackStartNewSongsOnly" /* TrackStartNewSongsOnly */, {
-        state: "log",
-        message: `TrackStart not Emitting, because playing the previous song again.`,
-        functionLayer: "LavalinkNode > trackStart()"
-      });
+    if (this.NodeManager.LavalinkManager.options?.emitNewSongsOnly === true && player.queue.previous[0]?.info?.identifier === track?.info?.identifier) {
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "TrackStartNewSongsOnly" /* TrackStartNewSongsOnly */, {
+          state: "log",
+          message: `TrackStart not Emitting, because playing the previous song again.`,
+          functionLayer: "LavalinkNode > trackStart()"
+        });
+      }
+      return;
     }
     if (!player.queue.current) {
       player.queue.current = this.getTrackOfPayload(payload);
       if (player.queue.current) {
         await player.queue.utils.save();
       } else {
-        this._emitDebugEvent("TrackStartNoTrack" /* TrackStartNoTrack */, {
-          state: "warn",
-          message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
-          functionLayer: "LavalinkNode > trackStart()"
-        });
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackStartNoTrack" /* TrackStartNoTrack */, {
+            state: "warn",
+            message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
+            functionLayer: "LavalinkNode > trackStart()"
+          });
+        }
       }
     }
-    this._LManager.emit("trackStart", player, player.queue.current, payload);
+    this.NodeManager.LavalinkManager.emit("trackStart", player, player.queue.current, payload);
     return;
   }
   /** @private util function for handling trackEnd event */
@@ -2202,12 +2127,14 @@ var LavalinkNode = class {
     if (player.get("internal_nodeChanging") === true) return;
     const trackToUse = track || this.getTrackOfPayload(payload);
     if (payload.reason === "replaced") {
-      this._emitDebugEvent("TrackEndReplaced" /* TrackEndReplaced */, {
-        state: "warn",
-        message: `TrackEnd Event does not handle any playback, because the track was replaced.`,
-        functionLayer: "LavalinkNode > trackEnd()"
-      });
-      this._LManager.emit("trackEnd", player, trackToUse, payload);
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "TrackEndReplaced" /* TrackEndReplaced */, {
+          state: "warn",
+          message: `TrackEnd Event does not handle any playback, because the track was replaced.`,
+          functionLayer: "LavalinkNode > trackEnd()"
+        });
+      }
+      this.NodeManager.LavalinkManager.emit("trackEnd", player, trackToUse, payload);
       return;
     }
     if (!player.queue.tracks.length && (player.repeatMode === "off" || player.get("internal_stopPlaying"))) return this.queueEnd(player, track, payload);
@@ -2215,8 +2142,8 @@ var LavalinkNode = class {
       if (player.get("internal_destroystatus") === true) return;
       await queueTrackEnd(player);
       if (!player.queue.current) return this.queueEnd(player, trackToUse, payload);
-      this._LManager.emit("trackEnd", player, trackToUse, payload);
-      if (this._LManager.options.autoSkip && player.queue.current) {
+      this.NodeManager.LavalinkManager.emit("trackEnd", player, trackToUse, payload);
+      if (this.NodeManager.LavalinkManager.options.autoSkip && player.queue.current) {
         player.play({ noReplace: true });
       }
       return;
@@ -2229,28 +2156,30 @@ var LavalinkNode = class {
     }
     if (!player.queue.current) return this.queueEnd(player, trackToUse, payload);
     player.set("internal_skipped", false);
-    this._LManager.emit("trackEnd", player, trackToUse, payload);
-    if (this._LManager.options.autoSkip && player.queue.current) {
+    this.NodeManager.LavalinkManager.emit("trackEnd", player, trackToUse, payload);
+    if (this.NodeManager.LavalinkManager.options.autoSkip && player.queue.current) {
       player.play({ noReplace: true });
     }
     return;
   }
   /** @private util function for handling trackStuck event */
   async trackStuck(player, track, payload) {
-    if (this._LManager.options.playerOptions.maxErrorsPerTime?.threshold > 0 && this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount >= 0) {
-      const oldTimestamps = (player.get("internal_erroredTracksTimestamps") || []).filter((v) => Date.now() - v < this._LManager.options.playerOptions.maxErrorsPerTime?.threshold);
+    if (this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold > 0 && this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount >= 0) {
+      const oldTimestamps = (player.get("internal_erroredTracksTimestamps") || []).filter((v) => Date.now() - v < this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold);
       player.set("internal_erroredTracksTimestamps", [...oldTimestamps, Date.now()]);
-      if (oldTimestamps.length > this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount) {
-        this._emitDebugEvent("TrackStuckMaxTracksErroredPerTime" /* TrackStuckMaxTracksErroredPerTime */, {
-          state: "log",
-          message: `trackStuck Event was triggered too often within a given threshold (LavalinkManager.options.playerOptions.maxErrorsPerTime). Threshold: "${this._LManager.options.playerOptions.maxErrorsPerTime?.threshold}ms", maxAmount: "${this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount}"`,
-          functionLayer: "LavalinkNode > trackStuck()"
-        });
+      if (oldTimestamps.length > this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount) {
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackStuckMaxTracksErroredPerTime" /* TrackStuckMaxTracksErroredPerTime */, {
+            state: "log",
+            message: `trackStuck Event was triggered too often within a given threshold (LavalinkManager.options.playerOptions.maxErrorsPerTime). Threshold: "${this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold}ms", maxAmount: "${this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount}"`,
+            functionLayer: "LavalinkNode > trackStuck()"
+          });
+        }
         player.destroy("TrackStuckMaxTracksErroredPerTime" /* TrackStuckMaxTracksErroredPerTime */);
         return;
       }
     }
-    this._LManager.emit("trackStuck", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("trackStuck", player, track || this.getTrackOfPayload(payload), payload);
     if (!player.queue.tracks.length && (player.repeatMode === "off" || player.get("internal_stopPlaying"))) {
       try {
         await player.node.updatePlayer({ guildId: player.guildId, playerOptions: { track: { encoded: null } } });
@@ -2263,52 +2192,54 @@ var LavalinkNode = class {
     if (!player.queue.current) {
       return this.queueEnd(player, track || this.getTrackOfPayload(payload), payload);
     }
-    if (this._LManager.options.autoSkip && player.queue.current) {
+    if (this.NodeManager.LavalinkManager.options.autoSkip && player.queue.current) {
       player.play({ track: player.queue.current, noReplace: false });
     }
     return;
   }
   /** @private util function for handling trackError event */
   async trackError(player, track, payload) {
-    if (this._LManager.options.playerOptions.maxErrorsPerTime?.threshold > 0 && this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount >= 0) {
-      const oldTimestamps = (player.get("internal_erroredTracksTimestamps") || []).filter((v) => Date.now() - v < this._LManager.options.playerOptions.maxErrorsPerTime?.threshold);
+    if (this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold > 0 && this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount >= 0) {
+      const oldTimestamps = (player.get("internal_erroredTracksTimestamps") || []).filter((v) => Date.now() - v < this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold);
       player.set("internal_erroredTracksTimestamps", [...oldTimestamps, Date.now()]);
-      if (oldTimestamps.length > this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount) {
-        this._emitDebugEvent("TrackErrorMaxTracksErroredPerTime" /* TrackErrorMaxTracksErroredPerTime */, {
-          state: "log",
-          message: `TrackError Event was triggered too often within a given threshold (LavalinkManager.options.playerOptions.maxErrorsPerTime). Threshold: "${this._LManager.options.playerOptions.maxErrorsPerTime?.threshold}ms", maxAmount: "${this._LManager.options.playerOptions.maxErrorsPerTime?.maxAmount}"`,
-          functionLayer: "LavalinkNode > trackError()"
-        });
+      if (oldTimestamps.length > this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount) {
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackErrorMaxTracksErroredPerTime" /* TrackErrorMaxTracksErroredPerTime */, {
+            state: "log",
+            message: `TrackError Event was triggered too often within a given threshold (LavalinkManager.options.playerOptions.maxErrorsPerTime). Threshold: "${this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.threshold}ms", maxAmount: "${this.NodeManager.LavalinkManager.options.playerOptions.maxErrorsPerTime?.maxAmount}"`,
+            functionLayer: "LavalinkNode > trackError()"
+          });
+        }
         player.destroy("TrackErrorMaxTracksErroredPerTime" /* TrackErrorMaxTracksErroredPerTime */);
         return;
       }
     }
-    this._LManager.emit("trackError", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("trackError", player, track || this.getTrackOfPayload(payload), payload);
     return;
   }
   /** @private util function for handling socketClosed event */
   socketClosed(player, payload) {
-    this._LManager.emit("playerSocketClosed", player, payload);
+    this.NodeManager.LavalinkManager.emit("playerSocketClosed", player, payload);
     return;
   }
   /** @private util function for handling SponsorBlock Segmentloaded event */
   SponsorBlockSegmentLoaded(player, track, payload) {
-    this._LManager.emit("SegmentsLoaded", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("SegmentsLoaded", player, track || this.getTrackOfPayload(payload), payload);
     return;
   }
   /** @private util function for handling SponsorBlock SegmentSkipped event */
   SponsorBlockSegmentSkipped(player, track, payload) {
-    this._LManager.emit("SegmentSkipped", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("SegmentSkipped", player, track || this.getTrackOfPayload(payload), payload);
     return;
   }
   /** @private util function for handling SponsorBlock Chaptersloaded event */
   SponsorBlockChaptersLoaded(player, track, payload) {
-    this._LManager.emit("ChaptersLoaded", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("ChaptersLoaded", player, track || this.getTrackOfPayload(payload), payload);
     return;
   }
   /** @private util function for handling SponsorBlock Chaptersstarted event */
   SponsorBlockChapterStarted(player, track, payload) {
-    this._LManager.emit("ChapterStarted", player, track || this.getTrackOfPayload(payload), payload);
+    this.NodeManager.LavalinkManager.emit("ChapterStarted", player, track || this.getTrackOfPayload(payload), payload);
     return;
   }
   /**
@@ -2323,7 +2254,7 @@ var LavalinkNode = class {
    * ```
    */
   async getSponsorBlock(player) {
-    if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
+    if (!this.info.plugins.find((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
     return await this.request(`/sessions/${this.sessionId}/players/${player.guildId}/sponsorblock/categories`);
   }
   /**
@@ -2338,7 +2269,7 @@ var LavalinkNode = class {
    * ```
    */
   async setSponsorBlock(player, segments = ["sponsor", "selfpromo"]) {
-    if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
+    if (!this.info.plugins.find((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
     if (!segments.length) throw new RangeError("No Segments provided. Did you ment to use 'deleteSponsorBlock'?");
     if (segments.some((v) => !validSponsorBlocks.includes(v.toLowerCase()))) throw new SyntaxError(`You provided a sponsorblock which isn't valid, valid ones are: ${validSponsorBlocks.map((v) => `'${v}'`).join(", ")}`);
     await this.request(`/sessions/${this.sessionId}/players/${player.guildId}/sponsorblock/categories`, (r) => {
@@ -2347,11 +2278,13 @@ var LavalinkNode = class {
       r.body = safeStringify(segments.map((v) => v.toLowerCase()));
     });
     player.set("internal_sponsorBlockCategories", segments.map((v) => v.toLowerCase()));
-    this._emitDebugEvent("SetSponsorBlock" /* SetSponsorBlock */, {
-      state: "log",
-      message: `SponsorBlock was set for Player: ${player.guildId} to: ${segments.map((v) => `'${v.toLowerCase()}'`).join(", ")}`,
-      functionLayer: "LavalinkNode > setSponsorBlock()"
-    });
+    if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.NodeManager.LavalinkManager.emit("debug", "SetSponsorBlock" /* SetSponsorBlock */, {
+        state: "log",
+        message: `SponsorBlock was set for Player: ${player.guildId} to: ${segments.map((v) => `'${v.toLowerCase()}'`).join(", ")}`,
+        functionLayer: "LavalinkNode > setSponsorBlock()"
+      });
+    }
     return;
   }
   /**
@@ -2366,16 +2299,18 @@ var LavalinkNode = class {
    * ```
    */
   async deleteSponsorBlock(player) {
-    if (this._checkForPlugins && !this.info?.plugins?.find?.((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
+    if (!this.info.plugins.find((v) => v.name === "sponsorblock-plugin")) throw new RangeError(`there is no sponsorblock-plugin available in the lavalink node: ${this.id}`);
     await this.request(`/sessions/${this.sessionId}/players/${player.guildId}/sponsorblock/categories`, (r) => {
       r.method = "DELETE";
     });
     player.set("internal_sponsorBlockCategories", []);
-    this._emitDebugEvent("DeleteSponsorBlock" /* DeleteSponsorBlock */, {
-      state: "log",
-      message: `SponsorBlock was deleted for Player: ${player.guildId}`,
-      functionLayer: "LavalinkNode > deleteSponsorBlock()"
-    });
+    if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.NodeManager.LavalinkManager.emit("debug", "DeleteSponsorBlock" /* DeleteSponsorBlock */, {
+        state: "log",
+        message: `SponsorBlock was deleted for Player: ${player.guildId}`,
+        functionLayer: "LavalinkNode > deleteSponsorBlock()"
+      });
+    }
     return;
   }
   /** private util function for handling the queue end event */
@@ -2384,38 +2319,46 @@ var LavalinkNode = class {
     player.queue.current = null;
     player.playing = false;
     player.set("internal_stopPlaying", void 0);
-    this._emitDebugEvent("QueueEnded" /* QueueEnded */, {
-      state: "log",
-      message: `Queue Ended because no more Tracks were in the Queue, due to EventName: "${payload.type}"`,
-      functionLayer: "LavalinkNode > queueEnd()"
-    });
-    if (typeof this._LManager.options?.playerOptions?.onEmptyQueue?.autoPlayFunction === "function" && typeof player.get("internal_autoplayStopPlaying") === "undefined") {
-      this._emitDebugEvent("AutoplayExecution" /* AutoplayExecution */, {
+    if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.NodeManager.LavalinkManager.emit("debug", "QueueEnded" /* QueueEnded */, {
         state: "log",
-        message: `Now Triggering Autoplay.`,
-        functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
+        message: `Queue Ended because no more Tracks were in the Queue, due to EventName: "${payload.type}"`,
+        functionLayer: "LavalinkNode > queueEnd()"
       });
+    }
+    if (typeof this.NodeManager.LavalinkManager.options?.playerOptions?.onEmptyQueue?.autoPlayFunction === "function" && typeof player.get("internal_autoplayStopPlaying") === "undefined") {
+      if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.NodeManager.LavalinkManager.emit("debug", "AutoplayExecution" /* AutoplayExecution */, {
+          state: "log",
+          message: `Now Triggering Autoplay.`,
+          functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
+        });
+      }
       const previousAutoplayTime = player.get("internal_previousautoplay");
       const duration = previousAutoplayTime ? Date.now() - previousAutoplayTime : 0;
-      if (!duration || duration > this._LManager.options.playerOptions.minAutoPlayMs || !!player.get("internal_skipped")) {
-        await this._LManager.options?.playerOptions?.onEmptyQueue?.autoPlayFunction(player, track);
+      if (!duration || duration > this.NodeManager.LavalinkManager.options.playerOptions.minAutoPlayMs || !!player.get("internal_skipped")) {
+        await this.NodeManager.LavalinkManager.options?.playerOptions?.onEmptyQueue?.autoPlayFunction(player, track);
         player.set("internal_previousautoplay", Date.now());
         if (player.queue.tracks.length > 0) await queueTrackEnd(player);
-        else this._emitDebugEvent("AutoplayNoSongsAdded" /* AutoplayNoSongsAdded */, {
-          state: "warn",
-          message: `Autoplay was triggered but no songs were added to the queue.`,
-          functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
-        });
-      }
-      if (player.queue.current) {
-        if (payload.type === "TrackEndEvent") this._LManager.emit("trackEnd", player, track, payload);
-        if (this._LManager.options.autoSkip) return player.play({ noReplace: true, paused: false });
+        else if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "AutoplayNoSongsAdded" /* AutoplayNoSongsAdded */, {
+            state: "warn",
+            message: `Autoplay was triggered but no songs were added to the queue.`,
+            functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
+          });
+        }
+        if (player.queue.current) {
+          if (payload.type === "TrackEndEvent") this.NodeManager.LavalinkManager.emit("trackEnd", player, track, payload);
+          if (this.NodeManager.LavalinkManager.options.autoSkip) return player.play({ noReplace: true, paused: false });
+        }
       } else {
-        this._emitDebugEvent("AutoplayThresholdSpamLimiter" /* AutoplayThresholdSpamLimiter */, {
-          state: "warn",
-          message: `Autoplay was triggered after the previousautoplay too early. Threshold is: ${this._LManager.options.playerOptions.minAutoPlayMs}ms and the Duration was ${duration}ms`,
-          functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
-        });
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "AutoplayThresholdSpamLimiter" /* AutoplayThresholdSpamLimiter */, {
+            state: "warn",
+            message: `Autoplay was triggered after the previousautoplay too early. Threshold is: ${this.NodeManager.LavalinkManager.options.playerOptions.minAutoPlayMs}ms and the Duration was ${duration}ms`,
+            functionLayer: "LavalinkNode > queueEnd() > autoplayFunction"
+          });
+        }
       }
     }
     player.set("internal_skipped", false);
@@ -2428,29 +2371,34 @@ var LavalinkNode = class {
     if (payload?.reason !== "stopped") {
       await player.queue.utils.save();
     }
-    if (typeof this._LManager.options.playerOptions?.onEmptyQueue?.destroyAfterMs === "number" && !isNaN(this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs) && this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs >= 0) {
-      if (this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs === 0) {
+    if (typeof this.NodeManager.LavalinkManager.options.playerOptions?.onEmptyQueue?.destroyAfterMs === "number" && !isNaN(this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs) && this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs >= 0) {
+      if (this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs === 0) {
         player.destroy("QueueEmpty" /* QueueEmpty */);
         return;
       } else {
-        this._emitDebugEvent("TriggerQueueEmptyInterval" /* TriggerQueueEmptyInterval */, {
-          state: "log",
-          message: `Trigger Queue Empty Interval was Triggered because playerOptions.onEmptyQueue.destroyAfterMs is set to ${this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs}ms`,
-          functionLayer: "LavalinkNode > queueEnd() > destroyAfterMs"
-        });
-        this._LManager.emit("playerQueueEmptyStart", player, this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs);
-        if (player.get("internal_queueempty")) clearTimeout(player.get("internal_queueempty"));
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TriggerQueueEmptyInterval" /* TriggerQueueEmptyInterval */, {
+            state: "log",
+            message: `Trigger Queue Empty Interval was Triggered because playerOptions.onEmptyQueue.destroyAfterMs is set to ${this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs}ms`,
+            functionLayer: "LavalinkNode > queueEnd() > destroyAfterMs"
+          });
+        }
+        this.NodeManager.LavalinkManager.emit("playerQueueEmptyStart", player, this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs);
+        if (player.get("internal_queueempty")) {
+          clearTimeout(player.get("internal_queueempty"));
+          player.set("internal_queueempty", void 0);
+        }
         player.set("internal_queueempty", setTimeout(() => {
           player.set("internal_queueempty", void 0);
           if (player.queue.current) {
-            return this._LManager.emit("playerQueueEmptyCancel", player);
+            return this.NodeManager.LavalinkManager.emit("playerQueueEmptyCancel", player);
           }
-          this._LManager.emit("playerQueueEmptyEnd", player);
+          this.NodeManager.LavalinkManager.emit("playerQueueEmptyEnd", player);
           player.destroy("QueueEmpty" /* QueueEmpty */);
-        }, this._LManager.options.playerOptions.onEmptyQueue?.destroyAfterMs));
+        }, this.NodeManager.LavalinkManager.options.playerOptions.onEmptyQueue?.destroyAfterMs));
       }
     }
-    this._LManager.emit("queueEnd", player, track, payload);
+    this.NodeManager.LavalinkManager.emit("queueEnd", player, track, payload);
     return;
   }
   /**
@@ -2466,14 +2414,16 @@ var LavalinkNode = class {
       if (player.queue.current) {
         await player.queue.utils.save();
       } else {
-        this._emitDebugEvent("TrackStartNoTrack" /* TrackStartNoTrack */, {
-          state: "warn",
-          message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
-          functionLayer: "LavalinkNode > trackStart()"
-        });
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackStartNoTrack" /* TrackStartNoTrack */, {
+            state: "warn",
+            message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
+            functionLayer: "LavalinkNode > trackStart()"
+          });
+        }
       }
     }
-    this._LManager.emit("LyricsLine", player, track, payload);
+    this.NodeManager.LavalinkManager.emit("LyricsLine", player, track, payload);
     return;
   }
   /**
@@ -2489,14 +2439,16 @@ var LavalinkNode = class {
       if (player.queue.current) {
         await player.queue.utils.save();
       } else {
-        this._emitDebugEvent("TrackStartNoTrack" /* TrackStartNoTrack */, {
-          state: "warn",
-          message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
-          functionLayer: "LavalinkNode > trackStart()"
-        });
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackStartNoTrack" /* TrackStartNoTrack */, {
+            state: "warn",
+            message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
+            functionLayer: "LavalinkNode > trackStart()"
+          });
+        }
       }
     }
-    this._LManager.emit("LyricsFound", player, track, payload);
+    this.NodeManager.LavalinkManager.emit("LyricsFound", player, track, payload);
     return;
   }
   /**
@@ -2512,14 +2464,16 @@ var LavalinkNode = class {
       if (player.queue.current) {
         await player.queue.utils.save();
       } else {
-        this._emitDebugEvent("TrackStartNoTrack" /* TrackStartNoTrack */, {
-          state: "warn",
-          message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
-          functionLayer: "LavalinkNode > trackStart()"
-        });
+        if (this.NodeManager.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.NodeManager.LavalinkManager.emit("debug", "TrackStartNoTrack" /* TrackStartNoTrack */, {
+            state: "warn",
+            message: `Trackstart emitted but there is no track on player.queue.current, trying to get the track of the payload failed too.`,
+            functionLayer: "LavalinkNode > trackStart()"
+          });
+        }
       }
     }
-    this._LManager.emit("LyricsNotFound", player, track, payload);
+    this.NodeManager.LavalinkManager.emit("LyricsNotFound", player, track, payload);
     return;
   }
 };
@@ -2881,21 +2835,6 @@ var FilterManager = class {
   data = structuredClone(DEFAULT_FILTER_DATAS);
   /** The Player assigned to this Filter Manager */
   player;
-  get _LManager() {
-    return this.player.LavalinkManager;
-  }
-  /**
-   * Returns wether the plugin validations are enabled or not
-   */
-  get _checkForPlugins() {
-    return !!this._LManager.options?.autoChecks?.pluginValidations;
-  }
-  /**
-   * Returns wether the source validations are enabled or not
-   */
-  get _checkForSources() {
-    return !!this._LManager.options?.autoChecks?.sourcesValidations;
-  }
   /** The Constructor for the FilterManager */
   constructor(player) {
     this.player = player;
@@ -2932,13 +2871,13 @@ var FilterManager = class {
     if (!this.filters.karaoke) delete sendData.karaoke;
     if (!this.filters.rotation) delete sendData.rotation;
     if (this.filters.audioOutput === "stereo") delete sendData.channelMix;
-    if (Object.values(this.data.timescale ?? {}).every((v) => v === 1)) delete sendData.timescale;
+    if (Object.values(this.data.timescale).every((v) => v === 1)) delete sendData.timescale;
     if (!this.player.node.sessionId) throw new Error("The Lavalink-Node is either not ready or not up to date");
     sendData.equalizer = [...this.equalizerBands];
     if (sendData.equalizer.length === 0) delete sendData.equalizer;
     for (const key of Object.keys(sendData)) {
       if (key === "pluginFilters") {
-      } else if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.(key)) delete sendData[key];
+      } else if (this.player.node.info && !this.player.node.info?.filters?.includes?.(key)) delete sendData[key];
     }
     const now = performance.now();
     if (this.player.options.instaUpdateFiltersFix === true) this.filterUpdatedState = true;
@@ -2954,19 +2893,6 @@ var FilterManager = class {
   privateNot0(value) {
     return typeof value === "number" && value !== 0;
   }
-  getLavalinkFilterData() {
-    return this.data.pluginFilters?.["lavalink-filter-plugin"] || {
-      echo: {
-        decay: this.data.pluginFilters?.echo?.decay && !this.data.pluginFilters?.echo?.echoLength ? this.data.pluginFilters?.echo?.decay : 0,
-        delay: this.data.pluginFilters?.echo?.delay || 0
-      },
-      reverb: {
-        gains: [],
-        delays: [],
-        ...this.data.pluginFilters?.reverb
-      }
-    };
-  }
   /**
    * Checks if the filters are correctly stated (active / not-active) - mostly used internally.
    * @param oldFilterTimescale
@@ -2985,17 +2911,13 @@ var FilterManager = class {
     this.filters.rotation = this.privateNot0(this.data.rotation?.rotationHz);
     this.filters.vibrato = this.privateNot0(this.data.vibrato?.frequency) || this.privateNot0(this.data.vibrato?.depth);
     this.filters.tremolo = this.privateNot0(this.data.tremolo?.frequency) || this.privateNot0(this.data.tremolo?.depth);
-    const lavalinkFilterData = this.getLavalinkFilterData();
-    this.filters.lavalinkFilterPlugin = {
-      echo: this.privateNot0(lavalinkFilterData?.echo?.decay) || this.privateNot0(lavalinkFilterData?.echo?.delay),
-      reverb: this.privateNot0(lavalinkFilterData?.reverb?.delays?.length) || this.privateNot0(lavalinkFilterData?.reverb?.gains?.length)
-    };
-    this.filters.lavalinkLavaDspxPlugin = {
-      lowPass: Object.values(this.data.pluginFilters?.["low-pass"] || {})?.length > 0,
-      highPass: Object.values(this.data.pluginFilters?.["high-pass"] || {})?.length > 0,
-      normalization: Object.values(this.data.pluginFilters?.normalization || {})?.length > 0,
-      echo: Object.values(this.data.pluginFilters?.echo || {})?.length > 0 && typeof this.data.pluginFilters?.echo?.delay === "undefined"
-    };
+    const lavalinkFilterData = this.data.pluginFilters?.["lavalink-filter-plugin"] || { echo: { decay: this.data.pluginFilters?.echo?.decay && !this.data.pluginFilters?.echo?.echoLength ? this.data.pluginFilters.echo.decay : 0, delay: this.data.pluginFilters?.echo?.delay || 0 }, reverb: { gains: [], delays: [], ...this.data.pluginFilters.reverb } };
+    this.filters.lavalinkFilterPlugin.echo = lavalinkFilterData.echo.decay !== 0 || lavalinkFilterData.echo.delay !== 0;
+    this.filters.lavalinkFilterPlugin.reverb = lavalinkFilterData.reverb?.delays?.length !== 0 || lavalinkFilterData.reverb?.gains?.length !== 0;
+    this.filters.lavalinkLavaDspxPlugin.highPass = Object.values(this.data.pluginFilters?.["high-pass"] || {}).length > 0;
+    this.filters.lavalinkLavaDspxPlugin.lowPass = Object.values(this.data.pluginFilters?.["low-pass"] || {}).length > 0;
+    this.filters.lavalinkLavaDspxPlugin.normalization = Object.values(this.data.pluginFilters?.normalization || {}).length > 0;
+    this.filters.lavalinkLavaDspxPlugin.echo = Object.values(this.data.pluginFilters?.echo || {}).length > 0 && typeof this.data.pluginFilters?.echo?.delay === "undefined";
     this.filters.lowPass = this.privateNot0(this.data.lowPass?.smoothing);
     this.filters.karaoke = Object.values(this.data.karaoke ?? {}).some((v) => v !== 0);
     if ((this.filters.nightcore || this.filters.vaporwave) && oldFilterTimescale) {
@@ -3078,7 +3000,7 @@ var FilterManager = class {
    * ```
    */
   async setAudioOutput(type) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("channelMix")) throw new Error("Node#Info#filters does not include the 'channelMix' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("channelMix")) throw new Error("Node#Info#filters does not include the 'channelMix' Filter (Node has it not enable)");
     if (!type || !audioOutputsData[type]) throw "Invalid audio type added, must be 'mono' / 'stereo' / 'left' / 'right'";
     this.data = this.data ?? {};
     this.data.channelMix = audioOutputsData[type];
@@ -3098,7 +3020,7 @@ var FilterManager = class {
    * ```
    */
   async setSpeed(speed = 1) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.filters.nightcore = false;
     this.filters.vaporwave = false;
@@ -3119,7 +3041,7 @@ var FilterManager = class {
    * ```
    */
   async setPitch(pitch = 1) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.filters.nightcore = false;
     this.filters.vaporwave = false;
@@ -3140,7 +3062,7 @@ var FilterManager = class {
    * ```
    */
   async setRate(rate = 1) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.filters.nightcore = false;
     this.filters.vaporwave = false;
@@ -3164,7 +3086,7 @@ var FilterManager = class {
    * ```
    */
   async toggleRotation(rotationHz = 0.2) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("rotation")) throw new Error("Node#Info#filters does not include the 'rotation' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("rotation")) throw new Error("Node#Info#filters does not include the 'rotation' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.rotation = this.filters.rotation ? DEFAULT_FILTER_DATAS.rotation : { rotationHz };
     this.filters.rotation = !this.filters.rotation;
@@ -3187,7 +3109,7 @@ var FilterManager = class {
    * ```
    */
   async toggleVibrato(frequency = 10, depth = 1) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("vibrato")) throw new Error("Node#Info#filters does not include the 'vibrato' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("vibrato")) throw new Error("Node#Info#filters does not include the 'vibrato' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.vibrato = this.filters.vibrato ? DEFAULT_FILTER_DATAS.vibrato : { depth, frequency };
     this.filters.vibrato = !this.filters.vibrato;
@@ -3210,7 +3132,7 @@ var FilterManager = class {
    * ```
    */
   async toggleTremolo(frequency = 4, depth = 0.8) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("tremolo")) throw new Error("Node#Info#filters does not include the 'tremolo' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("tremolo")) throw new Error("Node#Info#filters does not include the 'tremolo' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.tremolo = this.filters.tremolo ? DEFAULT_FILTER_DATAS.tremolo : { depth, frequency };
     this.filters.tremolo = !this.filters.tremolo;
@@ -3232,7 +3154,7 @@ var FilterManager = class {
    * ```
    */
   async toggleLowPass(smoothing = 20) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("lowPass")) throw new Error("Node#Info#filters does not include the 'lowPass' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("lowPass")) throw new Error("Node#Info#filters does not include the 'lowPass' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.lowPass = this.filters.lowPass ? DEFAULT_FILTER_DATAS.lowPass : { smoothing };
     this.filters.lowPass = !this.filters.lowPass;
@@ -3259,8 +3181,8 @@ var FilterManager = class {
      * ```
      */
     toggleLowPass: async (boostFactor = 1, cutoffFrequency = 80) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("low-pass")) throw new Error("Node#Info#filters does not include the 'low-pass' Filter (Node has it not enable)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("low-pass")) throw new Error("Node#Info#filters does not include the 'low-pass' Filter (Node has it not enable)");
       this.data = this.data ?? {};
       this.data.pluginFilters = this.data.pluginFilters ?? {};
       if (this.filters.lavalinkLavaDspxPlugin.lowPass) delete this.data.pluginFilters["low-pass"];
@@ -3285,8 +3207,8 @@ var FilterManager = class {
      * ```
      */
     toggleHighPass: async (boostFactor = 1, cutoffFrequency = 80) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("high-pass")) throw new Error("Node#Info#filters does not include the 'high-pass' Filter (Node has it not enable)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("high-pass")) throw new Error("Node#Info#filters does not include the 'high-pass' Filter (Node has it not enable)");
       this.data = this.data ?? {};
       this.data.pluginFilters = this.data.pluginFilters ?? {};
       if (this.filters.lavalinkLavaDspxPlugin.highPass) delete this.data.pluginFilters["high-pass"];
@@ -3311,8 +3233,8 @@ var FilterManager = class {
      * ```
      */
     toggleNormalization: async (maxAmplitude = 0.75, adaptive = true) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("normalization")) throw new Error("Node#Info#filters does not include the 'normalization' Filter (Node has it not enable)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("normalization")) throw new Error("Node#Info#filters does not include the 'normalization' Filter (Node has it not enable)");
       this.data = this.data ?? {};
       this.data.pluginFilters = this.data.pluginFilters ?? {};
       if (this.filters.lavalinkLavaDspxPlugin.normalization) delete this.data.pluginFilters.normalization;
@@ -3337,8 +3259,8 @@ var FilterManager = class {
      * ```
      */
     toggleEcho: async (decay = 0.5, echoLength = 0.5) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("echo")) throw new Error("Node#Info#filters does not include the 'echo' Filter (Node has it not enable)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavadspx-plugin")) throw new Error("Node#Info#plugins does not include the lavadspx plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("echo")) throw new Error("Node#Info#filters does not include the 'echo' Filter (Node has it not enable)");
       this.data = this.data ?? {};
       this.data.pluginFilters = this.data.pluginFilters ?? {};
       if (this.filters.lavalinkLavaDspxPlugin.echo) delete this.data.pluginFilters.echo;
@@ -3368,8 +3290,8 @@ var FilterManager = class {
      * ```
      */
     toggleEcho: async (delay = 4, decay = 0.8) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavalink-filter-plugin")) throw new Error("Node#Info#plugins does not include the lavalink-filter-plugin plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("echo")) throw new Error("Node#Info#filters does not include the 'echo' Filter (Node has it not enable aka not installed!)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavalink-filter-plugin")) throw new Error("Node#Info#plugins does not include the lavalink-filter-plugin plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("echo")) throw new Error("Node#Info#filters does not include the 'echo' Filter (Node has it not enable aka not installed!)");
       this.data = this.data ?? {};
       const { echo, reverb } = DEFAULT_FILTER_DATAS.pluginFilters["lavalink-filter-plugin"];
       this.data.pluginFilters = {
@@ -3399,8 +3321,8 @@ var FilterManager = class {
      * ```
      */
     toggleReverb: async (delays = [0.037, 0.042, 0.048, 0.053], gains = [0.84, 0.83, 0.82, 0.81]) => {
-      if (this._checkForPlugins && !this.player?.node?.info?.plugins?.find?.((v) => v.name === "lavalink-filter-plugin")) throw new Error("Node#Info#plugins does not include the lavalink-filter-plugin plugin");
-      if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("reverb")) throw new Error("Node#Info#filters does not include the 'reverb' Filter (Node has it not enable aka not installed!)");
+      if (this.player.node.info && !this.player.node.info?.plugins?.find((v) => v.name === "lavalink-filter-plugin")) throw new Error("Node#Info#plugins does not include the lavalink-filter-plugin plugin");
+      if (this.player.node.info && !this.player.node.info?.filters?.includes("reverb")) throw new Error("Node#Info#filters does not include the 'reverb' Filter (Node has it not enable aka not installed!)");
       this.data = this.data ?? {};
       const { echo, reverb } = DEFAULT_FILTER_DATAS.pluginFilters["lavalink-filter-plugin"];
       this.data.pluginFilters = {
@@ -3432,7 +3354,7 @@ var FilterManager = class {
    * ```
    */
   async toggleNightcore(speed = 1.289999523162842, pitch = 1.289999523162842, rate = 0.9365999523162842) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.timescale = this.filters.nightcore ? DEFAULT_FILTER_DATAS.timescale : { speed, pitch, rate };
     this.filters.nightcore = !this.filters.nightcore;
@@ -3458,7 +3380,7 @@ var FilterManager = class {
    * ```
    */
   async toggleVaporwave(speed = 0.8500000238418579, pitch = 0.800000011920929, rate = 1) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("timescale")) throw new Error("Node#Info#filters does not include the 'timescale' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.timescale = this.filters.vaporwave ? DEFAULT_FILTER_DATAS.timescale : { speed, pitch, rate };
     this.filters.vaporwave = !this.filters.vaporwave;
@@ -3485,7 +3407,7 @@ var FilterManager = class {
    * ```
    */
   async toggleKaraoke(level = 1, monoLevel = 1, filterBand = 220, filterWidth = 100) {
-    if (this._checkForSources && !this.player?.node?.info?.filters?.includes?.("karaoke")) throw new Error("Node#Info#filters does not include the 'karaoke' Filter (Node has it not enable)");
+    if (this.player.node.info && !this.player.node.info?.filters?.includes("karaoke")) throw new Error("Node#Info#filters does not include the 'karaoke' Filter (Node has it not enable)");
     this.data = this.data ?? {};
     this.data.karaoke = this.filters.karaoke ? DEFAULT_FILTER_DATAS.karaoke : { level, monoLevel, filterBand, filterWidth };
     this.filters.karaoke = !this.filters.karaoke;
@@ -4002,15 +3924,6 @@ var Player = class {
   };
   /** Custom data for the player */
   data = {};
-  /**
-   * Emits a debug event to the LavalinkManager
-   * @param name name of the event
-   * @param eventData event data
-   */
-  _emitDebugEvent(name, eventData) {
-    if (!this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) return;
-    this.LavalinkManager.emit("debug", name, eventData);
-  }
   /**
    * Create a new Player
    * @param options
@@ -4026,8 +3939,8 @@ var Player = class {
     this.textChannelId = this.options.textChannelId || null;
     this.node = typeof this.options.node === "string" ? this.LavalinkManager.nodeManager.nodes.get(this.options.node) : this.options.node;
     if (!this.node || typeof this.node.request !== "function") {
-      if (typeof this.options.node === "string") {
-        this._emitDebugEvent("PlayerCreateNodeNotFound" /* PlayerCreateNodeNotFound */, {
+      if (typeof this.options.node === "string" && this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerCreateNodeNotFound" /* PlayerCreateNodeNotFound */, {
           state: "warn",
           message: `Player was created with provided node Id: ${this.options.node}, but no node with that Id was found.`,
           functionLayer: "Player > constructor()"
@@ -4084,11 +3997,13 @@ var Player = class {
    */
   async play(options = {}) {
     if (this.get("internal_queueempty")) {
-      this._emitDebugEvent("PlayerPlayQueueEmptyTimeoutClear" /* PlayerPlayQueueEmptyTimeoutClear */, {
-        state: "log",
-        message: `Player was called to play something, while there was a queueEmpty Timeout set, clearing the timeout.`,
-        functionLayer: "Player > play()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerPlayQueueEmptyTimeoutClear" /* PlayerPlayQueueEmptyTimeoutClear */, {
+          state: "log",
+          message: `Player was called to play something, while there was a queueEmpty Timeout set, clearing the timeout.`,
+          functionLayer: "Player > play()"
+        });
+      }
       this.LavalinkManager.emit("playerQueueEmptyCancel", this);
       clearTimeout(this.get("internal_queueempty"));
       this.set("internal_queueempty", void 0);
@@ -4098,12 +4013,14 @@ var Player = class {
         try {
           await options.clientTrack.resolve(this);
         } catch (error) {
-          this._emitDebugEvent("PlayerPlayUnresolvedTrackFailed" /* PlayerPlayUnresolvedTrackFailed */, {
-            state: "error",
-            error,
-            message: `Player Play was called with clientTrack, Song is unresolved, but couldn't resolve it`,
-            functionLayer: "Player > play() > resolve currentTrack"
-          });
+          if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+            this.LavalinkManager.emit("debug", "PlayerPlayUnresolvedTrackFailed" /* PlayerPlayUnresolvedTrackFailed */, {
+              state: "error",
+              error,
+              message: `Player Play was called with clientTrack, Song is unresolved, but couldn't resolve it`,
+              functionLayer: "Player > play() > resolve currentTrack"
+            });
+          }
           this.LavalinkManager.emit("trackError", this, this.queue.current, error);
           if (options && "clientTrack" in options) delete options.clientTrack;
           if (options && "track" in options) delete options.track;
@@ -4140,11 +4057,13 @@ var Player = class {
           ...options.track.userData
         }
       }).filter((v) => typeof v[1] !== "undefined"));
-      this._emitDebugEvent("PlayerPlayWithTrackReplace" /* PlayerPlayWithTrackReplace */, {
-        state: "log",
-        message: `Player was called to play something, with a specific track provided. Replacing the current Track and resolving the track on trackStart Event.`,
-        functionLayer: "Player > play()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerPlayWithTrackReplace" /* PlayerPlayWithTrackReplace */, {
+          state: "log",
+          message: `Player was called to play something, with a specific track provided. Replacing the current Track and resolving the track on trackStart Event.`,
+          functionLayer: "Player > play()"
+        });
+      }
       return this.node.updatePlayer({
         guildId: this.guildId,
         noReplace: false,
@@ -4161,11 +4080,13 @@ var Player = class {
     }
     if (!this.queue.current && this.queue.tracks.length) await queueTrackEnd(this);
     if (this.queue.current && this.LavalinkManager.utils.isUnresolvedTrack(this.queue.current)) {
-      this._emitDebugEvent("PlayerPlayUnresolvedTrack" /* PlayerPlayUnresolvedTrack */, {
-        state: "log",
-        message: `Player Play was called, current Queue Song is unresolved, resolving the track.`,
-        functionLayer: "Player > play()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerPlayUnresolvedTrack" /* PlayerPlayUnresolvedTrack */, {
+          state: "log",
+          message: `Player Play was called, current Queue Song is unresolved, resolving the track.`,
+          functionLayer: "Player > play()"
+        });
+      }
       try {
         await this.queue.current.resolve(this);
         if (typeof options.track?.userData === "object" && this.queue.current) this.queue.current.userData = {
@@ -4174,12 +4095,14 @@ var Player = class {
           ...options.track?.userData
         };
       } catch (error) {
-        this._emitDebugEvent("PlayerPlayUnresolvedTrackFailed" /* PlayerPlayUnresolvedTrackFailed */, {
-          state: "error",
-          error,
-          message: `Player Play was called, current Queue Song is unresolved, but couldn't resolve it`,
-          functionLayer: "Player > play() > resolve currentTrack"
-        });
+        if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+          this.LavalinkManager.emit("debug", "PlayerPlayUnresolvedTrackFailed" /* PlayerPlayUnresolvedTrackFailed */, {
+            state: "error",
+            error,
+            message: `Player Play was called, current Queue Song is unresolved, but couldn't resolve it`,
+            functionLayer: "Player > play() > resolve currentTrack"
+          });
+        }
         this.LavalinkManager.emit("trackError", this, this.queue.current, error);
         if (options && "clientTrack" in options) delete options.clientTrack;
         if (options && "track" in options) delete options.track;
@@ -4240,11 +4163,13 @@ var Player = class {
     ), 1e3), 0));
     const now = performance.now();
     if (this.LavalinkManager.options.playerOptions.applyVolumeAsFilter) {
-      this._emitDebugEvent("PlayerVolumeAsFilter" /* PlayerVolumeAsFilter */, {
-        state: "log",
-        message: `Player Volume was set as a Filter, because LavalinkManager option "playerOptions.applyVolumeAsFilter" is true`,
-        functionLayer: "Player > setVolume()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerVolumeAsFilter" /* PlayerVolumeAsFilter */, {
+          state: "log",
+          message: `Player Volume was set as a Filter, because LavalinkManager option "playerOptions.applyVolumeAsFilter" is true`,
+          functionLayer: "Player > setVolume()"
+        });
+      }
       await this.node.updatePlayer({ guildId: this.guildId, playerOptions: { filters: { volume: this.lavalinkVolume / 100 } } });
     } else {
       await this.node.updatePlayer({ guildId: this.guildId, playerOptions: { volume: this.lavalinkVolume } });
@@ -4289,11 +4214,13 @@ var Player = class {
   async search(query, requestUser, throwOnEmpty = false) {
     const Query = this.LavalinkManager.utils.transformQuery(query);
     if (["bcsearch", "bandcamp"].includes(Query.source) && !this.node.info?.sourceManagers.includes("bandcamp")) {
-      this._emitDebugEvent("BandcampSearchLokalEngine" /* BandcampSearchLokalEngine */, {
-        state: "log",
-        message: `Player.search was called with a Bandcamp Query, but no bandcamp search was enabled on lavalink, searching with the custom Search Engine.`,
-        functionLayer: "Player > search()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "BandcampSearchLokalEngine" /* BandcampSearchLokalEngine */, {
+          state: "log",
+          message: `Player.search was called with a Bandcamp Query, but no bandcamp search was enabled on lavalink, searching with the custom Search Engine.`,
+          functionLayer: "Player > search()"
+        });
+      }
       return await bandCampSearch(this, Query.query, requestUser);
     }
     return this.node.search(Query, requestUser, throwOnEmpty);
@@ -4445,11 +4372,13 @@ var Player = class {
       this.set("internal_queueempty", void 0);
     }
     if (this.get("internal_destroystatus") === true) {
-      this._emitDebugEvent("PlayerDestroyingSomewhereElse" /* PlayerDestroyingSomewhereElse */, {
-        state: "warn",
-        message: `Player is already destroying somewhere else..`,
-        functionLayer: "Player > destroy()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerDestroyingSomewhereElse" /* PlayerDestroyingSomewhereElse */, {
+          state: "warn",
+          message: `Player is already destroying somewhere else..`,
+          functionLayer: "Player > destroy()"
+        });
+      }
       if (this.LavalinkManager.options.advancedOptions?.debugOptions.playerDestroy.debugLog) console.log(`Lavalink-Client-Debug | PlayerDestroy [::] destroy Function, [guildId ${this.guildId}] - Already destroying somewhere else..`);
       return;
     }
@@ -4542,15 +4471,17 @@ var Player = class {
         const missingSources = [...trackSources].filter(
           (source) => !updateNode.info?.sourceManagers.includes(source)
         );
-        if (this.LavalinkManager.options.autoChecks?.sourcesValidations && missingSources.length)
+        if (missingSources.length)
           throw new RangeError(`Sources missing for Node ${updateNode.id}: ${missingSources.join(", ")}`);
       }
     }
-    this._emitDebugEvent("PlayerChangeNode" /* PlayerChangeNode */, {
-      state: "log",
-      message: `Player.changeNode() was executed, trying to change from "${this.node.id}" to "${updateNode.id}"`,
-      functionLayer: "Player > changeNode()"
-    });
+    if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+      this.LavalinkManager.emit("debug", "PlayerChangeNode" /* PlayerChangeNode */, {
+        state: "log",
+        message: `Player.changeNode() was executed, trying to change from "${this.node.id}" to "${updateNode.id}"`,
+        functionLayer: "Player > changeNode()"
+      });
+    }
     const data = this.toJSON();
     const currentTrack = this.queue.current;
     if (!this.voice.endpoint || !this.voice.sessionId || !this.voice.token)
@@ -4561,26 +4492,30 @@ var Player = class {
     const now = performance.now();
     try {
       await this.connect();
-      const hasSponsorBlock = !this.LavalinkManager.options?.autoChecks?.pluginValidations || this.node.info?.plugins?.find((v) => v.name === "sponsorblock-plugin");
+      const hasSponsorBlock = this.node.info?.plugins?.find((v) => v.name === "sponsorblock-plugin");
       if (hasSponsorBlock) {
         const sponsorBlockCategories = this.get("internal_sponsorBlockCategories");
         if (Array.isArray(sponsorBlockCategories) && sponsorBlockCategories.length) {
           await this.setSponsorBlock(sponsorBlockCategories).catch((error) => {
-            this._emitDebugEvent("PlayerChangeNode" /* PlayerChangeNode */, {
-              state: "error",
-              error,
-              message: `Player > changeNode() Unable to set SponsorBlock Segments`,
-              functionLayer: "Player > changeNode()"
-            });
+            if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+              this.LavalinkManager.emit("debug", "PlayerChangeNode" /* PlayerChangeNode */, {
+                state: "error",
+                error,
+                message: `Player > changeNode() Unable to set SponsorBlock Segments`,
+                functionLayer: "Player > changeNode()"
+              });
+            }
           });
         } else {
           await this.setSponsorBlock().catch((error) => {
-            this._emitDebugEvent("PlayerChangeNode" /* PlayerChangeNode */, {
-              state: "error",
-              error,
-              message: `Player > changeNode() Unable to set SponsorBlock Segments`,
-              functionLayer: "Player > changeNode()"
-            });
+            if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+              this.LavalinkManager.emit("debug", "PlayerChangeNode" /* PlayerChangeNode */, {
+                state: "error",
+                error,
+                message: `Player > changeNode() Unable to set SponsorBlock Segments`,
+                functionLayer: "Player > changeNode()"
+              });
+            }
           });
         }
       }
@@ -4605,27 +4540,25 @@ var Player = class {
       this.ping.lavalink = Math.round((performance.now() - now) / 10) / 100;
       return this.node.id;
     } catch (error) {
-      this._emitDebugEvent("PlayerChangeNode" /* PlayerChangeNode */, {
-        state: "error",
-        error,
-        message: `Player.changeNode() execution failed`,
-        functionLayer: "Player > changeNode()"
-      });
+      if (this.LavalinkManager.options?.advancedOptions?.enableDebugEvents) {
+        this.LavalinkManager.emit("debug", "PlayerChangeNode" /* PlayerChangeNode */, {
+          state: "error",
+          error,
+          message: `Player.changeNode() execution failed`,
+          functionLayer: "Player > changeNode()"
+        });
+      }
       throw new Error(`Failed to change the node: ${error}`);
     } finally {
       this.set("internal_nodeChanging", void 0);
     }
   }
   /**
-   * (Wrapper-FN for changeNode) Move the player to a different node. If no node is provided, it will find the least used node that is not the same as the current node.
+   * Move the player to a different node. If no node is provided, it will find the least used node that is not the same as the current node.
    * @param node the id of the node to move to
    * @returns the player
    * @throws RangeError if there is no available nodes.
    * @throws Error if the node to move to is the same as the current node.
-   * @example
-   * ```ts
-   * const newNodeMovedTo = await player.moveNode(); // no need to specify the new node, it will find a least used node automatically, but you can ofc. use a custom node id.
-   * ```
    */
   async moveNode(node) {
     try {
@@ -4661,7 +4594,8 @@ var Player = class {
       nodeId: this.node?.id,
       nodeSessionId: this.node?.sessionId,
       ping: this.ping,
-      queue: this.queue.utils.toJSON()
+      queue: this.queue.utils.toJSON(),
+      data: this.data
     };
   }
 };
@@ -4736,10 +4670,6 @@ var LavalinkManager = class extends EventEmitter2 {
         id: options?.client?.id,
         username: options?.client?.username ?? "lavalink-client"
       },
-      autoChecks: {
-        sourcesValidations: options?.autoChecks?.sourcesValidations ?? true,
-        pluginValidations: options?.autoChecks?.pluginValidations ?? true
-      },
       sendToShard: options?.sendToShard,
       autoMove: options?.autoMove ?? false,
       nodes: options?.nodes,
@@ -4803,8 +4733,6 @@ var LavalinkManager = class extends EventEmitter2 {
     if (options?.autoSkipOnResolveError && typeof options?.autoSkipOnResolveError !== "boolean") throw new SyntaxError("ManagerOption.autoSkipOnResolveError must be either false | true aka boolean");
     if (options?.emitNewSongsOnly && typeof options?.emitNewSongsOnly !== "boolean") throw new SyntaxError("ManagerOption.emitNewSongsOnly must be either false | true aka boolean");
     if (!options?.nodes || !Array.isArray(options?.nodes) || !options?.nodes.every((node) => this.utils.isNodeOptions(node))) throw new SyntaxError("ManagerOption.nodes must be an Array of NodeOptions and is required of at least 1 Node");
-    if (typeof options?.autoChecks?.sourcesValidations !== "boolean") throw new SyntaxError("ManagerOption.autoChecks.sourcesValidations must be either false | true aka boolean");
-    if (typeof options?.autoChecks?.pluginValidations !== "boolean") throw new SyntaxError("ManagerOption.autoChecks.pluginValidations must be either false | true aka boolean");
     if (options?.queueOptions?.queueStore) {
       const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(options?.queueOptions?.queueStore));
       const requiredKeys = ["get", "set", "stringify", "parse", "delete"];
@@ -4817,15 +4745,6 @@ var LavalinkManager = class extends EventEmitter2 {
     }
     if (typeof options?.queueOptions?.maxPreviousTracks !== "number" || options?.queueOptions?.maxPreviousTracks < 0) options.queueOptions.maxPreviousTracks = 25;
   }
-  /**
-   * Emits a debug event to the LavalinkManager
-   * @param name name of the event
-   * @param eventData event data
-   */
-  _emitDebugEvent(name, eventData) {
-    if (!this.options?.advancedOptions?.enableDebugEvents) return;
-    this.emit("debug", name, eventData);
-  }
   /**
    * Create the Lavalink Manager
    * @param options
@@ -4975,11 +4894,13 @@ var LavalinkManager = class extends EventEmitter2 {
     if (!oldPlayer) return;
     if (typeof oldPlayer.voiceChannelId === "string" && oldPlayer.connected && !oldPlayer.get("internal_destroywithoutdisconnect")) {
       if (!this.options?.advancedOptions?.debugOptions?.playerDestroy?.dontThrowError) throw new Error(`Use Player#destroy() not LavalinkManager#deletePlayer() to stop the Player ${safeStringify(oldPlayer.toJSON?.())}`);
-      this._emitDebugEvent("PlayerDeleteInsteadOfDestroy" /* PlayerDeleteInsteadOfDestroy */, {
-        state: "warn",
-        message: "Use Player#destroy() not LavalinkManager#deletePlayer() to stop the Player",
-        functionLayer: "LavalinkManager > deletePlayer()"
-      });
+      else if (this.options?.advancedOptions?.enableDebugEvents) {
+        this.emit("debug", "PlayerDeleteInsteadOfDestroy" /* PlayerDeleteInsteadOfDestroy */, {
+          state: "warn",
+          message: "Use Player#destroy() not LavalinkManager#deletePlayer() to stop the Player",
+          functionLayer: "LavalinkManager > deletePlayer()"
+        });
+      }
     }
     return this.players.delete(guildId);
   }
@@ -5027,11 +4948,13 @@ var LavalinkManager = class extends EventEmitter2 {
       }
     }
     if (success > 0) this.initiated = true;
-    else this._emitDebugEvent("FailedToConnectToNodes" /* FailedToConnectToNodes */, {
-      state: "error",
-      message: "Failed to connect to at least 1 Node",
-      functionLayer: "LavalinkManager > init()"
-    });
+    else if (this.options?.advancedOptions?.enableDebugEvents) {
+      this.emit("debug", "FailedToConnectToNodes" /* FailedToConnectToNodes */, {
+        state: "error",
+        message: "Failed to connect to at least 1 Node",
+        functionLayer: "LavalinkManager > init()"
+      });
+    }
     return this;
   }
   /**
@@ -5051,20 +4974,24 @@ var LavalinkManager = class extends EventEmitter2 {
    */
   async sendRawData(data) {
     if (!this.initiated) {
-      this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-        state: "log",
-        message: "Manager is not initated yet",
-        functionLayer: "LavalinkManager > sendRawData()"
-      });
+      if (this.options?.advancedOptions?.enableDebugEvents) {
+        this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+          state: "log",
+          message: "Manager is not initated yet",
+          functionLayer: "LavalinkManager > sendRawData()"
+        });
+      }
       if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, manager is not initated yet");
       return;
     }
     if (!("t" in data)) {
-      this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-        state: "error",
-        message: "No 't' in payload-data of the raw event:",
-        functionLayer: "LavalinkManager > sendRawData()"
-      });
+      if (this.options?.advancedOptions?.enableDebugEvents) {
+        this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+          state: "error",
+          message: "No 't' in payload-data of the raw event:",
+          functionLayer: "LavalinkManager > sendRawData()"
+        });
+      }
       if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, no 't' in payload-data of the raw event:", data);
       return;
     }
@@ -5077,39 +5004,47 @@ var LavalinkManager = class extends EventEmitter2 {
     if (["VOICE_STATE_UPDATE", "VOICE_SERVER_UPDATE"].includes(data.t)) {
       const update = "d" in data ? data.d : data;
       if (!update) {
-        this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-          state: "warn",
-          message: `No Update data found in payload :: ${safeStringify(data, 2)}`,
-          functionLayer: "LavalinkManager > sendRawData()"
-        });
+        if (this.options?.advancedOptions?.enableDebugEvents) {
+          this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+            state: "warn",
+            message: `No Update data found in payload :: ${safeStringify(data, 2)}`,
+            functionLayer: "LavalinkManager > sendRawData()"
+          });
+        }
         if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, no update data found in payload:", data);
         return;
       }
       if (!("token" in update) && !("session_id" in update)) {
-        this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-          state: "error",
-          message: `No 'token' nor 'session_id' found in payload :: ${safeStringify(data, 2)}`,
-          functionLayer: "LavalinkManager > sendRawData()"
-        });
+        if (this.options?.advancedOptions?.enableDebugEvents) {
+          this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+            state: "error",
+            message: `No 'token' nor 'session_id' found in payload :: ${safeStringify(data, 2)}`,
+            functionLayer: "LavalinkManager > sendRawData()"
+          });
+        }
         if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, no 'token' nor 'session_id' found in payload:", data);
         return;
       }
       const player = this.getPlayer(update.guild_id);
       if (!player) {
-        this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-          state: "warn",
-          message: `No Lavalink Player found via key: 'guild_id' of update-data :: ${safeStringify(update, 2)}`,
-          functionLayer: "LavalinkManager > sendRawData()"
-        });
+        if (this.options?.advancedOptions?.enableDebugEvents) {
+          this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+            state: "warn",
+            message: `No Lavalink Player found via key: 'guild_id' of update-data :: ${safeStringify(update, 2)}`,
+            functionLayer: "LavalinkManager > sendRawData()"
+          });
+        }
         if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, No Lavalink Player found via key: 'guild_id' of update-data:", update);
         return;
       }
       if (player.get("internal_destroystatus") === true) {
-        this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-          state: "warn",
-          message: `Player is in a destroying state. can't signal the voice states`,
-          functionLayer: "LavalinkManager > sendRawData()"
-        });
+        if (this.options?.advancedOptions?.enableDebugEvents) {
+          this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+            state: "warn",
+            message: `Player is in a destroying state. can't signal the voice states`,
+            functionLayer: "LavalinkManager > sendRawData()"
+          });
+        }
         if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, Player is in a destroying state. can't signal the voice states");
         return;
       }
@@ -5134,11 +5069,13 @@ var LavalinkManager = class extends EventEmitter2 {
               }
             }
           });
-          this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-            state: "log",
-            message: `Sent updatePlayer for voice token session :: ${safeStringify({ voice: { token: update.token, endpoint: update.endpoint, sessionId: sessionId2Use }, update, playerVoice: player.voice }, 2)}`,
-            functionLayer: "LavalinkManager > sendRawData()"
-          });
+          if (this.options?.advancedOptions?.enableDebugEvents) {
+            this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+              state: "log",
+              message: `Sent updatePlayer for voice token session :: ${safeStringify({ voice: { token: update.token, endpoint: update.endpoint, sessionId: sessionId2Use }, update, playerVoice: player.voice }, 2)}`,
+              functionLayer: "LavalinkManager > sendRawData()"
+            });
+          }
           if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, Sent updatePlayer for voice token session", { voice: { token: update.token, endpoint: update.endpoint, sessionId: sessionId2Use }, playerVoice: player.voice, update });
         }
         return;
@@ -5147,11 +5084,13 @@ var LavalinkManager = class extends EventEmitter2 {
         if (update.user_id && player.voiceChannelId) {
           this.emit(update.channel_id === player.voiceChannelId ? "playerVoiceJoin" : "playerVoiceLeave", player, update.user_id);
         }
-        this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-          state: "warn",
-          message: `voice update user is not equal to provided client id of the LavalinkManager.options.client.id :: user: "${update.user_id}" manager client id: "${this.options?.client.id}"`,
-          functionLayer: "LavalinkManager > sendRawData()"
-        });
+        if (this.options?.advancedOptions?.enableDebugEvents) {
+          this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+            state: "warn",
+            message: `voice update user is not equal to provided client id of the LavalinkManager.options.client.id :: user: "${update.user_id}" manager client id: "${this.options?.client.id}"`,
+            functionLayer: "LavalinkManager > sendRawData()"
+          });
+        }
         if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug("Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, voice update user is not equal to provided client id of the manageroptions#client#id", "user:", update.user_id, "manager client id:", this.options?.client.id);
         return;
       }
@@ -5159,11 +5098,13 @@ var LavalinkManager = class extends EventEmitter2 {
         if (player.voiceChannelId !== update.channel_id) this.emit("playerMove", player, player.voiceChannelId, update.channel_id);
         player.voice.sessionId = update.session_id || player.voice.sessionId;
         if (!player.voice.sessionId) {
-          this._emitDebugEvent("NoAudioDebug" /* NoAudioDebug */, {
-            state: "warn",
-            message: `Function to assing sessionId provided, but no found in Payload: ${safeStringify({ update, playerVoice: player.voice }, 2)}`,
-            functionLayer: "LavalinkManager > sendRawData()"
-          });
+          if (this.options?.advancedOptions?.enableDebugEvents) {
+            this.emit("debug", "NoAudioDebug" /* NoAudioDebug */, {
+              state: "warn",
+              message: `Function to assing sessionId provided, but no found in Payload: ${safeStringify({ update, playerVoice: player.voice }, 2)}`,
+              functionLayer: "LavalinkManager > sendRawData()"
+            });
+          }
           if (this.options?.advancedOptions?.debugOptions?.noAudio === true) console.debug(`Lavalink-Client-Debug | NO-AUDIO [::] sendRawData function, Function to assing sessionId provided, but no found in Payload: ${safeStringify(update, 2)}`);
         }
         player.voiceChannelId = update.channel_id;
@@ -5194,11 +5135,13 @@ var LavalinkManager = class extends EventEmitter2 {
           try {
             const previousPosition = player.position;
             const previousPaused = player.paused;
-            this._emitDebugEvent("PlayerAutoReconnect" /* PlayerAutoReconnect */, {
-              state: "log",
-              message: `Auto reconnecting player because LavalinkManager.options.playerOptions.onDisconnect.autoReconnect is true`,
-              functionLayer: "LavalinkManager > sendRawData()"
-            });
+            if (this.options?.advancedOptions?.enableDebugEvents) {
+              this.emit("debug", "PlayerAutoReconnect" /* PlayerAutoReconnect */, {
+                state: "log",
+                message: `Auto reconnecting player because LavalinkManager.options.playerOptions.onDisconnect.autoReconnect is true`,
+                functionLayer: "LavalinkManager > sendRawData()"
+              });
+            }
             if (!autoReconnectOnlyWithTracks || autoReconnectOnlyWithTracks && (player.queue.current || player.queue.tracks.length)) {
               await player.connect();
             }
@@ -5208,11 +5151,13 @@ var LavalinkManager = class extends EventEmitter2 {
             if (player.queue.tracks.length) {
               return void await player.play({ paused: previousPaused });
             }
-            this._emitDebugEvent("PlayerAutoReconnect" /* PlayerAutoReconnect */, {
-              state: "log",
-              message: `Auto reconnected, but nothing to play`,
-              functionLayer: "LavalinkManager > sendRawData()"
-            });
+            if (this.options?.advancedOptions?.enableDebugEvents) {
+              this.emit("debug", "PlayerAutoReconnect" /* PlayerAutoReconnect */, {
+                state: "log",
+                message: `Auto reconnected, but nothing to play`,
+                functionLayer: "LavalinkManager > sendRawData()"
+              });
+            }
             return;
           } catch (e) {
             console.error(e);
